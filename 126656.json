{"path":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","commits":[{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, false);\n      } else {\n        hits = s.search(f, hitCount, sort, false);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, false);\n      } else {\n        hits = s.search(f, hitCount, sort, false);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" ; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, false);\n      } else {\n        hits = s.search(f, hitCount, sort, false);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["0e121d43b5a10f2df530f406f935102656e9c4e8","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"83870855d82aba6819217abeff5a40779dbb28b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"]},"commit2Childs":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"0e121d43b5a10f2df530f406f935102656e9c4e8":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1d3f7ab1a502671bbdb03bcced21e764d2483221"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}