{"path":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","commits":[{"id":"e7533828cbcc5f498a44cca5d9bce92692663778","date":1408525002,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n            classCounts.put(cl, count + 1);\n        } else {\n            classCounts.put(cl, 1);\n        }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc=0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n        Integer count = entry.getValue();\n        returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n        sumdoc+=count;\n\n    }\n    \n    //correction\n    if(sumdoc<k){\n      for(ClassificationResult<BytesRef> cr:returnList){\n        cr.setScore(cr.getScore()*(double)k/(double)sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3b2d9bc464ed9ae5113f93c943d3954ee6078e0","date":1415781602,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : returnList) {\n        cr.setScore(cr.getScore() * (double) k / (double) sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","sourceOld":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n            classCounts.put(cl, count + 1);\n        } else {\n            classCounts.put(cl, 1);\n        }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc=0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n        Integer count = entry.getValue();\n        returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n        sumdoc+=count;\n\n    }\n    \n    //correction\n    if(sumdoc<k){\n      for(ClassificationResult<BytesRef> cr:returnList){\n        cr.setScore(cr.getScore()*(double)k/(double)sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"360ff513ddb24a30ffa2111a3ef0f91038803100","date":1430403123,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : returnList) {\n        cr.setScore(cr.getScore() * (double) k / (double) sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","sourceOld":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : returnList) {\n        cr.setScore(cr.getScore() * (double) k / (double) sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"805a01fd60dd540fc1326f9886d8cc985647f38e","date":1430733992,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      returnList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : returnList) {\n        cr.setScore(cr.getScore() * (double) k / (double) sumdoc);\n      }\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9dcf48d9030d73fb294fb586dc4c0bb879b80c8","date":1438605505,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), count / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"134a24d0cb66520908d88384f1a559875704ed25","date":1445326601,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d480d446945fb66f3dfe71fbaf0ba3ac41aae3f","date":1445328810,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      StorableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bccc45dd8c1b6c02b164d20d9e383575c74659a","date":1480027580,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75babd1dfc2521603bfeb0968042e921d8c6c652","date":1480042089,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33bfee30277584028170135002def66f9d57732b","date":1547842233,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n          classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52ec154a31cf63bc47d2cc0b49e171a4e75aa99d","date":1548322018,"type":3,"author":"Tommaso Teofili","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n          classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  //ranking of classes must be taken in consideration\n  /**\n   * build a list of classification results from search results\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);\n      for (IndexableField singleStorableField : storableFields) {\n        if (singleStorableField != null) {\n          BytesRef cl = new BytesRef(singleStorableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75babd1dfc2521603bfeb0968042e921d8c6c652":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","9bccc45dd8c1b6c02b164d20d9e383575c74659a"],"d9dcf48d9030d73fb294fb586dc4c0bb879b80c8":["805a01fd60dd540fc1326f9886d8cc985647f38e"],"9bccc45dd8c1b6c02b164d20d9e383575c74659a":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"134a24d0cb66520908d88384f1a559875704ed25":["d9dcf48d9030d73fb294fb586dc4c0bb879b80c8"],"33bfee30277584028170135002def66f9d57732b":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"360ff513ddb24a30ffa2111a3ef0f91038803100":["c3b2d9bc464ed9ae5113f93c943d3954ee6078e0"],"52ec154a31cf63bc47d2cc0b49e171a4e75aa99d":["83788ad129a5154d5c6562c4e8ce3db48793aada","33bfee30277584028170135002def66f9d57732b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["75babd1dfc2521603bfeb0968042e921d8c6c652","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"727bb765ff2542275f6d31f67be18d7104bae148":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","75babd1dfc2521603bfeb0968042e921d8c6c652"],"e7533828cbcc5f498a44cca5d9bce92692663778":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"805a01fd60dd540fc1326f9886d8cc985647f38e":["360ff513ddb24a30ffa2111a3ef0f91038803100"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["75babd1dfc2521603bfeb0968042e921d8c6c652"],"5d480d446945fb66f3dfe71fbaf0ba3ac41aae3f":["134a24d0cb66520908d88384f1a559875704ed25"],"c3b2d9bc464ed9ae5113f93c943d3954ee6078e0":["e7533828cbcc5f498a44cca5d9bce92692663778"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["52ec154a31cf63bc47d2cc0b49e171a4e75aa99d"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["5d480d446945fb66f3dfe71fbaf0ba3ac41aae3f"]},"commit2Childs":{"75babd1dfc2521603bfeb0968042e921d8c6c652":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","727bb765ff2542275f6d31f67be18d7104bae148","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"d9dcf48d9030d73fb294fb586dc4c0bb879b80c8":["134a24d0cb66520908d88384f1a559875704ed25"],"9bccc45dd8c1b6c02b164d20d9e383575c74659a":["75babd1dfc2521603bfeb0968042e921d8c6c652"],"134a24d0cb66520908d88384f1a559875704ed25":["5d480d446945fb66f3dfe71fbaf0ba3ac41aae3f"],"33bfee30277584028170135002def66f9d57732b":["52ec154a31cf63bc47d2cc0b49e171a4e75aa99d"],"360ff513ddb24a30ffa2111a3ef0f91038803100":["805a01fd60dd540fc1326f9886d8cc985647f38e"],"52ec154a31cf63bc47d2cc0b49e171a4e75aa99d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"727bb765ff2542275f6d31f67be18d7104bae148":[],"e7533828cbcc5f498a44cca5d9bce92692663778":["c3b2d9bc464ed9ae5113f93c943d3954ee6078e0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e7533828cbcc5f498a44cca5d9bce92692663778"],"805a01fd60dd540fc1326f9886d8cc985647f38e":["d9dcf48d9030d73fb294fb586dc4c0bb879b80c8"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["33bfee30277584028170135002def66f9d57732b","52ec154a31cf63bc47d2cc0b49e171a4e75aa99d"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"5d480d446945fb66f3dfe71fbaf0ba3ac41aae3f":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"c3b2d9bc464ed9ae5113f93c943d3954ee6078e0":["360ff513ddb24a30ffa2111a3ef0f91038803100"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["75babd1dfc2521603bfeb0968042e921d8c6c652","9bccc45dd8c1b6c02b164d20d9e383575c74659a","727bb765ff2542275f6d31f67be18d7104bae148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}