{"path":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","commits":[{"id":"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","date":1436588269,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0806aac02ecbbdc6b5d9705ae15da193219c7af4","date":1499930856,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified \" + createNodeList + \" are not currently active in \"\n                + nodeNameVsShardCount.keySet() + \", no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified are not currently active, no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified \" + createNodeList + \" are not currently active in \"\n                + nodeNameVsShardCount.keySet() + \", no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified \" + createNodeList + \" are not currently active in \"\n                + nodeNameVsShardCount.keySet() + \", no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodeNameVsShardCount(String,ClusterState,List[String]).mjava","sourceNew":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified \" + createNodeList + \" are not currently active in \"\n                + nodeNameVsShardCount.keySet() + \", no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","sourceOld":"  private static HashMap<String, ReplicaCount> getNodeNameVsShardCount(String collectionName,\n                                                                       ClusterState clusterState, List<String> createNodeList) {\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = new HashMap<>();\n    for (String s : nodeList) {\n      nodeNameVsShardCount.put(s, new ReplicaCount(s));\n    }\n    if (createNodeList != null) { // Overrides petty considerations about maxShardsPerNode\n      if (createNodeList.size() != nodeNameVsShardCount.size()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"At least one of the node(s) specified \" + createNodeList + \" are not currently active in \"\n                + nodeNameVsShardCount.keySet() + \", no action taken.\");\n      }\n      return nodeNameVsShardCount;\n    }\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n    for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n      DocCollection c = entry.getValue();\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          ReplicaCount count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++; // Used ot \"weigh\" whether this node should be used later.\n            if (entry.getKey().equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    return nodeNameVsShardCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["73450c0955930295d34703e7ddbfc6973b7a121a","0806aac02ecbbdc6b5d9705ae15da193219c7af4"],"73450c0955930295d34703e7ddbfc6973b7a121a":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","73450c0955930295d34703e7ddbfc6973b7a121a"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"560c18d71dad43d675158783c3840f8c80d6d39c":["73450c0955930295d34703e7ddbfc6973b7a121a","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["560c18d71dad43d675158783c3840f8c80d6d39c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"73450c0955930295d34703e7ddbfc6973b7a121a":["c304e97e7c1d472bc70e801b35ee78583916c6cd","7dc08f02757dd10637b16a5c65eaaef839a91a9a","0806aac02ecbbdc6b5d9705ae15da193219c7af4","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","560c18d71dad43d675158783c3840f8c80d6d39c"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"560c18d71dad43d675158783c3840f8c80d6d39c":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}