{"path":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","commits":[{"id":"be9a5d1846ac0beb625ba68da060e16119d9f51e","date":1328820081,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        @Override\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      @Override\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","sourceOld":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        @Override\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      @Override\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","sourceOld":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5ad8cb078811acf9ef38ece78171f1bfe5786de","date":1474538499,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return fieldName -> ! excludes.shouldMutate(fieldName);\n    }\n\n    return fieldName -> (includes.shouldMutate(fieldName)\n            && ! excludes.shouldMutate(fieldName));\n  }\n\n","sourceOld":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        @Override\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      @Override\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return fieldName -> ! excludes.shouldMutate(fieldName);\n    }\n\n    return fieldName -> (includes.shouldMutate(fieldName)\n            && ! excludes.shouldMutate(fieldName));\n  }\n\n","sourceOld":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        @Override\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      @Override\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor#wrap(FieldNameSelector,FieldNameSelector).mjava","sourceNew":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return fieldName -> ! excludes.shouldMutate(fieldName);\n    }\n\n    return fieldName -> (includes.shouldMutate(fieldName)\n            && ! excludes.shouldMutate(fieldName));\n  }\n\n","sourceOld":"  /** \n   * Wraps two FieldNameSelectors such that the FieldNameSelector \n   * returned matches all fields specified by the \"includes\" unless they \n   * are matched by \"excludes\"\n   * @param includes a selector identifying field names that should be selected\n   * @param excludes a selector identifying field names that should be \n   *        <i>not</i> be selected, even if they are matched by the 'includes' \n   *        selector\n   * @return Either a new FieldNameSelector or one of the input selecors \n   *         if the combination lends itself to optimization.\n   */\n  public static FieldNameSelector wrap(final FieldNameSelector includes, \n                                       final FieldNameSelector excludes) { \n\n    if (SELECT_NO_FIELDS == excludes) {\n      return includes;\n    }\n\n    if (SELECT_ALL_FIELDS == excludes) {\n      return SELECT_NO_FIELDS;\n    }\n    \n    if (SELECT_ALL_FIELDS == includes) {\n      return new FieldNameSelector() {\n        @Override\n        public boolean shouldMutate(final String fieldName) {\n          return ! excludes.shouldMutate(fieldName);\n        }\n      };\n    }\n\n    return new FieldNameSelector() {\n      @Override\n      public boolean shouldMutate(final String fieldName) {\n        return (includes.shouldMutate(fieldName)\n                && ! excludes.shouldMutate(fieldName));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["be9a5d1846ac0beb625ba68da060e16119d9f51e","7530de27b87b961b51f01bd1299b7004d46e8823"],"be9a5d1846ac0beb625ba68da060e16119d9f51e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7530de27b87b961b51f01bd1299b7004d46e8823","c5ad8cb078811acf9ef38ece78171f1bfe5786de"],"7530de27b87b961b51f01bd1299b7004d46e8823":["be9a5d1846ac0beb625ba68da060e16119d9f51e"],"c5ad8cb078811acf9ef38ece78171f1bfe5786de":["7530de27b87b961b51f01bd1299b7004d46e8823"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7530de27b87b961b51f01bd1299b7004d46e8823","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"be9a5d1846ac0beb625ba68da060e16119d9f51e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["be9a5d1846ac0beb625ba68da060e16119d9f51e"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","c5ad8cb078811acf9ef38ece78171f1bfe5786de","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c5ad8cb078811acf9ef38ece78171f1bfe5786de":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}