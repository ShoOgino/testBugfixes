{"path":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"144cd9248ef4df6739fe736179848f0b1dc05cd4","date":1310757241,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":["7d6b8491b15b391062b53404b4af3c8f18924090"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"872cff1d3a554e0cd64014cd97f88d3002b0f491","date":1323024658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b65b350ca9588f9fc76ce7d6804160d06c45ff42","date":1323026297,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"543e59b1fc2ac58a49da34c2e0df3351a111d9c8","date":1326235877,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":["28427ef110c4c5bf5b4057731b83110bd1e13724"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"197070b7f9191af8b5d8598b579393d4a67e32f0","date":1341843740,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, 0);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, 0);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, 0);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, false);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, 0);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, 0);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, IOUtils.CHARSET_UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":["28427ef110c4c5bf5b4057731b83110bd1e13724","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.FLAG_NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator(null);\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiTerms.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiLeafReader.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \", e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiTerms.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiLeafReader.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            if (log.isErrorEnabled()) {\n              log.error(\"Error loading external value source + fileName + \" + e\n                  + (otherErrors < 10 ? \"\" : \"\\tSkipping future errors for this file.\"));\n            }\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \", e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Loaded external value source \" + fname\n          + (notFoundCount == 0 ? \"\" : \" :\" + notFoundCount + \" missing keys \" + notFound));\n    }\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiTerms.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiLeafReader.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \", e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiTerms.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiLeafReader.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            log.error(\"Error loading external value source + fileName + {}{}\", e\n                , (otherErrors < 10 ? \"\" : \"\\tSkipping future errors for this file.\"));\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \", e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n    if (log.isInfoEnabled()) {\n      String tmp = (notFoundCount == 0 ? \"\" : \" :\" + notFoundCount + \" missing keys \" + notFound);\n      log.info(\"Loaded external value source {}{}\", fname, tmp);\n    }\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error opening external value source file: \", e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRefBuilder internalKey = new BytesRefBuilder();\n\n    try {\n      TermsEnum termsEnum = MultiTerms.getTerms(reader, idName).iterator();\n      PostingsEnum postingsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiLeafReader.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.lastIndexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        float fval;\n        try {\n          idType.readableToIndexed(key, internalKey);\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            if (log.isErrorEnabled()) {\n              log.error(\"Error loading external value source + fileName + \" + e\n                  + (otherErrors < 10 ? \"\" : \"\\tSkipping future errors for this file.\"));\n            }\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey.get())) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n        int doc;\n        while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      log.error(\"Error loading external value source: \", e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Loaded external value source \" + fname\n          + (notFoundCount == 0 ? \"\" : \" :\" + notFoundCount + \" missing keys \" + notFound));\n    }\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["02331260bb246364779cb6f04919ca47900d01bb","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["543e59b1fc2ac58a49da34c2e0df3351a111d9c8","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["7d89d7e4e5101347833eea558851bf4209218619"],"2acf500f78aa12b92e371fd89c719291986b6b90":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","197070b7f9191af8b5d8598b579393d4a67e32f0"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"144cd9248ef4df6739fe736179848f0b1dc05cd4":["c26f00b574427b55127e869b935845554afde1fa"],"197070b7f9191af8b5d8598b579393d4a67e32f0":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","7d89d7e4e5101347833eea558851bf4209218619"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640","19275ba31e621f6da1b83bf13af75233876fd3d4"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["543e59b1fc2ac58a49da34c2e0df3351a111d9c8"],"3cc749c053615f5871f3b95715fe292f34e70a53":["144cd9248ef4df6739fe736179848f0b1dc05cd4"],"575e66bd4b2349209027f6801184da7fc3cba13f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["3cc749c053615f5871f3b95715fe292f34e70a53"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"7d89d7e4e5101347833eea558851bf4209218619":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"51f5280f31484820499077f41fcdfe92d527d9dc":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"46d8ada1fff8d18cb197c38c7983225162599948":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","2acf500f78aa12b92e371fd89c719291986b6b90"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["02331260bb246364779cb6f04919ca47900d01bb"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":["3cc749c053615f5871f3b95715fe292f34e70a53","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","2acf500f78aa12b92e371fd89c719291986b6b90"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["46d8ada1fff8d18cb197c38c7983225162599948","02331260bb246364779cb6f04919ca47900d01bb"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"543e59b1fc2ac58a49da34c2e0df3351a111d9c8":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"02331260bb246364779cb6f04919ca47900d01bb":["2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"c26f00b574427b55127e869b935845554afde1fa":["144cd9248ef4df6739fe736179848f0b1dc05cd4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["51f5280f31484820499077f41fcdfe92d527d9dc"],"2acf500f78aa12b92e371fd89c719291986b6b90":["46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","02331260bb246364779cb6f04919ca47900d01bb"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"144cd9248ef4df6739fe736179848f0b1dc05cd4":["3cc749c053615f5871f3b95715fe292f34e70a53"],"197070b7f9191af8b5d8598b579393d4a67e32f0":["2acf500f78aa12b92e371fd89c719291986b6b90"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","7d89d7e4e5101347833eea558851bf4209218619"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2acf500f78aa12b92e371fd89c719291986b6b90","197070b7f9191af8b5d8598b579393d4a67e32f0","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3cc749c053615f5871f3b95715fe292f34e70a53":["872cff1d3a554e0cd64014cd97f88d3002b0f491","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["b65b350ca9588f9fc76ce7d6804160d06c45ff42","543e59b1fc2ac58a49da34c2e0df3351a111d9c8"],"7d89d7e4e5101347833eea558851bf4209218619":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","5eb2511ababf862ea11e10761c70ee560cd84510"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"46d8ada1fff8d18cb197c38c7983225162599948":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"543e59b1fc2ac58a49da34c2e0df3351a111d9c8":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"02331260bb246364779cb6f04919ca47900d01bb":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","5eb2511ababf862ea11e10761c70ee560cd84510","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","b65b350ca9588f9fc76ce7d6804160d06c45ff42","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}