{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","commits":[{"id":"6ec82ee811ca4bf233f8445e727133af762a7bf0","date":1516991772,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLatchWatcher() throws InterruptedException {\n    OverseerTaskQueue.LatchWatcher latch1 = new OverseerTaskQueue.LatchWatcher();\n    long before = System.nanoTime();\n    latch1.await(100);\n    long after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) > 50);\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 500);// Mostly to make sure the millis->nanos->millis is not broken\n    latch1.process(new WatchedEvent(new WatcherEvent(1, 1, \"/foo/bar\")));\n    before = System.nanoTime();\n    latch1.await(10000);// Expecting no wait\n    after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n    \n    final AtomicBoolean expectedEventProcessed = new AtomicBoolean(false);\n    final AtomicBoolean doneWaiting = new AtomicBoolean(false);\n    final OverseerTaskQueue.LatchWatcher latch2 = new OverseerTaskQueue.LatchWatcher(Event.EventType.NodeCreated);\n    Thread t = new Thread(()->{\n      //Process an event of a different type first, this shouldn't release the latch\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeDeleted.getIntValue(), 1, \"/foo/bar\")));\n      try {\n        Thread.sleep(10);\n      } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n      assertFalse(\"Latch shouldn't have been released\", doneWaiting.get());\n      // Now process the correct type of event\n      expectedEventProcessed.set(true);\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeCreated.getIntValue(), 1, \"/foo/bar\")));\n    });\n    t.start();\n    before = System.nanoTime();\n    latch2.await(10000); // It shouldn't wait this long, t should notify the lock\n    after = System.nanoTime();\n    doneWaiting.set(true);\n    assertTrue(expectedEventProcessed.get());\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","sourceNew":"  @Test\n  public void testLatchWatcher() throws InterruptedException {\n    OverseerTaskQueue.LatchWatcher latch1 = new OverseerTaskQueue.LatchWatcher();\n    long before = System.nanoTime();\n    latch1.await(100);\n    long after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) > 50);\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 500);// Mostly to make sure the millis->nanos->millis is not broken\n    latch1.process(new WatchedEvent(new WatcherEvent(1, 1, \"/foo/bar\")));\n    before = System.nanoTime();\n    latch1.await(10000);// Expecting no wait\n    after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n    \n    final AtomicBoolean expectedEventProcessed = new AtomicBoolean(false);\n    final AtomicBoolean doneWaiting = new AtomicBoolean(false);\n    final OverseerTaskQueue.LatchWatcher latch2 = new OverseerTaskQueue.LatchWatcher(Event.EventType.NodeCreated);\n    Thread t = new Thread(()->{\n      //Process an event of a different type first, this shouldn't release the latch\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeDeleted.getIntValue(), 1, \"/foo/bar\")));\n\n      assertFalse(\"Latch shouldn't have been released\", doneWaiting.get());\n      // Now process the correct type of event\n      expectedEventProcessed.set(true);\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeCreated.getIntValue(), 1, \"/foo/bar\")));\n    });\n    t.start();\n    before = System.nanoTime();\n    latch2.await(10000); // It shouldn't wait this long, t should notify the lock\n    after = System.nanoTime();\n    doneWaiting.set(true);\n    assertTrue(expectedEventProcessed.get());\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n  }\n\n","sourceOld":"  @Test\n  public void testLatchWatcher() throws InterruptedException {\n    OverseerTaskQueue.LatchWatcher latch1 = new OverseerTaskQueue.LatchWatcher();\n    long before = System.nanoTime();\n    latch1.await(100);\n    long after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) > 50);\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 500);// Mostly to make sure the millis->nanos->millis is not broken\n    latch1.process(new WatchedEvent(new WatcherEvent(1, 1, \"/foo/bar\")));\n    before = System.nanoTime();\n    latch1.await(10000);// Expecting no wait\n    after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n    \n    final AtomicBoolean expectedEventProcessed = new AtomicBoolean(false);\n    final AtomicBoolean doneWaiting = new AtomicBoolean(false);\n    final OverseerTaskQueue.LatchWatcher latch2 = new OverseerTaskQueue.LatchWatcher(Event.EventType.NodeCreated);\n    Thread t = new Thread(()->{\n      //Process an event of a different type first, this shouldn't release the latch\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeDeleted.getIntValue(), 1, \"/foo/bar\")));\n      try {\n        Thread.sleep(10);\n      } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n      assertFalse(\"Latch shouldn't have been released\", doneWaiting.get());\n      // Now process the correct type of event\n      expectedEventProcessed.set(true);\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeCreated.getIntValue(), 1, \"/foo/bar\")));\n    });\n    t.start();\n    before = System.nanoTime();\n    latch2.await(10000); // It shouldn't wait this long, t should notify the lock\n    after = System.nanoTime();\n    doneWaiting.set(true);\n    assertTrue(expectedEventProcessed.get());\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n  }\n\n","bugFix":["6ec82ee811ca4bf233f8445e727133af762a7bf0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testLatchWatcher().mjava","sourceNew":"  @Test\n  public void testLatchWatcher() throws InterruptedException {\n    OverseerTaskQueue.LatchWatcher latch1 = new OverseerTaskQueue.LatchWatcher();\n    long before = System.nanoTime();\n    latch1.await(100);\n    long after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) > 50);\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 500);// Mostly to make sure the millis->nanos->millis is not broken\n    latch1.process(new WatchedEvent(new WatcherEvent(1, 1, \"/foo/bar\")));\n    before = System.nanoTime();\n    latch1.await(10000);// Expecting no wait\n    after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n\n    final AtomicBoolean expectedEventProcessed = new AtomicBoolean(false);\n    final AtomicBoolean doneWaiting = new AtomicBoolean(false);\n    final OverseerTaskQueue.LatchWatcher latch2 = new OverseerTaskQueue.LatchWatcher(Event.EventType.NodeCreated);\n    Thread t = new Thread(()->{\n      //Process an event of a different type first, this shouldn't release the latch\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeDeleted.getIntValue(), 1, \"/foo/bar\")));\n\n      assertFalse(\"Latch shouldn't have been released\", doneWaiting.get());\n      // Now process the correct type of event\n      expectedEventProcessed.set(true);\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeCreated.getIntValue(), 1, \"/foo/bar\")));\n    });\n    t.start();\n    before = System.nanoTime();\n    latch2.await(10000); // It shouldn't wait this long, t should notify the lock\n    after = System.nanoTime();\n    doneWaiting.set(true);\n    assertTrue(expectedEventProcessed.get());\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n  }\n\n","sourceOld":"  @Test\n  public void testLatchWatcher() throws InterruptedException {\n    OverseerTaskQueue.LatchWatcher latch1 = new OverseerTaskQueue.LatchWatcher();\n    long before = System.nanoTime();\n    latch1.await(100);\n    long after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) > 50);\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 500);// Mostly to make sure the millis->nanos->millis is not broken\n    latch1.process(new WatchedEvent(new WatcherEvent(1, 1, \"/foo/bar\")));\n    before = System.nanoTime();\n    latch1.await(10000);// Expecting no wait\n    after = System.nanoTime();\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n    \n    final AtomicBoolean expectedEventProcessed = new AtomicBoolean(false);\n    final AtomicBoolean doneWaiting = new AtomicBoolean(false);\n    final OverseerTaskQueue.LatchWatcher latch2 = new OverseerTaskQueue.LatchWatcher(Event.EventType.NodeCreated);\n    Thread t = new Thread(()->{\n      //Process an event of a different type first, this shouldn't release the latch\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeDeleted.getIntValue(), 1, \"/foo/bar\")));\n\n      assertFalse(\"Latch shouldn't have been released\", doneWaiting.get());\n      // Now process the correct type of event\n      expectedEventProcessed.set(true);\n      latch2.process(new WatchedEvent(new WatcherEvent(Event.EventType.NodeCreated.getIntValue(), 1, \"/foo/bar\")));\n    });\n    t.start();\n    before = System.nanoTime();\n    latch2.await(10000); // It shouldn't wait this long, t should notify the lock\n    after = System.nanoTime();\n    doneWaiting.set(true);\n    assertTrue(expectedEventProcessed.get());\n    assertTrue(TimeUnit.NANOSECONDS.toMillis(after-before) < 1000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6ec82ee811ca4bf233f8445e727133af762a7bf0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ec82ee811ca4bf233f8445e727133af762a7bf0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ec82ee811ca4bf233f8445e727133af762a7bf0"],"6ec82ee811ca4bf233f8445e727133af762a7bf0":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}