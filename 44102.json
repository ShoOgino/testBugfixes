{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge,SegmentInfos,AtomicReference[CountDownLatch]).mjava","commits":[{"id":"81819c5a4a660afd353042c67106e682bb877cf1","date":1583169587,"type":0,"author":"msfroh","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge,SegmentInfos,AtomicReference[CountDownLatch]).mjava","pathOld":"/dev/null","sourceNew":"  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,\n                                                                AtomicReference<CountDownLatch> mergeLatchRef) {\n    return new MergePolicy.OneMerge(merge.segments) {\n      public void mergeFinished() throws IOException {\n        super.mergeFinished();\n        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n        if (mergeAwaitLatch == null) {\n          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n          return;\n        }\n        if (isAborted() == false) {\n          deleter.incRef(this.info.files());\n          // Resolve \"live\" SegmentInfos segments to their toCommit cloned equivalents, based on segment name.\n          Set<String> mergedSegmentNames = new HashSet<>();\n          for (SegmentCommitInfo sci : this.segments) {\n            deleter.decRef(sci.files());\n            mergedSegmentNames.add(sci.info.name);\n          }\n          List<SegmentCommitInfo> toCommitMergedAwaySegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : toCommit) {\n            if (mergedSegmentNames.contains(sci.info.name)) {\n              toCommitMergedAwaySegments.add(sci);\n            }\n          }\n          // Construct a OneMerge that applies to toCommit\n          MergePolicy.OneMerge applicableMerge = new MergePolicy.OneMerge(toCommitMergedAwaySegments);\n          applicableMerge.info = this.info.clone();\n          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n          toCommit.applyMergeChanges(applicableMerge, false);\n        }\n        mergeAwaitLatch.countDown();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5","date":1583441366,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge,SegmentInfos,AtomicReference[CountDownLatch]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge,SegmentInfos,AtomicReference[CountDownLatch]).mjava","sourceNew":"  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,\n                                                                AtomicReference<CountDownLatch> mergeLatchRef) {\n    return new MergePolicy.OneMerge(merge.segments) {\n      public void mergeFinished() throws IOException {\n        super.mergeFinished();\n        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n        if (mergeAwaitLatch == null) {\n          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n          return;\n        }\n        if (committed) {\n          deleter.incRef(this.info.files());\n          // Resolve \"live\" SegmentInfos segments to their toCommit cloned equivalents, based on segment name.\n          Set<String> mergedSegmentNames = new HashSet<>();\n          for (SegmentCommitInfo sci : this.segments) {\n            deleter.decRef(sci.files());\n            mergedSegmentNames.add(sci.info.name);\n          }\n          List<SegmentCommitInfo> toCommitMergedAwaySegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : toCommit) {\n            if (mergedSegmentNames.contains(sci.info.name)) {\n              toCommitMergedAwaySegments.add(sci);\n            }\n          }\n          // Construct a OneMerge that applies to toCommit\n          MergePolicy.OneMerge applicableMerge = new MergePolicy.OneMerge(toCommitMergedAwaySegments);\n          applicableMerge.info = this.info.clone();\n          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n          toCommit.applyMergeChanges(applicableMerge, false);\n        }\n        mergeAwaitLatch.countDown();\n      }\n    };\n  }\n\n","sourceOld":"  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,\n                                                                AtomicReference<CountDownLatch> mergeLatchRef) {\n    return new MergePolicy.OneMerge(merge.segments) {\n      public void mergeFinished() throws IOException {\n        super.mergeFinished();\n        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n        if (mergeAwaitLatch == null) {\n          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n          return;\n        }\n        if (isAborted() == false) {\n          deleter.incRef(this.info.files());\n          // Resolve \"live\" SegmentInfos segments to their toCommit cloned equivalents, based on segment name.\n          Set<String> mergedSegmentNames = new HashSet<>();\n          for (SegmentCommitInfo sci : this.segments) {\n            deleter.decRef(sci.files());\n            mergedSegmentNames.add(sci.info.name);\n          }\n          List<SegmentCommitInfo> toCommitMergedAwaySegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : toCommit) {\n            if (mergedSegmentNames.contains(sci.info.name)) {\n              toCommitMergedAwaySegments.add(sci);\n            }\n          }\n          // Construct a OneMerge that applies to toCommit\n          MergePolicy.OneMerge applicableMerge = new MergePolicy.OneMerge(toCommitMergedAwaySegments);\n          applicableMerge.info = this.info.clone();\n          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n          toCommit.applyMergeChanges(applicableMerge, false);\n        }\n        mergeAwaitLatch.countDown();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba192a321314de8edbe20b279eee9c471b16b48b","date":1583706474,"type":4,"author":"Michael Sokolov","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge,SegmentInfos,AtomicReference[CountDownLatch]).mjava","sourceNew":null,"sourceOld":"  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,\n                                                                AtomicReference<CountDownLatch> mergeLatchRef) {\n    return new MergePolicy.OneMerge(merge.segments) {\n      public void mergeFinished() throws IOException {\n        super.mergeFinished();\n        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n        if (mergeAwaitLatch == null) {\n          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n          return;\n        }\n        if (committed) {\n          deleter.incRef(this.info.files());\n          // Resolve \"live\" SegmentInfos segments to their toCommit cloned equivalents, based on segment name.\n          Set<String> mergedSegmentNames = new HashSet<>();\n          for (SegmentCommitInfo sci : this.segments) {\n            deleter.decRef(sci.files());\n            mergedSegmentNames.add(sci.info.name);\n          }\n          List<SegmentCommitInfo> toCommitMergedAwaySegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : toCommit) {\n            if (mergedSegmentNames.contains(sci.info.name)) {\n              toCommitMergedAwaySegments.add(sci);\n            }\n          }\n          // Construct a OneMerge that applies to toCommit\n          MergePolicy.OneMerge applicableMerge = new MergePolicy.OneMerge(toCommitMergedAwaySegments);\n          applicableMerge.info = this.info.clone();\n          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n          toCommit.applyMergeChanges(applicableMerge, false);\n        }\n        mergeAwaitLatch.countDown();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba192a321314de8edbe20b279eee9c471b16b48b":["fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5"],"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5":["81819c5a4a660afd353042c67106e682bb877cf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81819c5a4a660afd353042c67106e682bb877cf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba192a321314de8edbe20b279eee9c471b16b48b"]},"commit2Childs":{"ba192a321314de8edbe20b279eee9c471b16b48b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5":["ba192a321314de8edbe20b279eee9c471b16b48b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["81819c5a4a660afd353042c67106e682bb877cf1"],"81819c5a4a660afd353042c67106e682bb877cf1":["fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}