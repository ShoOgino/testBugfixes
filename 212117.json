{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(segmentInfos) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(segmentInfos) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(segmentInfos) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","bugFix":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(segmentInfos) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaaffc439e5ab10d23bed4448c0da2f2055ab552","date":1357315674,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = System.nanoTime();\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf","date":1357317637,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = System.nanoTime();\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a39601082ada9861e66f44b312c6549f4c5c7c0","date":1378755051,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      decRef(lastFiles);\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      for (Collection<String> lastFile : lastFiles) {\n        decRef(lastFile);\n      }\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.add(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["cefe924a3b76c22b7df9a075329750871699af6b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cefe924a3b76c22b7df9a075329750871699af6b","date":1409757963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      decRef(lastFiles);\n      lastFiles.clear();\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":["1a39601082ada9861e66f44b312c6549f4c5c7c0","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fba839b7548159227edcb740033d0f814b323d8d","date":1424455904,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(directory, false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directory, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Try again now to delete any previously un-deletable\n    // files (because they were in use, on Windows):\n    deletePendingFiles();\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = System.nanoTime();\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = System.nanoTime();\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#checkpoint(SegmentInfos,boolean).mjava","sourceNew":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = System.nanoTime();\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","sourceOld":"  /**\n   * For definition of \"check point\" see IndexWriter comments:\n   * \"Clarification: Check Points (and commits)\".\n   *\n   * Writer calls this when it has made a \"consistent\n   * change\" to the index, meaning new files are written to\n   * the index and the in-memory SegmentInfos have been\n   * modified to point to those files.\n   *\n   * This may or may not be a commit (segments_N may or may\n   * not have been written).\n   *\n   * We simply incref the files referenced by the new\n   * SegmentInfos and decref the files we had previously\n   * seen (if any).\n   *\n   * If this is a commit, we also call the policy to give it\n   * a chance to remove other commits.  If any commits are\n   * removed, we decref their files as well.\n   */\n  public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {\n    assert locked();\n\n    assert Thread.holdsLock(writer);\n    long t0 = 0;\n    if (infoStream.isEnabled(\"IFD\")) {\n      t0 = System.nanoTime();\n      infoStream.message(\"IFD\", \"now checkpoint \\\"\" + writer.segString(writer.toLiveInfos(segmentInfos)) + \"\\\" [\" + segmentInfos.size() + \" segments \" + \"; isCommit = \" + isCommit + \"]\");\n    }\n\n    // Incref the files:\n    incRef(segmentInfos, isCommit);\n\n    if (isCommit) {\n      // Append to our commits list:\n      commits.add(new CommitPoint(commitsToDelete, directoryOrig, segmentInfos));\n\n      // Tell policy so it can remove commits:\n      policy.onCommit(commits);\n\n      // Decref files for commits that were deleted by the policy:\n      deleteCommits();\n    } else {\n      // DecRef old files from the last checkpoint, if any:\n      try {\n        decRef(lastFiles);\n      } finally {\n        lastFiles.clear();\n      }\n\n      // Save files so we can decr on next checkpoint/commit:\n      lastFiles.addAll(segmentInfos.files(false));\n    }\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      long t1 = System.nanoTime();\n      infoStream.message(\"IFD\", ((t1-t0)/1000000) + \" msec to checkpoint\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","854c907ba21cf5682ecb9b18bf1188a38d0cbbaf"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"cefe924a3b76c22b7df9a075329750871699af6b":["1a39601082ada9861e66f44b312c6549f4c5c7c0"],"fba839b7548159227edcb740033d0f814b323d8d":["cefe924a3b76c22b7df9a075329750871699af6b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf":["aaaffc439e5ab10d23bed4448c0da2f2055ab552"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["950882a2bd2a5f9dc16a154871584eaa643d882a","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["950882a2bd2a5f9dc16a154871584eaa643d882a","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"618635065f043788c9e034f96ca5cd5cea1b4592":["fba839b7548159227edcb740033d0f814b323d8d"],"aaaffc439e5ab10d23bed4448c0da2f2055ab552":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"1a39601082ada9861e66f44b312c6549f4c5c7c0":["854c907ba21cf5682ecb9b18bf1188a38d0cbbaf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950882a2bd2a5f9dc16a154871584eaa643d882a":["618635065f043788c9e034f96ca5cd5cea1b4592"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"cefe924a3b76c22b7df9a075329750871699af6b":["fba839b7548159227edcb740033d0f814b323d8d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"fba839b7548159227edcb740033d0f814b323d8d":["618635065f043788c9e034f96ca5cd5cea1b4592"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","38e3b736c7ca086d61b7dbb841c905ee115490da","aaaffc439e5ab10d23bed4448c0da2f2055ab552"],"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","1a39601082ada9861e66f44b312c6549f4c5c7c0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aaaffc439e5ab10d23bed4448c0da2f2055ab552":["854c907ba21cf5682ecb9b18bf1188a38d0cbbaf"],"618635065f043788c9e034f96ca5cd5cea1b4592":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"1a39601082ada9861e66f44b312c6549f4c5c7c0":["cefe924a3b76c22b7df9a075329750871699af6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","38e3b736c7ca086d61b7dbb841c905ee115490da","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}