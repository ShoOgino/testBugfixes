{"path":"backwards/src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    int maxSize = BooleanQuery.getMaxClauseCount();\n    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);\n    FilteredTermEnum enumerator = getEnum(reader);\n    try {\n      ScoreTerm bottomSt = null;\n      do {\n        final Term t = enumerator.term();\n        if (t == null) break;\n        ScoreTerm st = new ScoreTerm(t, enumerator.difference());\n        if (stQueue.size() < maxSize) {\n          // record the current bottom item\n          if (bottomSt == null || st.compareTo(bottomSt) > 0) {\n            bottomSt = st;\n          }\n          // add to PQ, as it is not yet filled up\n          stQueue.offer(st);\n        } else {\n          assert bottomSt != null;\n          // only add to PQ, if the ScoreTerm is greater than the current bottom,\n          // as all entries will be enqueued after the current bottom and will never be visible\n          if (st.compareTo(bottomSt) < 0) {\n            stQueue.offer(st);\n          }\n        }\n        //System.out.println(\"current: \"+st.term+\"(\"+st.score+\"), bottom: \"+bottomSt.term+\"(\"+bottomSt.score+\")\");\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = Math.min(stQueue.size(), maxSize);\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.poll();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"backwards/src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    int maxSize = BooleanQuery.getMaxClauseCount();\n    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);\n    FilteredTermEnum enumerator = getEnum(reader);\n    try {\n      ScoreTerm bottomSt = null;\n      do {\n        final Term t = enumerator.term();\n        if (t == null) break;\n        ScoreTerm st = new ScoreTerm(t, enumerator.difference());\n        if (stQueue.size() < maxSize) {\n          // record the current bottom item\n          if (bottomSt == null || st.compareTo(bottomSt) > 0) {\n            bottomSt = st;\n          }\n          // add to PQ, as it is not yet filled up\n          stQueue.offer(st);\n        } else {\n          assert bottomSt != null;\n          // only add to PQ, if the ScoreTerm is greater than the current bottom,\n          // as all entries will be enqueued after the current bottom and will never be visible\n          if (st.compareTo(bottomSt) < 0) {\n            stQueue.offer(st);\n          }\n        }\n        //System.out.println(\"current: \"+st.term+\"(\"+st.score+\"), bottom: \"+bottomSt.term+\"(\"+bottomSt.score+\")\");\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = Math.min(stQueue.size(), maxSize);\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.poll();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    int maxSize = BooleanQuery.getMaxClauseCount();\n    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);\n    FilteredTermEnum enumerator = getEnum(reader);\n    try {\n      ScoreTerm bottomSt = null;\n      do {\n        final Term t = enumerator.term();\n        if (t == null) break;\n        ScoreTerm st = new ScoreTerm(t, enumerator.difference());\n        if (stQueue.size() < maxSize) {\n          // record the current bottom item\n          if (bottomSt == null || st.compareTo(bottomSt) > 0) {\n            bottomSt = st;\n          }\n          // add to PQ, as it is not yet filled up\n          stQueue.offer(st);\n        } else {\n          assert bottomSt != null;\n          // only add to PQ, if the ScoreTerm is greater than the current bottom,\n          // as all entries will be enqueued after the current bottom and will never be visible\n          if (st.compareTo(bottomSt) < 0) {\n            stQueue.offer(st);\n          }\n        }\n        //System.out.println(\"current: \"+st.term+\"(\"+st.score+\"), bottom: \"+bottomSt.term+\"(\"+bottomSt.score+\")\");\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = Math.min(stQueue.size(), maxSize);\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.poll();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}