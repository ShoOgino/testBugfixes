{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","commits":[{"id":"4426b4db58382f44a19bd3bbd62c69df9e9fa84a","date":1459983420,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9","date":1459984736,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f77a7e20dbadc238bc591ca864625fbf17c7976","date":1460093626,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    \n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6c62df758561770fbfb93e3328392285f3f618","date":1462109700,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    \n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly; not quite the full range though\n        arcDistance[i] = random().nextDouble() * (Math.PI * 0.5 - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      /* Hole logic is broken and needs rethinking\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n            \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n      */\n      \n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    \n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    \n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly; not quite the full range though\n        arcDistance[i] = random().nextDouble() * (Math.PI * 0.5 - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      /* Hole logic is broken and needs rethinking\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n            \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n      */\n      \n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected static Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired, final boolean createHoles) {\n    \n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    // Pick a set of points\n    while (true) {\n      double accumulatedAngle = 0.0;\n      for (int i = 0; i < pointCount; i++) {\n        final int remainingEdgeCount = pointCount - i;\n        final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n        if (remainingEdgeCount == 1) {\n          angles[i] = remainingAngle;\n        } else {\n          // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n          double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n          if (maximumAngle > Math.PI) {\n            maximumAngle = Math.PI;\n          }\n          // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n          // 180 degrees.  And since we have three points to start with, we already know that.\n          final double minimumAngle = MINIMUM_EDGE_ANGLE;\n          // Pick the angle\n          final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n          angles[i] = angle;\n          accumulatedAngle += angle;\n        }\n        // Pick the arc distance randomly\n        arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n      }\n      if (clockwiseDesired) {\n        // Reverse the signs\n        for (int i = 0; i < pointCount; i++) {\n          angles[i] = -angles[i];\n        }\n      }\n      \n      // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n      final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n      \n      // Create the geo3d polygon, so we can test out our poles.\n      final GeoPolygon poly;\n      try {\n        poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n      } catch (IllegalArgumentException e) {\n        // This is what happens when three adjacent points are colinear, so try again.\n        continue;\n      }\n      \n      // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n      // going to use Geo3D to help us select those given the points we just made.\n      \n      final int holeCount = createHoles?TestUtil.nextInt(random(), 0, 2):0;\n      \n      final List<Polygon> holeList = new ArrayList<>();\n      \n      for (int i = 0; i < holeCount; i++) {\n        // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n        // If we can't find a good pole we have to give it up and not do the hole.\n        for (int k = 0; k < 500; k++) {\n          final GeoPoint poleChoice = new GeoPoint(pm, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n          if (!poly.isWithin(poleChoice)) {\n            continue;\n          }\n          // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n          // After that we give up and pick a new pole.\n          boolean foundOne = false;\n          for (int j = 0; j < 100; j++) {\n            final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired, false);\n            // Verify that the inside polygon is OK.  If not, discard and repeat.\n            if (!verifyPolygon(pm, insidePoly, poly)) {\n              continue;\n            }\n            holeList.add(insidePoly);\n            foundOne = true;\n          }\n          if (foundOne) {\n            break;\n          }\n        }\n      }\n\n      final Polygon[] holes = holeList.toArray(new Polygon[0]);\n      \n      // Finally, build the polygon and return it\n      final double[] lats = new double[polyPoints.size() + 1];\n      final double[] lons = new double[polyPoints.size() + 1];\n        \n      for (int i = 0; i < polyPoints.size(); i++) {\n        lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n        lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n      }\n      lats[polyPoints.size()] = lats[0];\n      lons[polyPoints.size()] = lons[0];\n      return new Polygon(lats, lons, holes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["4426b4db58382f44a19bd3bbd62c69df9e9fa84a"],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["4f77a7e20dbadc238bc591ca864625fbf17c7976"],"4f77a7e20dbadc238bc591ca864625fbf17c7976":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"4426b4db58382f44a19bd3bbd62c69df9e9fa84a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b6c62df758561770fbfb93e3328392285f3f618"],"5b6c62df758561770fbfb93e3328392285f3f618":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee","5b6c62df758561770fbfb93e3328392285f3f618"]},"commit2Childs":{"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["4f77a7e20dbadc238bc591ca864625fbf17c7976"],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["5b6c62df758561770fbfb93e3328392285f3f618","55b50463286869f584cf849d1587a0fcd54d1dfa"],"4f77a7e20dbadc238bc591ca864625fbf17c7976":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"4426b4db58382f44a19bd3bbd62c69df9e9fa84a":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4426b4db58382f44a19bd3bbd62c69df9e9fa84a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5b6c62df758561770fbfb93e3328392285f3f618":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}