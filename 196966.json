{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":["c619aff1490fbcbfb8aee81049da5e5120a986d6","9ce667c6d3400b22523701c549c0d35e26da8b46"],"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f241b963c5bcd6c2293a928059dd2d64988a6042","date":1340296137,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":["c619aff1490fbcbfb8aee81049da5e5120a986d6","44fcbde6fb2ac44ee3b45e013e54a42911e689ff","2586f96f60332eb97ecd2934b0763791462568b2"],"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad","a4278fc65afbb35739525c37f818cded6fe6e9ae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a161d72d5c6edf60ebeffca098091eb6595523c7","date":1349275653,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e2893fd5349134af382d33ccc3d84840394c6c1","date":1353682567,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":["257da767277782760db0814096b999899995b2b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4278fc65afbb35739525c37f818cded6fe6e9ae","date":1369132128,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort();\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e9ca12badc371399673a8a074cb281a72f34049","date":1395419500,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n        try {\n          processEvents(false, true);\n        } finally {\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false, false);\n  }\n\n","bugFix":null,"bugIntro":["3c8ae37f624b6dd2e224b74ec2632c0810de8d18","322c7e6294f703248e9b818ca5b393b090ac05ad","cefe924a3b76c22b7df9a075329750871699af6b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c8ae37f624b6dd2e224b74ec2632c0810de8d18","date":1396297002,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n        try {\n          processEvents(false, true);\n        } finally {\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","bugFix":["c619aff1490fbcbfb8aee81049da5e5120a986d6","6e9ca12badc371399673a8a074cb281a72f34049"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n        try {\n          processEvents(false, true);\n        } finally {\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergePolicy/Scheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n        \n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        processEvents(false, true);\n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler, readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aebd7aefbda82cfbe6db062b1008391c1eb8c5d8","date":1397380990,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergePolicy/Scheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      processEvents(false, true);\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergePolicy/Scheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergePolicy/Scheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a64ffebe62143a8d4c37d99b6ece6d430d948ebc","date":1408382164,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cefe924a3b76c22b7df9a075329750871699af6b","date":1409757963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {}\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":["c619aff1490fbcbfb8aee81049da5e5120a986d6","6e9ca12badc371399673a8a074cb281a72f34049"],"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a5624f5d378dee7dd3295c0e227fd5a09ba2116","date":1409925189,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.refresh();\n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7599427f762eb1b4265584fd6e96521e4a1a4f3c","date":1413100083,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","date":1414017220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b869e42fbd9c52c4728652ba51faf7266b239a6f","date":1428140988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount.get();\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount;\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount.get();\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount.get();\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n        \n        assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized(this) {\n        abortMerges();\n        stopMerges = true;\n      }\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling closeInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        lastCommitChangeCount = changeCount.get();\n        \n        deleter.close();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (!success) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (!success) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322c7e6294f703248e9b818ca5b393b090ac05ad","date":1442166853,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n    // Make sure no commit is running, else e.g. we can close while another thread is still fsync'ing:\n    synchronized(commitLock) {\n      rollbackInternalNoCommit();\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f","06584e6e98d592b34e1329b384182f368d2025e8","949847c0040cd70a68222d526cb0da7bf6cbb3c2","73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","c5df35ab57c223ea11aec64b53bf611904f3dced","786a4d25ca958a1f315a9d6a74f0441fdafcd522","9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","c4ff8864209d2e972cb4393600c26082f9a6533d","ee59f646cf24586a449cad77391a60a3ac8d8959","a161d72d5c6edf60ebeffca098091eb6595523c7","c619aff1490fbcbfb8aee81049da5e5120a986d6","850aca8525380ccb7df9626d7caa89678005dd31","ae14298f4eec6d5faee6a149f88ba57d14a6f21a","d9e22bdf0692bfa61e342b04a6ac7078670c1e16","58c6bbc222f074c844e736e6fb23647e3db9cfe3","b869e42fbd9c52c4728652ba51faf7266b239a6f","7e1cbd7e289dc1243c7a59e1a83d078163a147fe","6e9ca12badc371399673a8a074cb281a72f34049","7599427f762eb1b4265584fd6e96521e4a1a4f3c","ae695f21c50b03702b5d0fa2543d5af844bb7cd3","7af110b00ea8df9429309d83e38e0533d82e144f","cefe924a3b76c22b7df9a075329750871699af6b","f241b963c5bcd6c2293a928059dd2d64988a6042"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n    // Make sure no commit is running, else e.g. we can close while another thread is still fsync'ing:\n    synchronized(commitLock) {\n      rollbackInternalNoCommit();\n\n      assert pendingNumDocs.get() == segmentInfos.totalMaxDoc()\n          : \"pendingNumDocs \" + pendingNumDocs.get() + \" != \" + segmentInfos.totalMaxDoc() + \" totalMaxDoc\";\n    }\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n    // Make sure no commit is running, else e.g. we can close while another thread is still fsync'ing:\n    synchronized(commitLock) {\n      rollbackInternalNoCommit();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b869e42fbd9c52c4728652ba51faf7266b239a6f":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"322c7e6294f703248e9b818ca5b393b090ac05ad":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["7af110b00ea8df9429309d83e38e0533d82e144f"],"7af110b00ea8df9429309d83e38e0533d82e144f":["a4278fc65afbb35739525c37f818cded6fe6e9ae"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["aebd7aefbda82cfbe6db062b1008391c1eb8c5d8"],"f241b963c5bcd6c2293a928059dd2d64988a6042":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"aebd7aefbda82cfbe6db062b1008391c1eb8c5d8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3a5624f5d378dee7dd3295c0e227fd5a09ba2116":["cefe924a3b76c22b7df9a075329750871699af6b"],"a161d72d5c6edf60ebeffca098091eb6595523c7":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["3c8ae37f624b6dd2e224b74ec2632c0810de8d18"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["3a5624f5d378dee7dd3295c0e227fd5a09ba2116"],"a4278fc65afbb35739525c37f818cded6fe6e9ae":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"5eb2511ababf862ea11e10761c70ee560cd84510":["6e9ca12badc371399673a8a074cb281a72f34049","3c8ae37f624b6dd2e224b74ec2632c0810de8d18"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"55980207f1977bd1463465de1659b821347e2fa8":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"cefe924a3b76c22b7df9a075329750871699af6b":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["a161d72d5c6edf60ebeffca098091eb6595523c7"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a4278fc65afbb35739525c37f818cded6fe6e9ae","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["a4278fc65afbb35739525c37f818cded6fe6e9ae","7af110b00ea8df9429309d83e38e0533d82e144f"],"6e9ca12badc371399673a8a074cb281a72f34049":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["b869e42fbd9c52c4728652ba51faf7266b239a6f"],"3c8ae37f624b6dd2e224b74ec2632c0810de8d18":["6e9ca12badc371399673a8a074cb281a72f34049"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a161d72d5c6edf60ebeffca098091eb6595523c7","6e2893fd5349134af382d33ccc3d84840394c6c1"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","f241b963c5bcd6c2293a928059dd2d64988a6042"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"]},"commit2Childs":{"b869e42fbd9c52c4728652ba51faf7266b239a6f":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"322c7e6294f703248e9b818ca5b393b090ac05ad":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","55980207f1977bd1463465de1659b821347e2fa8"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["6e9ca12badc371399673a8a074cb281a72f34049"],"7af110b00ea8df9429309d83e38e0533d82e144f":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"f241b963c5bcd6c2293a928059dd2d64988a6042":["a161d72d5c6edf60ebeffca098091eb6595523c7","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","38e3b736c7ca086d61b7dbb841c905ee115490da"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["f241b963c5bcd6c2293a928059dd2d64988a6042","38e3b736c7ca086d61b7dbb841c905ee115490da","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aebd7aefbda82cfbe6db062b1008391c1eb8c5d8":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a5624f5d378dee7dd3295c0e227fd5a09ba2116":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"a161d72d5c6edf60ebeffca098091eb6595523c7":["6e2893fd5349134af382d33ccc3d84840394c6c1","d4d69c535930b5cce125cff868d40f6373dc27d4"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["aebd7aefbda82cfbe6db062b1008391c1eb8c5d8"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["7599427f762eb1b4265584fd6e96521e4a1a4f3c","55980207f1977bd1463465de1659b821347e2fa8"],"a4278fc65afbb35739525c37f818cded6fe6e9ae":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"55980207f1977bd1463465de1659b821347e2fa8":[],"cefe924a3b76c22b7df9a075329750871699af6b":["3a5624f5d378dee7dd3295c0e227fd5a09ba2116"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"6e9ca12badc371399673a8a074cb281a72f34049":["5eb2511ababf862ea11e10761c70ee560cd84510","3c8ae37f624b6dd2e224b74ec2632c0810de8d18"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"3c8ae37f624b6dd2e224b74ec2632c0810de8d18":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","5eb2511ababf862ea11e10761c70ee560cd84510"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a4278fc65afbb35739525c37f818cded6fe6e9ae"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"5faf65b6692f15cca0f87bf8666c87899afc619f":["b869e42fbd9c52c4728652ba51faf7266b239a6f"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["cefe924a3b76c22b7df9a075329750871699af6b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","38e3b736c7ca086d61b7dbb841c905ee115490da","55980207f1977bd1463465de1659b821347e2fa8","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}