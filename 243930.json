{"path":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","pathOld":"lucene/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","sourceNew":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to the beginning.  As all TokenStreams must be reusable,\n   * any implementations which have state that needs to be reset between usages\n   * of the TokenStream, must implement this method. Note that if your TokenStream\n   * caches tokens and feeds them back again after a reset, it is imperative\n   * that you clone the tokens when you store them away (on the first pass) as\n   * well as when you return them (on future passes after {@link #reset()}).\n   */\n  public void reset() throws IOException {}\n\n","sourceOld":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to the beginning.  As all TokenStreams must be reusable,\n   * any implementations which have state that needs to be reset between usages\n   * of the TokenStream, must implement this method. Note that if your TokenStream\n   * caches tokens and feeds them back again after a reset, it is imperative\n   * that you clone the tokens when you store them away (on the first pass) as\n   * well as when you return them (on future passes after {@link #reset()}).\n   */\n  public void reset() throws IOException {}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c1b87b155748a27fbed84a0ffb3f8799177451e","date":1346349018,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","sourceNew":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to a clean state. Stateful implementations must implement\n   * this method so that they can be reused, just as if they had been created fresh.\n   */\n  public void reset() throws IOException {}\n\n","sourceOld":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to the beginning.  As all TokenStreams must be reusable,\n   * any implementations which have state that needs to be reset between usages\n   * of the TokenStream, must implement this method. Note that if your TokenStream\n   * caches tokens and feeds them back again after a reset, it is imperative\n   * that you clone the tokens when you store them away (on the first pass) as\n   * well as when you return them (on future passes after {@link #reset()}).\n   */\n  public void reset() throws IOException {}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","sourceNew":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to a clean state. Stateful implementations must implement\n   * this method so that they can be reused, just as if they had been created fresh.\n   */\n  public void reset() throws IOException {}\n\n","sourceOld":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to the beginning.  As all TokenStreams must be reusable,\n   * any implementations which have state that needs to be reset between usages\n   * of the TokenStream, must implement this method. Note that if your TokenStream\n   * caches tokens and feeds them back again after a reset, it is imperative\n   * that you clone the tokens when you store them away (on the first pass) as\n   * well as when you return them (on future passes after {@link #reset()}).\n   */\n  public void reset() throws IOException {}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd8e41d532014fca193d0a5d22a7ae75f795ab3","date":1380016401,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/analysis/TokenStream#reset().mjava","sourceNew":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p>\n   * Resets this stream to a clean state. Stateful implementations must implement\n   * this method so that they can be reused, just as if they had been created fresh.\n   * <p>\n   * If you override this method, always call {@code super.reset()}, otherwise\n   * some internal state will not be correctly reset (e.g., {@link Tokenizer} will\n   * throw {@link IllegalStateException} on further usage).\n   */\n  public void reset() throws IOException {}\n\n","sourceOld":"  /**\n   * This method is called by a consumer before it begins consumption using\n   * {@link #incrementToken()}.\n   * <p/>\n   * Resets this stream to a clean state. Stateful implementations must implement\n   * this method so that they can be reused, just as if they had been created fresh.\n   */\n  public void reset() throws IOException {}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c1b87b155748a27fbed84a0ffb3f8799177451e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8fd8e41d532014fca193d0a5d22a7ae75f795ab3":["4c1b87b155748a27fbed84a0ffb3f8799177451e"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4c1b87b155748a27fbed84a0ffb3f8799177451e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8fd8e41d532014fca193d0a5d22a7ae75f795ab3"]},"commit2Childs":{"4c1b87b155748a27fbed84a0ffb3f8799177451e":["8fd8e41d532014fca193d0a5d22a7ae75f795ab3","05a14b2611ead08655a2b2bdc61632eb31316e57"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4c1b87b155748a27fbed84a0ffb3f8799177451e","05a14b2611ead08655a2b2bdc61632eb31316e57"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8fd8e41d532014fca193d0a5d22a7ae75f795ab3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}