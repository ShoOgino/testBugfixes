{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","commits":[{"id":"2a6ee6c302710254b6c2474ccd2755f9f2323ee3","date":1330700384,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"/dev/null","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, minPairWeightComparator, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"/dev/null","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, minPairWeightComparator, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, minPairWeightComparator, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, minPairWeightComparator, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, minPairWeightComparator, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a81c53232b7a347a2a79b731a0b152059237a4b5","date":1351810824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                         outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2), \n                                         minPairWeightComparator));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches);\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a80a77f74130ba0cde6aae8833e5e560739459a","date":1351810990,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader(0);\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39","date":1370266419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(true), // weight\n        PositiveIntOutputs.getSingleton(true)  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = _TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = _TestUtil.nextInt(random, 0, 500); // outputs 0..500 \n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<String,TwoLongs>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<Long,Long>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<Pair<Long,Long>>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<Util.MinResult<Pair<Long,Long>>>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<Pair<Long,Long>>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<Pair<Long,Long>>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d245db17aaa41b338dae9da5d4edba4dd6f61612","date":1394644847,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n    \n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n    \n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n    \n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n    \n    BytesReader reader = fst.getBytesReader();\n    \n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n    \n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.MinResult<Pair<Long,Long>>[] r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Util.MinResult<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Util.MinResult<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                          outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.length);\n\n      for(int hit=0;hit<r.length;hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r[hit].input);\n        assertEquals(matches.get(hit).output, r[hit].output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.shutdown();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.shutdown();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRef scratch = new IntsRef();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRef()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3","d245db17aaa41b338dae9da5d4edba4dd6f61612"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output);\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final FSTCompiler<Pair<Long,Long>> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      fstCompiler.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = fstCompiler.compile();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testShortestPathsWFSTRandom().mjava","sourceNew":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final FSTCompiler<Pair<Long,Long>> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      fstCompiler.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = fstCompiler.compile();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","sourceOld":"  /** like testShortestPathsRandom, but uses pairoutputs so we have both a weight and an output */\n  public void testShortestPathsWFSTRandom() throws Exception {\n    int numWords = atLeast(1000);\n\n    final TreeMap<String,TwoLongs> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n\n    PairOutputs<Long,Long> outputs = new PairOutputs<>(\n        PositiveIntOutputs.getSingleton(), // weight\n        PositiveIntOutputs.getSingleton()  // output\n    );\n    final Builder<Pair<Long,Long>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n\n    Random random = random();\n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        s = TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n\n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      int weight = TestUtil.nextInt(random, 1, 100); // weights 1..100\n      int output = TestUtil.nextInt(random, 0, 500); // outputs 0..500\n      slowCompletor.put(s, new TwoLongs(weight, output));\n    }\n\n    for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n      //System.out.println(\"add: \" + e);\n      long weight = e.getValue().a;\n      long output = e.getValue().b;\n      builder.add(Util.toIntsRef(new BytesRef(e.getKey()), scratch), outputs.newPair(weight, output));\n    }\n\n    final FST<Pair<Long,Long>> fst = builder.finish();\n    //System.out.println(\"SAVE out.dot\");\n    //Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"));\n    //Util.toDot(fst, w, false, false);\n    //w.close();\n\n    BytesReader reader = fst.getBytesReader();\n\n    //System.out.println(\"testing: \" + allPrefixes.size() + \" prefixes\");\n    for (String prefix : allPrefixes) {\n      // 1. run prefix against fst, then complete by value\n      //System.out.println(\"TEST: \" + prefix);\n\n      Pair<Long,Long> prefixOutput = outputs.getNoOutput();\n      FST.Arc<Pair<Long,Long>> arc = fst.getFirstArc(new FST.Arc<Pair<Long,Long>>());\n      for(int idx=0;idx<prefix.length();idx++) {\n        if (fst.findTargetArc((int) prefix.charAt(idx), arc, arc, reader) == null) {\n          fail();\n        }\n        prefixOutput = outputs.add(prefixOutput, arc.output());\n      }\n\n      final int topN = TestUtil.nextInt(random, 1, 10);\n\n      Util.TopResults<Pair<Long,Long>> r = Util.shortestPaths(fst, arc, fst.outputs.getNoOutput(), minPairWeightComparator, topN, true);\n      assertTrue(r.isComplete);\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<Result<Pair<Long,Long>>> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,TwoLongs> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          //System.out.println(\"  consider \" + e.getKey());\n          matches.add(new Result<>(Util.toIntsRef(new BytesRef(e.getKey().substring(prefix.length())), new IntsRefBuilder()),\n                                                  outputs.newPair(e.getValue().a - prefixOutput.output1, e.getValue().b - prefixOutput.output2)));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new TieBreakByInputComparator<>(minPairWeightComparator));\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.topN.size());\n\n      for(int hit=0;hit<r.topN.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).input, r.topN.get(hit).input);\n        assertEquals(matches.get(hit).output, r.topN.get(hit).output);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["4a80a77f74130ba0cde6aae8833e5e560739459a"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["4a80a77f74130ba0cde6aae8833e5e560739459a","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"6613659748fe4411a7dcf85266e55db1f95f7315":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"a81c53232b7a347a2a79b731a0b152059237a4b5":["6ce825e9276493231308229152c48f755ce1a0a5"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8061ddd97f3352007d927dae445884a6f3d857b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6ce825e9276493231308229152c48f755ce1a0a5":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"4a80a77f74130ba0cde6aae8833e5e560739459a":["a81c53232b7a347a2a79b731a0b152059237a4b5"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["54204c8a3ca26aeafd273139fc29baf70d0f6786","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["c4015cd39dff8d4dec562d909f9766debac53aa6","6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a81c53232b7a347a2a79b731a0b152059237a4b5":["4a80a77f74130ba0cde6aae8833e5e560739459a"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"6ce825e9276493231308229152c48f755ce1a0a5":["a81c53232b7a347a2a79b731a0b152059237a4b5"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"4a80a77f74130ba0cde6aae8833e5e560739459a":["82557a475db3e0849171dc0be5b02e3ae0745ddb","c4015cd39dff8d4dec562d909f9766debac53aa6"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6ce825e9276493231308229152c48f755ce1a0a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f8061ddd97f3352007d927dae445884a6f3d857b","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}