{"path":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/10;\n                      shift = random.nextInt(trigger);\n                    }\n                    BytesRef term = termsEnum.next();\n                    if (term == null) {\n                      if (seenTermCount == 0) {\n                        break;\n                      }\n                      totTermCount.set(seenTermCount);\n                      seenTermCount = 0;\n                      if (totTermCount.get() < 10) {\n                        shift = 0;\n                        trigger = 1;\n                      } else {\n                        trigger = totTermCount.get()/10;\n                        //System.out.println(\"trigger \" + trigger);\n                        shift = random.nextInt(trigger);\n                      }\n                      termsEnum.seekCeil(new BytesRef(\"\"));\n                      continue;\n                    }\n                    seenTermCount++;\n                    // search 10 terms\n                    if (trigger == 0) {\n                      trigger = 1;\n                    }\n                    if ((seenTermCount + shift) % trigger == 0) {\n                      //if (VERBOSE) {\n                      //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                      //}\n                      totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/10;\n                      shift = random.nextInt(trigger);\n                    }\n                    BytesRef term = termsEnum.next();\n                    if (term == null) {\n                      if (seenTermCount == 0) {\n                        break;\n                      }\n                      totTermCount.set(seenTermCount);\n                      seenTermCount = 0;\n                      if (totTermCount.get() < 10) {\n                        shift = 0;\n                        trigger = 1;\n                      } else {\n                        trigger = totTermCount.get()/10;\n                        //System.out.println(\"trigger \" + trigger);\n                        shift = random.nextInt(trigger);\n                      }\n                      termsEnum.seekCeil(new BytesRef(\"\"));\n                      continue;\n                    }\n                    seenTermCount++;\n                    // search 10 terms\n                    if (trigger == 0) {\n                      trigger = 1;\n                    }\n                    if ((seenTermCount + shift) % trigger == 0) {\n                      //if (VERBOSE) {\n                      //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                      //}\n                      totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86365ce8db75e42ebe10805e99e92c463fef63b6","date":1330370408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/10;\n                      shift = random.nextInt(trigger);\n                    }\n                    BytesRef term = termsEnum.next();\n                    if (term == null) {\n                      if (seenTermCount == 0) {\n                        break;\n                      }\n                      totTermCount.set(seenTermCount);\n                      seenTermCount = 0;\n                      if (totTermCount.get() < 10) {\n                        shift = 0;\n                        trigger = 1;\n                      } else {\n                        trigger = totTermCount.get()/10;\n                        //System.out.println(\"trigger \" + trigger);\n                        shift = random.nextInt(trigger);\n                      }\n                      termsEnum.seekCeil(new BytesRef(\"\"));\n                      continue;\n                    }\n                    seenTermCount++;\n                    // search 10 terms\n                    if (trigger == 0) {\n                      trigger = 1;\n                    }\n                    if ((seenTermCount + shift) % trigger == 0) {\n                      //if (VERBOSE) {\n                      //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                      //}\n                      totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/10;\n                      shift = random.nextInt(trigger);\n                    }\n                    BytesRef term = termsEnum.next();\n                    if (term == null) {\n                      if (seenTermCount == 0) {\n                        break;\n                      }\n                      totTermCount.set(seenTermCount);\n                      seenTermCount = 0;\n                      if (totTermCount.get() < 10) {\n                        shift = 0;\n                        trigger = 1;\n                      } else {\n                        trigger = totTermCount.get()/10;\n                        //System.out.println(\"trigger \" + trigger);\n                        shift = random.nextInt(trigger);\n                      }\n                      termsEnum.seekCeil(new BytesRef(\"\"));\n                      continue;\n                    }\n                    seenTermCount++;\n                    // search 10 terms\n                    if (trigger == 0) {\n                      trigger = 1;\n                    }\n                    if ((seenTermCount + shift) % trigger == 0) {\n                      //if (VERBOSE) {\n                      //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                      //}\n                      totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12d34a50613f65c6d7da794b96bb90278ad96759","date":1331214552,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"635599f98f30cd9945088debbeb833f6c0fcdba4","date":1331215361,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 10) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (true) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        if (seenTermCount == 0) {\n                          break;\n                        }\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if (trigger == 0) {\n                        trigger = 1;\n                      }\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    InvertedFields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    InvertedFields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random, 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random.nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f","date":1338915218,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed\", warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6","date":1338921900,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: \" + warmed, !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed\", warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f","date":1339593213,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: \" + warmed, !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":["e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f","1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(AtomicReader sub : ((DirectoryReader) s.getIndexReader()).getSequentialSubReaders()) {\n                    SegmentReader segReader = (SegmentReader) sub;\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(((SegmentReader) sub).core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed7ba385535ed5109fa3082c791190945b382538","date":1380021240,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = _TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final AtomicReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    if (fields == null) {\n                      continue;\n                    }\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a","date":1427708531,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", term))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c55941686ce4a07d295ac4bf8993f170b6dff731","date":1427841851,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","date":1427842554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c576bf71df117a2003cac1787df5a9a5de44eb6","date":1427849700,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].setDaemon(true);\n      searchThreads[thread].start();\n    }\n\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator(null);\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicInteger totHits = new AtomicInteger();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Fields fields = MultiFields.getFields(s.getIndexReader());\n                    Terms terms = fields.terms(\"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiTerms.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiFields.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runSearchThreads(long).mjava","sourceNew":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TEST_NIGHTLY ? TestUtil.nextInt(random(), 1, 5) : 2;\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiTerms.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","sourceOld":"  protected void runSearchThreads(final long stopTimeMS) throws Exception {\n    final int numThreads = TestUtil.nextInt(random(), 1, 5);\n    final Thread[] searchThreads = new Thread[numThreads];\n    final AtomicLong totHits = new AtomicLong();\n\n    // silly starting guess:\n    final AtomicInteger totTermCount = new AtomicInteger(100);\n\n    // TODO: we should enrich this to do more interesting searches\n    for(int thread=0;thread<searchThreads.length;thread++) {\n      searchThreads[thread] = new Thread() {\n          @Override\n          public void run() {\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": launch search thread\");\n            }\n            while (System.currentTimeMillis() < stopTimeMS && !failed.get()) {\n              try {\n                final IndexSearcher s = getCurrentSearcher();\n                try {\n                  // Verify 1) IW is correctly setting\n                  // diagnostics, and 2) segment warming for\n                  // merged segments is actually happening:\n                  for(final LeafReaderContext sub : s.getIndexReader().leaves()) {\n                    SegmentReader segReader = (SegmentReader) sub.reader();\n                    Map<String,String> diagnostics = segReader.getSegmentInfo().info.getDiagnostics();\n                    assertNotNull(diagnostics);\n                    String source = diagnostics.get(\"source\");\n                    assertNotNull(source);\n                    if (source.equals(\"merge\")) {\n                      assertTrue(\"sub reader \" + sub + \" wasn't warmed: warmed=\" + warmed + \" diagnostics=\" + diagnostics + \" si=\" + segReader.getSegmentInfo(),\n                                 !assertMergedSegmentsWarmed || warmed.containsKey(segReader.core));\n                    }\n                  }\n                  if (s.getIndexReader().numDocs() > 0) {\n                    smokeTestSearcher(s);\n                    Terms terms = MultiTerms.getTerms(s.getIndexReader(), \"body\");\n                    if (terms == null) {\n                      continue;\n                    }\n                    TermsEnum termsEnum = terms.iterator();\n                    int seenTermCount = 0;\n                    int shift;\n                    int trigger; \n                    if (totTermCount.get() < 30) {\n                      shift = 0;\n                      trigger = 1;\n                    } else {\n                      trigger = totTermCount.get()/30;\n                      shift = random().nextInt(trigger);\n                    }\n                    while (System.currentTimeMillis() < stopTimeMS) {\n                      BytesRef term = termsEnum.next();\n                      if (term == null) {\n                        totTermCount.set(seenTermCount);\n                        break;\n                      }\n                      seenTermCount++;\n                      // search 30 terms\n                      if ((seenTermCount + shift) % trigger == 0) {\n                        //if (VERBOSE) {\n                        //System.out.println(Thread.currentThread().getName() + \" now search body:\" + term.utf8ToString());\n                        //}\n                        totHits.addAndGet(runQuery(s, new TermQuery(new Term(\"body\", BytesRef.deepCopyOf(term)))));\n                      }\n                    }\n                    //if (VERBOSE) {\n                    //System.out.println(Thread.currentThread().getName() + \": search done\");\n                    //}\n                  }\n                } finally {\n                  releaseSearcher(s);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                failed.set(true);\n                t.printStackTrace(System.out);\n                throw new RuntimeException(t);\n              }\n            }\n          }\n        };\n      searchThreads[thread].start();\n    }\n\n    for(Thread thread : searchThreads) {\n      thread.join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE search: totHits=\" + totHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6c576bf71df117a2003cac1787df5a9a5de44eb6"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","86365ce8db75e42ebe10805e99e92c463fef63b6"],"12d34a50613f65c6d7da794b96bb90278ad96759":["86365ce8db75e42ebe10805e99e92c463fef63b6"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["6613659748fe4411a7dcf85266e55db1f95f7315"],"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6":["1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f"],"e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f":["006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8028ab7a24273833d53d35eb160dba5b57283cf5","1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","635599f98f30cd9945088debbeb833f6c0fcdba4"],"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":["c55941686ce4a07d295ac4bf8993f170b6dff731"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ed7ba385535ed5109fa3082c791190945b382538"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c55941686ce4a07d295ac4bf8993f170b6dff731":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["635599f98f30cd9945088debbeb833f6c0fcdba4"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"ed7ba385535ed5109fa3082c791190945b382538":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["28288370235ed02234a64753cdbf0c6ec096304a"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"635599f98f30cd9945088debbeb833f6c0fcdba4":["12d34a50613f65c6d7da794b96bb90278ad96759"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"12d34a50613f65c6d7da794b96bb90278ad96759":["635599f98f30cd9945088debbeb833f6c0fcdba4"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","86365ce8db75e42ebe10805e99e92c463fef63b6"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6":["e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f"],"e234a8b89f7546c5cfa8bff6ba3bfb22bf8fd38f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c55941686ce4a07d295ac4bf8993f170b6dff731"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6c576bf71df117a2003cac1787df5a9a5de44eb6"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","ed7ba385535ed5109fa3082c791190945b382538"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","12d34a50613f65c6d7da794b96bb90278ad96759"],"c55941686ce4a07d295ac4bf8993f170b6dff731":["edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2"],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"ed7ba385535ed5109fa3082c791190945b382538":["6613659748fe4411a7dcf85266e55db1f95f7315"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1c36c2c148b5ca66c24d8441bec8cbc6ef648c0a"],"1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f":["006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["1c6875fb4ae52dc6f55e9bc34eb8152666c41a6f"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"635599f98f30cd9945088debbeb833f6c0fcdba4":["38e3b736c7ca086d61b7dbb841c905ee115490da","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","38e3b736c7ca086d61b7dbb841c905ee115490da","edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}