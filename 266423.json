{"path":"lucene/src/test/org/apache/lucene/search/TestFieldCache#testGetDocsWithFieldThreadSafety().mjava","commits":[{"id":"382fe3a6ca9745891afebda9b9a57cc158305545","date":1320952430,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestFieldCache#testGetDocsWithFieldThreadSafety().mjava","pathOld":"/dev/null","sourceNew":"  public void testGetDocsWithFieldThreadSafety() throws Exception {\n    final FieldCache cache = FieldCache.DEFAULT;\n    cache.purgeAllCaches();\n\n    int NUM_THREADS = 3;\n    Thread[] threads = new Thread[NUM_THREADS];\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicInteger iters = new AtomicInteger();\n    final int NUM_ITER = 200 * RANDOM_MULTIPLIER;\n    final CyclicBarrier restart = new CyclicBarrier(NUM_THREADS,\n                                                    new Runnable() {\n                                                      @Override\n                                                      public void run() {\n                                                        cache.purgeAllCaches();\n                                                        iters.incrementAndGet();\n                                                      }\n                                                    });\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX] = new Thread() {\n          @Override\n          public void run() {\n\n            try {\n              while(!failed.get()) {\n                final int op = random.nextInt(3);\n                if (op == 0) {\n                  // Purge all caches & resume, once all\n                  // threads get here:\n                  restart.await();\n                  if (iters.get() >= NUM_ITER) {\n                    break;\n                  }\n                } else if (op == 1) {\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    assertEquals(i%2 == 0, docsWithField.get(i));\n                  }\n                } else {\n                  int[] ints = cache.getInts(reader, \"sparse\", true);\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    if (i%2 == 0) {\n                      assertTrue(docsWithField.get(i));\n                      assertEquals(i, ints[i]);\n                    } else {\n                      assertFalse(docsWithField.get(i));\n                    }\n                  }\n                }\n              }\n            } catch (Throwable t) {\n              failed.set(true);\n              restart.reset();\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads[threadIDX].start();\n    }\n\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX].join();\n    }\n    assertFalse(failed.get());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","8c146731a64debc22c115bbf11ee1a060aa7ea02","8c146731a64debc22c115bbf11ee1a060aa7ea02","8c146731a64debc22c115bbf11ee1a060aa7ea02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFieldCache#testGetDocsWithFieldThreadSafety().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestFieldCache#testGetDocsWithFieldThreadSafety().mjava","sourceNew":"  public void testGetDocsWithFieldThreadSafety() throws Exception {\n    final FieldCache cache = FieldCache.DEFAULT;\n    cache.purgeAllCaches();\n\n    int NUM_THREADS = 3;\n    Thread[] threads = new Thread[NUM_THREADS];\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicInteger iters = new AtomicInteger();\n    final int NUM_ITER = 200 * RANDOM_MULTIPLIER;\n    final CyclicBarrier restart = new CyclicBarrier(NUM_THREADS,\n                                                    new Runnable() {\n                                                      @Override\n                                                      public void run() {\n                                                        cache.purgeAllCaches();\n                                                        iters.incrementAndGet();\n                                                      }\n                                                    });\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX] = new Thread() {\n          @Override\n          public void run() {\n\n            try {\n              while(!failed.get()) {\n                final int op = random.nextInt(3);\n                if (op == 0) {\n                  // Purge all caches & resume, once all\n                  // threads get here:\n                  restart.await();\n                  if (iters.get() >= NUM_ITER) {\n                    break;\n                  }\n                } else if (op == 1) {\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    assertEquals(i%2 == 0, docsWithField.get(i));\n                  }\n                } else {\n                  int[] ints = cache.getInts(reader, \"sparse\", true);\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    if (i%2 == 0) {\n                      assertTrue(docsWithField.get(i));\n                      assertEquals(i, ints[i]);\n                    } else {\n                      assertFalse(docsWithField.get(i));\n                    }\n                  }\n                }\n              }\n            } catch (Throwable t) {\n              failed.set(true);\n              restart.reset();\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads[threadIDX].start();\n    }\n\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX].join();\n    }\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  public void testGetDocsWithFieldThreadSafety() throws Exception {\n    final FieldCache cache = FieldCache.DEFAULT;\n    cache.purgeAllCaches();\n\n    int NUM_THREADS = 3;\n    Thread[] threads = new Thread[NUM_THREADS];\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicInteger iters = new AtomicInteger();\n    final int NUM_ITER = 200 * RANDOM_MULTIPLIER;\n    final CyclicBarrier restart = new CyclicBarrier(NUM_THREADS,\n                                                    new Runnable() {\n                                                      @Override\n                                                      public void run() {\n                                                        cache.purgeAllCaches();\n                                                        iters.incrementAndGet();\n                                                      }\n                                                    });\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX] = new Thread() {\n          @Override\n          public void run() {\n\n            try {\n              while(!failed.get()) {\n                final int op = random.nextInt(3);\n                if (op == 0) {\n                  // Purge all caches & resume, once all\n                  // threads get here:\n                  restart.await();\n                  if (iters.get() >= NUM_ITER) {\n                    break;\n                  }\n                } else if (op == 1) {\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    assertEquals(i%2 == 0, docsWithField.get(i));\n                  }\n                } else {\n                  int[] ints = cache.getInts(reader, \"sparse\", true);\n                  Bits docsWithField = cache.getDocsWithField(reader, \"sparse\");\n                  for (int i = 0; i < docsWithField.length(); i++) {\n                    if (i%2 == 0) {\n                      assertTrue(docsWithField.get(i));\n                      assertEquals(i, ints[i]);\n                    } else {\n                      assertFalse(docsWithField.get(i));\n                    }\n                  }\n                }\n              }\n            } catch (Throwable t) {\n              failed.set(true);\n              restart.reset();\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads[threadIDX].start();\n    }\n\n    for(int threadIDX=0;threadIDX<NUM_THREADS;threadIDX++) {\n      threads[threadIDX].join();\n    }\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["382fe3a6ca9745891afebda9b9a57cc158305545"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"382fe3a6ca9745891afebda9b9a57cc158305545":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["382fe3a6ca9745891afebda9b9a57cc158305545"],"382fe3a6ca9745891afebda9b9a57cc158305545":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}