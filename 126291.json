{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","commits":[{"id":"a18a03f140cbd3f78694787c9f98cf452aab7b7f","date":1423241474,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (!c.isProhibited()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f698887111a682424e759ba36083180899a1fd","date":1423588899,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r =\n              new Explanation(0.0f, \"match on required clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (!c.isProhibited()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46d8c7dbd8ccf2d1d4c893119d835477354fda52","date":1424873438,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0f, \"match on required clause, product of:\");\n          r.addDetail(new Explanation(0f, Occur.FILTER + \" clause\"));\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < matchCount);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r =\n              new Explanation(0.0f, \"match on required clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0f, \"match on required clause, product of:\");\n          r.addDetail(new Explanation(0f, Occur.FILTER + \" clause\"));\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < matchCount);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r =\n              new Explanation(0.0f, \"match on required clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      Explanation result = Explanation.match(sum, \"sum of:\", subs);\n      final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n      if (coordFactor != 1f) {\n        result = Explanation.match(sum * coordFactor, \"product of:\",\n            result, Explanation.match(coordFactor, \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    ComplexExplanation sumExpl = new ComplexExplanation();\n    sumExpl.setDescription(\"sum of:\");\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      if (w.scorer(context, context.reader().getLiveDocs()) == null) {\n        if (c.isRequired()) {\n          fail = true;\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          sumExpl.addDetail(r);\n        }\n        continue;\n      }\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          sumExpl.addDetail(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0f, \"match on required clause, product of:\");\n          r.addDetail(new Explanation(0f, Occur.FILTER + \" clause\"));\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n        } else if (c.isProhibited()) {\n          Explanation r =\n            new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n        r.addDetail(e);\n        sumExpl.addDetail(r);\n        fail = true;\n      }\n    }\n    if (fail) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription\n        (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n      return sumExpl;\n    } else if (shouldMatchCount < minShouldMatch) {\n      sumExpl.setMatch(Boolean.FALSE);\n      sumExpl.setValue(0.0f);\n      sumExpl.setDescription(\"Failure to match minimum number \"+\n                             \"of optional clauses: \" + minShouldMatch);\n      return sumExpl;\n    }\n    \n    sumExpl.setMatch(0 < matchCount);\n    sumExpl.setValue(sum);\n    \n    final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n    if (coordFactor == 1.0f) {\n      return sumExpl;                             // eliminate wrapper\n    } else {\n      ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                         sum*coordFactor,\n                                                         \"product of:\");\n      result.addDetail(sumExpl);\n      result.addDetail(new Explanation(coordFactor,\n                                       \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      Explanation result = Explanation.match(sum, \"sum of:\", subs);\n      final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n      if (coordFactor != 1f) {\n        result = Explanation.match(sum * coordFactor, \"product of:\",\n            result, Explanation.match(coordFactor, \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      Explanation result = Explanation.match(sum, \"sum of:\", subs);\n      final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n      if (coordFactor != 1f) {\n        result = Explanation.match(sum * coordFactor, \"product of:\",\n            result, Explanation.match(coordFactor, \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      }\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      return Explanation.match(sum, \"sum of:\", subs);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      Explanation result = Explanation.match(sum, \"sum of:\", subs);\n      final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n      if (coordFactor != 1f) {\n        result = Explanation.match(sum * coordFactor, \"product of:\",\n            result, Explanation.match(coordFactor, \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      }\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      return Explanation.match(sum, \"sum of:\", subs);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    int coord = 0;\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n          coord++;\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      Explanation result = Explanation.match(sum, \"sum of:\", subs);\n      final float coordFactor = disableCoord ? 1.0f : coord(coord, maxCoord);\n      if (coordFactor != 1f) {\n        result = Explanation.match(sum * coordFactor, \"product of:\",\n            result, Explanation.match(coordFactor, \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n      }\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7732a106554be0db3e03ac5211e46f6e0c285b8","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // Replicating the same floating-point errors as the scorer does is quite\n      // complex (essentially because of how ReqOptSumScorer casts intermediate\n      // contributions to the score to floats), so in order to make sure that\n      // explanations have the same value as the score, we pull a scorer and\n      // use it to compute the score.\n      Scorer scorer = scorer(context);\n      int advanced = scorer.iterator().advance(doc);\n      assert advanced == doc;\n      return Explanation.match(scorer.score(), \"sum of:\", subs);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      return Explanation.match(sum, \"sum of:\", subs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // Replicating the same floating-point errors as the scorer does is quite\n      // complex (essentially because of how ReqOptSumScorer casts intermediate\n      // contributions to the score to floats), so in order to make sure that\n      // explanations have the same value as the score, we pull a scorer and\n      // use it to compute the score.\n      Scorer scorer = scorer(context);\n      int advanced = scorer.iterator().advance(doc);\n      assert advanced == doc;\n      return Explanation.match(scorer.score(), \"sum of:\", subs);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    float sum = 0.0f;\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n          sum += e.getValue();\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // we have a match\n      return Explanation.match(sum, \"sum of:\", subs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a13f208db1e7d2e6004f070428b8dc9f533a14c","date":1561708237,"type":3,"author":"Sven Amann","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#explain(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    for (WeightedBooleanClause wc : weightedClauses) {\n      Weight w = wc.weight;\n      BooleanClause c = wc.clause;\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // Replicating the same floating-point errors as the scorer does is quite\n      // complex (essentially because of how ReqOptSumScorer casts intermediate\n      // contributions to the score to floats), so in order to make sure that\n      // explanations have the same value as the score, we pull a scorer and\n      // use it to compute the score.\n      Scorer scorer = scorer(context);\n      int advanced = scorer.iterator().advance(doc);\n      assert advanced == doc;\n      return Explanation.match(scorer.score(), \"sum of:\", subs);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n    final int minShouldMatch = query.getMinimumNumberShouldMatch();\n    List<Explanation> subs = new ArrayList<>();\n    boolean fail = false;\n    int matchCount = 0;\n    int shouldMatchCount = 0;\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n      Weight w = wIter.next();\n      BooleanClause c = cIter.next();\n      Explanation e = w.explain(context, doc);\n      if (e.isMatch()) {\n        if (c.isScoring()) {\n          subs.add(e);\n        } else if (c.isRequired()) {\n          subs.add(Explanation.match(0f, \"match on required clause, product of:\",\n              Explanation.match(0f, Occur.FILTER + \" clause\"), e));\n        } else if (c.isProhibited()) {\n          subs.add(Explanation.noMatch(\"match on prohibited clause (\" + c.getQuery().toString() + \")\", e));\n          fail = true;\n        }\n        if (!c.isProhibited()) {\n          matchCount++;\n        }\n        if (c.getOccur() == Occur.SHOULD) {\n          shouldMatchCount++;\n        }\n      } else if (c.isRequired()) {\n        subs.add(Explanation.noMatch(\"no match on required clause (\" + c.getQuery().toString() + \")\", e));\n        fail = true;\n      }\n    }\n    if (fail) {\n      return Explanation.noMatch(\"Failure to meet condition(s) of required/prohibited clause(s)\", subs);\n    } else if (matchCount == 0) {\n      return Explanation.noMatch(\"No matching clauses\", subs);\n    } else if (shouldMatchCount < minShouldMatch) {\n      return Explanation.noMatch(\"Failure to match minimum number of optional clauses: \" + minShouldMatch, subs);\n    } else {\n      // Replicating the same floating-point errors as the scorer does is quite\n      // complex (essentially because of how ReqOptSumScorer casts intermediate\n      // contributions to the score to floats), so in order to make sure that\n      // explanations have the same value as the score, we pull a scorer and\n      // use it to compute the score.\n      Scorer scorer = scorer(context);\n      int advanced = scorer.iterator().advance(doc);\n      assert advanced == doc;\n      return Explanation.match(scorer.score(), \"sum of:\", subs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a13f208db1e7d2e6004f070428b8dc9f533a14c":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"a18a03f140cbd3f78694787c9f98cf452aab7b7f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","c8a0e442f7b61f811680273b25da95994a724466"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["c8a0e442f7b61f811680273b25da95994a724466"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["c8a0e442f7b61f811680273b25da95994a724466","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["25f698887111a682424e759ba36083180899a1fd","46d8c7dbd8ccf2d1d4c893119d835477354fda52"],"46d8c7dbd8ccf2d1d4c893119d835477354fda52":["25f698887111a682424e759ba36083180899a1fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8a0e442f7b61f811680273b25da95994a724466":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["46d8c7dbd8ccf2d1d4c893119d835477354fda52"],"25f698887111a682424e759ba36083180899a1fd":["a18a03f140cbd3f78694787c9f98cf452aab7b7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a13f208db1e7d2e6004f070428b8dc9f533a14c"]},"commit2Childs":{"3a13f208db1e7d2e6004f070428b8dc9f533a14c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a18a03f140cbd3f78694787c9f98cf452aab7b7f":["25f698887111a682424e759ba36083180899a1fd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["3a13f208db1e7d2e6004f070428b8dc9f533a14c"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"46d8c7dbd8ccf2d1d4c893119d835477354fda52":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a18a03f140cbd3f78694787c9f98cf452aab7b7f"],"c8a0e442f7b61f811680273b25da95994a724466":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c7732a106554be0db3e03ac5211e46f6e0c285b8","1aad05eeff7818b0833c02ac6b743aa72054963b"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"25f698887111a682424e759ba36083180899a1fd":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","46d8c7dbd8ccf2d1d4c893119d835477354fda52"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}