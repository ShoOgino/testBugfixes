{"path":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns null if the sortSpec string doesn't look like a sort specification,\n   * or if the sort specification couldn't be converted into a Lucene Sort\n   * (because of a field not being indexed or undefined, etc).\n   *\n   * The form of the sort specification string currently parsed is:\n   * SortSpec ::= SingleSort [, SingleSort]* <number>?\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   *\n   * Examples:\n   *   top 10                        #take the top 10 by score\n   *   desc 10                       #take the top 10 by score\n   *   score desc 10                 #take the top 10 by score\n   *   weight bottom 10              #sort by weight ascending and take the first 10\n   *   weight desc                   #sort by weight descending\n   *   height desc,weight desc       #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc top 20 #sort by height descending, using weight ascending as a tiebreaker\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    // I wonder how fast the regex is??? as least we cache the pattern.\n    String[] parts = sortSeparator.split(sortSpec.trim(),0);\n    if (parts.length == 0) return null;\n\n    ArrayList<SortField> lst = new ArrayList<SortField>();\n    int num=-1;\n\n    int pos=0;\n    String fn;\n    boolean top=true;\n    boolean normalSortOnScore=false;\n\n    while (pos < parts.length) {\n      String str=parts[pos];\n      if (\"top\".equals(str) || \"bottom\".equals(str) || \"asc\".equals(str) || \"desc\".equals(str)) {\n        // if the field name seems to be missing, default to \"score\".\n        // note that this will mess up a field name that has the same name\n        // as a sort direction specifier.\n        fn=\"score\";\n      } else {\n        fn=str;\n        pos++;\n      }\n\n      // get the direction of the sort\n      str=parts[pos];\n      if (\"top\".equals(str) || \"desc\".equals(str)) {\n        top=true;\n      } else if (\"bottom\".equals(str) || \"asc\".equals(str)) {\n        top=false;\n      }  else {\n        return null;  // must not be a sort command\n      }\n\n      // get the field to sort on\n      // hmmm - should there be a fake/pseudo-field named \"score\" in the schema?\n      if (\"score\".equals(fn)) {\n        if (top) {\n          normalSortOnScore=true;\n          lst.add(SortField.FIELD_SCORE);\n        } else {\n          lst.add(new SortField(null, SortField.SCORE, true));\n        }\n      } else {\n        // getField could throw an exception if the name isn't found\n        try {\n          SchemaField f = schema.getField(fn);\n          if (f == null || !f.indexed()) return null;\n          lst.add(f.getType().getSortField(f,top));\n        } catch (Exception e) {\n          return null;\n        }\n      }\n      pos++;\n\n      // If there is a leftover part, assume it is a count\n      if (pos+1 == parts.length) {\n        try {\n          num = Integer.parseInt(parts[pos]);\n        } catch (Exception e) {\n          return null;\n        }\n        pos++;\n      }\n    }\n\n    Sort sort;\n    if (normalSortOnScore && lst.size() == 1) {\n      // Normalize the default sort on score descending to sort=null\n      sort=null;\n    } else {\n      sort = new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n    }\n    return new SortSpec(sort,num);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79c686ad76bb74d110ec3c727914fb5693a7da23","date":1158901446,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec string doesn't look like a sort specification,\n   * or if the sort specification couldn't be converted into a Lucene Sort\n   * (because of a field not being indexed or undefined, etc).\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]* <number>?\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   top 10                        #take the top 10 by score\n   *   desc 10                       #take the top 10 by score\n   *   score desc 10                 #take the top 10 by score\n   *   weight bottom 10              #sort by weight ascending and take the first 10\n   *   weight desc                   #sort by weight descending\n   *   height desc,weight desc       #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc top 20 #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    // I wonder how fast the regex is??? as least we cache the pattern.\n    String[] parts = sortSeparator.split(sortSpec.trim(),0);\n    if (parts.length == 0) return null;\n\n    ArrayList<SortField> lst = new ArrayList<SortField>();\n    int num=-1;\n\n    int pos=0;\n    String fn;\n    boolean top=true;\n    boolean normalSortOnScore=false;\n\n    while (pos < parts.length) {\n      String str=parts[pos];\n      if (\"top\".equals(str) || \"bottom\".equals(str) || \"asc\".equals(str) || \"desc\".equals(str)) {\n        // if the field name seems to be missing, default to \"score\".\n        // note that this will mess up a field name that has the same name\n        // as a sort direction specifier.\n        fn=\"score\";\n      } else {\n        fn=str;\n        pos++;\n      }\n\n      // get the direction of the sort\n      str=parts[pos];\n      if (\"top\".equals(str) || \"desc\".equals(str)) {\n        top=true;\n      } else if (\"bottom\".equals(str) || \"asc\".equals(str)) {\n        top=false;\n      }  else {\n        return null;  // must not be a sort command\n      }\n\n      // get the field to sort on\n      // hmmm - should there be a fake/pseudo-field named \"score\" in the schema?\n      if (\"score\".equals(fn)) {\n        if (top) {\n          normalSortOnScore=true;\n          lst.add(SortField.FIELD_SCORE);\n        } else {\n          lst.add(new SortField(null, SortField.SCORE, true));\n        }\n      } else {\n        // getField could throw an exception if the name isn't found\n        try {\n          SchemaField f = schema.getField(fn);\n          if (f == null || !f.indexed()) return null;\n          lst.add(f.getType().getSortField(f,top));\n        } catch (Exception e) {\n          return null;\n        }\n      }\n      pos++;\n\n      // If there is a leftover part, assume it is a count\n      if (pos+1 == parts.length) {\n        try {\n          num = Integer.parseInt(parts[pos]);\n        } catch (Exception e) {\n          return null;\n        }\n        pos++;\n      }\n    }\n\n    Sort sort;\n    if (normalSortOnScore && lst.size() == 1) {\n      // Normalize the default sort on score descending to sort=null\n      sort=null;\n    } else {\n      sort = new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n    }\n    return new SortSpec(sort,num);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec string doesn't look like a sort specification,\n   * or if the sort specification couldn't be converted into a Lucene Sort\n   * (because of a field not being indexed or undefined, etc).\n   *\n   * The form of the sort specification string currently parsed is:\n   * SortSpec ::= SingleSort [, SingleSort]* <number>?\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   *\n   * Examples:\n   *   top 10                        #take the top 10 by score\n   *   desc 10                       #take the top 10 by score\n   *   score desc 10                 #take the top 10 by score\n   *   weight bottom 10              #sort by weight ascending and take the first 10\n   *   weight desc                   #sort by weight descending\n   *   height desc,weight desc       #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc top 20 #sort by height descending, using weight ascending as a tiebreaker\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    // I wonder how fast the regex is??? as least we cache the pattern.\n    String[] parts = sortSeparator.split(sortSpec.trim(),0);\n    if (parts.length == 0) return null;\n\n    ArrayList<SortField> lst = new ArrayList<SortField>();\n    int num=-1;\n\n    int pos=0;\n    String fn;\n    boolean top=true;\n    boolean normalSortOnScore=false;\n\n    while (pos < parts.length) {\n      String str=parts[pos];\n      if (\"top\".equals(str) || \"bottom\".equals(str) || \"asc\".equals(str) || \"desc\".equals(str)) {\n        // if the field name seems to be missing, default to \"score\".\n        // note that this will mess up a field name that has the same name\n        // as a sort direction specifier.\n        fn=\"score\";\n      } else {\n        fn=str;\n        pos++;\n      }\n\n      // get the direction of the sort\n      str=parts[pos];\n      if (\"top\".equals(str) || \"desc\".equals(str)) {\n        top=true;\n      } else if (\"bottom\".equals(str) || \"asc\".equals(str)) {\n        top=false;\n      }  else {\n        return null;  // must not be a sort command\n      }\n\n      // get the field to sort on\n      // hmmm - should there be a fake/pseudo-field named \"score\" in the schema?\n      if (\"score\".equals(fn)) {\n        if (top) {\n          normalSortOnScore=true;\n          lst.add(SortField.FIELD_SCORE);\n        } else {\n          lst.add(new SortField(null, SortField.SCORE, true));\n        }\n      } else {\n        // getField could throw an exception if the name isn't found\n        try {\n          SchemaField f = schema.getField(fn);\n          if (f == null || !f.indexed()) return null;\n          lst.add(f.getType().getSortField(f,top));\n        } catch (Exception e) {\n          return null;\n        }\n      }\n      pos++;\n\n      // If there is a leftover part, assume it is a count\n      if (pos+1 == parts.length) {\n        try {\n          num = Integer.parseInt(parts[pos]);\n        } catch (Exception e) {\n          return null;\n        }\n        pos++;\n      }\n    }\n\n    Sort sort;\n    if (normalSortOnScore && lst.size() == 1) {\n      // Normalize the default sort on score descending to sort=null\n      sort=null;\n    } else {\n      sort = new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n    }\n    return new SortSpec(sort,num);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db0aeb2c6a9f5554fe05f71df91e37ad5def1c35","date":1168642124,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( 400, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( 400, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = schema.getField(part);\n        if (f == null || !f.indexed()){\n          throw new SolrException( 400, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec string doesn't look like a sort specification,\n   * or if the sort specification couldn't be converted into a Lucene Sort\n   * (because of a field not being indexed or undefined, etc).\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]* <number>?\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   top 10                        #take the top 10 by score\n   *   desc 10                       #take the top 10 by score\n   *   score desc 10                 #take the top 10 by score\n   *   weight bottom 10              #sort by weight ascending and take the first 10\n   *   weight desc                   #sort by weight descending\n   *   height desc,weight desc       #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc top 20 #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    // I wonder how fast the regex is??? as least we cache the pattern.\n    String[] parts = sortSeparator.split(sortSpec.trim(),0);\n    if (parts.length == 0) return null;\n\n    ArrayList<SortField> lst = new ArrayList<SortField>();\n    int num=-1;\n\n    int pos=0;\n    String fn;\n    boolean top=true;\n    boolean normalSortOnScore=false;\n\n    while (pos < parts.length) {\n      String str=parts[pos];\n      if (\"top\".equals(str) || \"bottom\".equals(str) || \"asc\".equals(str) || \"desc\".equals(str)) {\n        // if the field name seems to be missing, default to \"score\".\n        // note that this will mess up a field name that has the same name\n        // as a sort direction specifier.\n        fn=\"score\";\n      } else {\n        fn=str;\n        pos++;\n      }\n\n      // get the direction of the sort\n      str=parts[pos];\n      if (\"top\".equals(str) || \"desc\".equals(str)) {\n        top=true;\n      } else if (\"bottom\".equals(str) || \"asc\".equals(str)) {\n        top=false;\n      }  else {\n        return null;  // must not be a sort command\n      }\n\n      // get the field to sort on\n      // hmmm - should there be a fake/pseudo-field named \"score\" in the schema?\n      if (\"score\".equals(fn)) {\n        if (top) {\n          normalSortOnScore=true;\n          lst.add(SortField.FIELD_SCORE);\n        } else {\n          lst.add(new SortField(null, SortField.SCORE, true));\n        }\n      } else {\n        // getField could throw an exception if the name isn't found\n        try {\n          SchemaField f = schema.getField(fn);\n          if (f == null || !f.indexed()) return null;\n          lst.add(f.getType().getSortField(f,top));\n        } catch (Exception e) {\n          return null;\n        }\n      }\n      pos++;\n\n      // If there is a leftover part, assume it is a count\n      if (pos+1 == parts.length) {\n        try {\n          num = Integer.parseInt(parts[pos]);\n        } catch (Exception e) {\n          return null;\n        }\n        pos++;\n      }\n    }\n\n    Sort sort;\n    if (normalSortOnScore && lst.size() == 1) {\n      // Normalize the default sort on score descending to sort=null\n      sort=null;\n    } else {\n      sort = new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n    }\n    return new SortSpec(sort,num);\n  }\n\n","bugFix":null,"bugIntro":["1551536a8eb6261842b3af98b5538a6e4aa4f4f7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1551536a8eb6261842b3af98b5538a6e4aa4f4f7","date":1177880528,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( 400, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( 400, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( 400, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( 400, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( 400, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( 400, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = schema.getField(part);\n        if (f == null || !f.indexed()){\n          throw new SolrException( 400, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","bugFix":["db0aeb2c6a9f5554fe05f71df91e37ad5def1c35"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( 400, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( 400, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( 400, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( 400, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6075cf7db5ebb03b013c9110fca8f1013ba6a72","date":1196271697,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n    \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n    \t  top = true;\n    \t}\n    \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n    \t  top = false;\n    \t}\n    \telse {\n    \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n    \t}\n    \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n\t\tthrow new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If thre is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    // For more info on the 'num' field, -1, \n    // see: https://issues.apache.org/jira/browse/SOLR-99\n    return new SortSpec( new Sort(lst),-1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b10a2ec5b70066aec90c0c33052ecea6e64eb389","date":1254477771,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (\"#\".equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      }\n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } \n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da52eff14300478b6b4df00b41b2decc3468f848","date":1255014950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (DOCID.equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      }\n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (\"#\".equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      }\n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32ef722831135736529762b4b97a13dd58b06f66","date":1260567610,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for (int i = 0; i < parts.length; i++) {\n      String part = parts[i].trim();\n      boolean top = true;\n      //determine the ordering, ascending or descending\n      int idx = part.indexOf(' ');\n      if (idx > 0) {\n        String order = part.substring(idx + 1).trim();\n        if (\"desc\".equals(order) || \"top\".equals(order)) {\n          top = true;\n        } else if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n          top = false;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \" + order);\n        }\n        part = part.substring(0, idx).trim();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\");\n      }\n      //figure out the field or score\n      if (\"score\".equals(part)) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if (parts.length == 1) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        } else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (DOCID.equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      } else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try {\n          f = schema.getField(part);\n        }\n        catch (SolrException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \" + part, e);\n        }\n        if (f == null || !f.indexed()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \" + part);\n        }\n        lst[i] = f.getType().getSortField(f, top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   *\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending \n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   *\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec==null || sortSpec.length()==0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for( int i=0; i<parts.length; i++ ) {\n      String part = parts[i].trim();\n      boolean top=true;\n        \n      int idx = part.indexOf( ' ' );\n      if( idx > 0 ) {\n        String order = part.substring( idx+1 ).trim();\n      \tif( \"desc\".equals( order ) || \"top\".equals(order) ) {\n      \t  top = true;\n      \t}\n      \telse if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n      \t  top = false;\n      \t}\n      \telse {\n      \t  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \"+order);\n      \t}\n      \tpart = part.substring( 0, idx ).trim();\n      }\n      else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\" );\n      }\n    \t\n      if( \"score\".equals(part) ) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if( parts.length == 1 ) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        }\n        else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (DOCID.equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      }\n      else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try{\n          f = schema.getField(part);\n        }\n        catch( SolrException e ){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \"+part, e );\n        }\n        if (f == null || !f.indexed()){\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \"+part );\n        }\n        lst[i] = f.getType().getSortField(f,top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7adea379ca28e367e6726634db1cebeb14483ee9","date":1260658827,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth == 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n\n    String[] parts = sortSep.split(sortSpec.trim());\n    if (parts.length == 0) return null;\n\n    SortField[] lst = new SortField[parts.length];\n    for (int i = 0; i < parts.length; i++) {\n      String part = parts[i].trim();\n      boolean top = true;\n      //determine the ordering, ascending or descending\n      int idx = part.indexOf(' ');\n      if (idx > 0) {\n        String order = part.substring(idx + 1).trim();\n        if (\"desc\".equals(order) || \"top\".equals(order)) {\n          top = true;\n        } else if (\"asc\".equals(order) || \"bottom\".equals(order)) {\n          top = false;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown sort order: \" + order);\n        }\n        part = part.substring(0, idx).trim();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Missing sort order.\");\n      }\n      //figure out the field or score\n      if (\"score\".equals(part)) {\n        if (top) {\n          // If there is only one thing in the list, just do the regular thing...\n          if (parts.length == 1) {\n            return null; // do normal scoring...\n          }\n          lst[i] = SortField.FIELD_SCORE;\n        } else {\n          lst[i] = new SortField(null, SortField.SCORE, true);\n        }\n      } else if (DOCID.equals(part)) {\n        lst[i] = new SortField(null, SortField.DOC, top);\n      } else {\n        // getField could throw an exception if the name isn't found\n        SchemaField f = null;\n        try {\n          f = schema.getField(part);\n        }\n        catch (SolrException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"can not sort on undefined field: \" + part, e);\n        }\n        if (f == null || !f.indexed()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"can not sort on unindexed field: \" + part);\n        }\n        lst[i] = f.getType().getSortField(f, top);\n      }\n    }\n    return new Sort(lst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c072979741a04848324e4e51ae44d2975855f781","date":1267453665,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth == 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da52eff14300478b6b4df00b41b2decc3468f848":["b10a2ec5b70066aec90c0c33052ecea6e64eb389"],"32ef722831135736529762b4b97a13dd58b06f66":["da52eff14300478b6b4df00b41b2decc3468f848"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"b10a2ec5b70066aec90c0c33052ecea6e64eb389":["c6075cf7db5ebb03b013c9110fca8f1013ba6a72"],"c072979741a04848324e4e51ae44d2975855f781":["7adea379ca28e367e6726634db1cebeb14483ee9"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["1551536a8eb6261842b3af98b5538a6e4aa4f4f7"],"79c686ad76bb74d110ec3c727914fb5693a7da23":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1551536a8eb6261842b3af98b5538a6e4aa4f4f7":["db0aeb2c6a9f5554fe05f71df91e37ad5def1c35"],"7adea379ca28e367e6726634db1cebeb14483ee9":["32ef722831135736529762b4b97a13dd58b06f66"],"ad94625fb8d088209f46650c8097196fec67f00c":["c072979741a04848324e4e51ae44d2975855f781"],"c6075cf7db5ebb03b013c9110fca8f1013ba6a72":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"db0aeb2c6a9f5554fe05f71df91e37ad5def1c35":["79c686ad76bb74d110ec3c727914fb5693a7da23"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"da52eff14300478b6b4df00b41b2decc3468f848":["32ef722831135736529762b4b97a13dd58b06f66"],"32ef722831135736529762b4b97a13dd58b06f66":["7adea379ca28e367e6726634db1cebeb14483ee9"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"b10a2ec5b70066aec90c0c33052ecea6e64eb389":["da52eff14300478b6b4df00b41b2decc3468f848"],"c072979741a04848324e4e51ae44d2975855f781":["ad94625fb8d088209f46650c8097196fec67f00c"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["c6075cf7db5ebb03b013c9110fca8f1013ba6a72"],"79c686ad76bb74d110ec3c727914fb5693a7da23":["db0aeb2c6a9f5554fe05f71df91e37ad5def1c35"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["79c686ad76bb74d110ec3c727914fb5693a7da23"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1551536a8eb6261842b3af98b5538a6e4aa4f4f7":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"7adea379ca28e367e6726634db1cebeb14483ee9":["c072979741a04848324e4e51ae44d2975855f781"],"c6075cf7db5ebb03b013c9110fca8f1013ba6a72":["b10a2ec5b70066aec90c0c33052ecea6e64eb389"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"db0aeb2c6a9f5554fe05f71df91e37ad5def1c35":["1551536a8eb6261842b3af98b5538a6e4aa4f4f7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}