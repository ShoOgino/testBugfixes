{"path":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","commits":[{"id":"9ed5f4bd4ee593745097b1ec9f0110b1997a9e58","date":1396480148,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n    \n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"Unhappy\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n    \n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"Unhappy\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c897483ab479f5d1bcdd40400d20ef417b3b837","date":1400781817,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint+\"/MB\", \n        \"/MB==['Megabyte','MiB','megabyte']\");    \n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n    \n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"Unhappy\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4da8d4c422d841c0e5a997bf16dd471c5545d3e4","date":1430889527,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint+\"/MB\", \n        \"/MB==['Megabyte','MiB','megabyte']\");    \n  }\n\n","bugFix":null,"bugIntro":["67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba","date":1456446390,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular']\");\n  }\n\n","bugFix":["4da8d4c422d841c0e5a997bf16dd471c5545d3e4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f494bc636a1302995e4930fdccd371eeda452f87","date":1457370876,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPut(\"/schema/fields/\" + newFieldName, json(\"{'type':'managed_en'}\"),\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9abfb16d083560e0a83d5c27b03f42ae7b5b22bb","date":1491559883,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    // multi-term synonym logic - SOLR-10264\n    final String multiTermOrigin;\n    final String multiTermSynonym;\n    if (random().nextBoolean()) {\n      multiTermOrigin  = \"hansestadt hamburg\";\n      multiTermSynonym = \"hh\";\n    } else {\n      multiTermOrigin  = \"hh\";\n      multiTermSynonym = \"hansestadt hamburg\";\n    }\n    // multi-term logic similar to the angry/mad logic (angry ~ origin, mad ~ synonym)\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(adoc(newFieldName, multiTermOrigin+\" is in North Germany.\", \"id\", \"040\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    assertQ(\"/select?q=\" + newFieldName + \":\"+URLEncoder.encode(multiTermOrigin, \"UTF-8\"),\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // add a mapping that will expand a query for \"multi-term synonym\" to match docs with \"acronym\"\n    syns = new HashMap<>();\n    syns.put(multiTermSynonym, Arrays.asList(multiTermOrigin));\n    assertJPut(endpoint,\n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n\n    assertJQ(endpoint+\"/\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\"),\n        \"/\"+multiTermSynonym+\"==['\"+multiTermOrigin+\"']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    // should not match as the synonym mapping between \"origin\" and \"synonym\"\n    // was not added before the document was indexed\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");\n\n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // now query for \"synonym\" and we should see our test doc with \"origin\"\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n\n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    // multi-term synonym logic - SOLR-10264\n    final String multiTermOrigin;\n    final String multiTermSynonym;\n    if (random().nextBoolean()) {\n      multiTermOrigin  = \"hansestadt hamburg\";\n      multiTermSynonym = \"hh\";\n    } else {\n      multiTermOrigin  = \"hh\";\n      multiTermSynonym = \"hansestadt hamburg\";\n    }\n    // multi-term logic similar to the angry/mad logic (angry ~ origin, mad ~ synonym)\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(adoc(newFieldName, multiTermOrigin+\" is in North Germany.\", \"id\", \"040\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    assertQ(\"/select?q=\" + newFieldName + \":\"+URLEncoder.encode(multiTermOrigin, \"UTF-8\"),\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // add a mapping that will expand a query for \"multi-term synonym\" to match docs with \"acronym\"\n    syns = new HashMap<>();\n    syns.put(multiTermSynonym, Arrays.asList(multiTermOrigin));\n    assertJPut(endpoint,\n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n\n    assertJQ(endpoint+\"/\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\"),\n        \"/\"+multiTermSynonym+\"==['\"+multiTermOrigin+\"']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    // should not match as the synonym mapping between \"origin\" and \"synonym\"\n    // was not added before the document was indexed\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");\n\n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // now query for \"synonym\" and we should see our test doc with \"origin\"\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n\n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3714bcf66a68a1600e9dd11442fc1b33b62ef088","date":1556832005,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","pathOld":"solr/core/src/test/org/apache/solr/rest/schema/analysis/TestManagedSynonymFilterFactory#testManagedSynonyms().mjava","sourceNew":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint,\n        toJSONString(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint,\n        toJSONString(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    // multi-term synonym logic - SOLR-10264\n    final String multiTermOrigin;\n    final String multiTermSynonym;\n    if (random().nextBoolean()) {\n      multiTermOrigin  = \"hansestadt hamburg\";\n      multiTermSynonym = \"hh\";\n    } else {\n      multiTermOrigin  = \"hh\";\n      multiTermSynonym = \"hansestadt hamburg\";\n    }\n    // multi-term logic similar to the angry/mad logic (angry ~ origin, mad ~ synonym)\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(adoc(newFieldName, multiTermOrigin+\" is in North Germany.\", \"id\", \"040\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    assertQ(\"/select?q=\" + newFieldName + \":\"+URLEncoder.encode(multiTermOrigin, \"UTF-8\"),\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint,\n        toJSONString(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // add a mapping that will expand a query for \"multi-term synonym\" to match docs with \"acronym\"\n    syns = new HashMap<>();\n    syns.put(multiTermSynonym, Arrays.asList(multiTermOrigin));\n    assertJPut(endpoint,\n        toJSONString(syns),\n               \"/responseHeader/status==0\");\n\n    assertJQ(endpoint+\"/\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\"),\n        \"/\"+multiTermSynonym+\"==['\"+multiTermOrigin+\"']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    // should not match as the synonym mapping between \"origin\" and \"synonym\"\n    // was not added before the document was indexed\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");\n\n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // now query for \"synonym\" and we should see our test doc with \"origin\"\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n\n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        toJSONString(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        toJSONString(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, toJSONString(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","sourceOld":"  @Test\n  public void testManagedSynonyms() throws Exception {\n    // this endpoint depends on at least one field type containing the following\n    // declaration in the schema-rest.xml:\n    // \n    //   <filter class=\"solr.ManagedSynonymFilterFactory\" managed=\"english\" />\n    //      \n    String endpoint = \"/schema/analysis/synonyms/english\";\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==false\",\n             \"/synonymMappings/managedMap=={}\");\n      \n    // put a new mapping into the synonyms\n    Map<String,List<String>> syns = new HashMap<>();\n    syns.put(\"happy\", Arrays.asList(\"glad\",\"cheerful\",\"joyful\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint,\n        \"/synonymMappings/managedMap/happy==['cheerful','glad','joyful']\");\n\n    // request to a specific mapping\n    assertJQ(endpoint+\"/happy\", \n             \"/happy==['cheerful','glad','joyful']\");\n\n    // does not exist\n    assertJQ(endpoint+\"/sad\", \n             \"/error/code==404\");\n    \n    // verify the user can update the ignoreCase initArg\n    assertJPut(endpoint, \n               json(\"{ 'initArgs':{ 'ignoreCase':true } }\"), \n               \"responseHeader/status==0\");\n\n    assertJQ(endpoint, \n             \"/synonymMappings/initArgs/ignoreCase==true\");\n    \n    syns = new HashMap<>();\n    syns.put(\"sad\", Arrays.asList(\"unhappy\"));    \n    syns.put(\"SAD\", Arrays.asList(\"bummed\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n             \"/synonymMappings/managedMap/sad==['unhappy']\");\n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/SAD==['bummed']\");\n    \n    // expect a union of values when requesting the \"sad\" child\n    assertJQ(endpoint+\"/sad\", \n        \"/sad==['bummed','unhappy']\");\n    \n    // verify delete works\n    assertJDelete(endpoint+\"/sad\",\n                  \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap=={'happy':['cheerful','glad','joyful']}\");\n    \n    // should fail with 404 as foo doesn't exist\n    assertJDelete(endpoint+\"/foo\",\n                  \"/error/code==404\");\n    \n    // verify that a newly added synonym gets expanded on the query side after core reload\n    \n    String newFieldName = \"managed_en_field\";\n    // make sure the new field doesn't already exist\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 0\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '404'\",\n            \"/response/lst[@name='error']/int[@name='code'] = '404'\");\n\n    // add the new field\n    assertJPost(\"/schema\", \"{ add-field :  { name: managed_en_field, type : managed_en}}\",\n               \"/responseHeader/status==0\");\n\n    // make sure the new field exists now\n    assertQ(\"/schema/fields/\" + newFieldName + \"?indent=on&wt=xml\",\n            \"count(/response/lst[@name='field']) = 1\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\");\n\n    // multi-term synonym logic - SOLR-10264\n    final String multiTermOrigin;\n    final String multiTermSynonym;\n    if (random().nextBoolean()) {\n      multiTermOrigin  = \"hansestadt hamburg\";\n      multiTermSynonym = \"hh\";\n    } else {\n      multiTermOrigin  = \"hh\";\n      multiTermSynonym = \"hansestadt hamburg\";\n    }\n    // multi-term logic similar to the angry/mad logic (angry ~ origin, mad ~ synonym)\n\n    assertU(adoc(newFieldName, \"I am a happy test today but yesterday I was angry\", \"id\", \"5150\"));\n    assertU(adoc(newFieldName, multiTermOrigin+\" is in North Germany.\", \"id\", \"040\"));\n    assertU(commit());\n\n    assertQ(\"/select?q=\" + newFieldName + \":angry\",\n            \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n            \"/response/result[@name='response'][@numFound='1']\",\n            \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    assertQ(\"/select?q=\" + newFieldName + \":\"+URLEncoder.encode(multiTermOrigin, \"UTF-8\"),\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n    \n    // add a mapping that will expand a query for \"mad\" to match docs with \"angry\"\n    syns = new HashMap<>();\n    syns.put(\"mad\", Arrays.asList(\"angry\"));    \n    assertJPut(endpoint, \n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint, \n        \"/synonymMappings/managedMap/mad==['angry']\");\n\n    // add a mapping that will expand a query for \"multi-term synonym\" to match docs with \"acronym\"\n    syns = new HashMap<>();\n    syns.put(multiTermSynonym, Arrays.asList(multiTermOrigin));\n    assertJPut(endpoint,\n               JSONUtil.toJSON(syns),\n               \"/responseHeader/status==0\");\n\n    assertJQ(endpoint+\"/\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\"),\n        \"/\"+multiTermSynonym+\"==['\"+multiTermOrigin+\"']\");\n\n    // should not match as the synonym mapping between mad and angry does not    \n    // get applied until core reload\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");    \n    \n    // should not match as the synonym mapping between \"origin\" and \"synonym\"\n    // was not added before the document was indexed\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='0']\");\n\n    restTestHarness.reload();\n\n    // now query for mad and we should see our test doc\n    assertQ(\"/select?q=\" + newFieldName + \":mad\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='5150']\");    \n    \n    // now query for \"synonym\" and we should see our test doc with \"origin\"\n    assertQ(\"/select?q=\" + newFieldName + \":(\"+URLEncoder.encode(multiTermSynonym, \"UTF-8\") + \")&sow=false\",\n        \"/response/lst[@name='responseHeader']/int[@name='status'] = '0'\",\n        \"/response/result[@name='response'][@numFound='1']\",\n        \"/response/result[@name='response']/doc/str[@name='id'][.='040']\");\n\n    // test for SOLR-6015\n    syns = new HashMap<>();\n    syns.put(\"mb\", Arrays.asList(\"megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n\n    syns.put(\"MB\", Arrays.asList(\"MiB\", \"Megabyte\"));    \n    assertJPut(endpoint,\n        JSONUtil.toJSON(syns),\n        \"/responseHeader/status==0\");\n    \n    assertJQ(endpoint + \"/MB\",\n        \"/MB==['Megabyte','MiB','megabyte']\");\n\n    // test for SOLR-6878 - by default, expand is true, but only applies when sending in a list\n    List<String> m2mSyns = new ArrayList<>();\n    m2mSyns.addAll(Arrays.asList(\"funny\", \"entertaining\", \"whimiscal\", \"jocular\"));\n    assertJPut(endpoint, JSONUtil.toJSON(m2mSyns), \"/responseHeader/status==0\");\n\n    assertJQ(endpoint + \"/funny\",\n        \"/funny==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/entertaining\",\n        \"/entertaining==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/jocular\",\n        \"/jocular==['entertaining','funny','jocular','whimiscal']\");\n    assertJQ(endpoint + \"/whimiscal\",\n        \"/whimiscal==['entertaining','funny','jocular','whimiscal']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["f494bc636a1302995e4930fdccd371eeda452f87"],"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9ed5f4bd4ee593745097b1ec9f0110b1997a9e58"],"4da8d4c422d841c0e5a997bf16dd471c5545d3e4":["3c897483ab479f5d1bcdd40400d20ef417b3b837"],"9ed5f4bd4ee593745097b1ec9f0110b1997a9e58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f494bc636a1302995e4930fdccd371eeda452f87":["67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba"],"9abfb16d083560e0a83d5c27b03f42ae7b5b22bb":["f494bc636a1302995e4930fdccd371eeda452f87"],"3c897483ab479f5d1bcdd40400d20ef417b3b837":["9ed5f4bd4ee593745097b1ec9f0110b1997a9e58"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["9abfb16d083560e0a83d5c27b03f42ae7b5b22bb"],"67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba":["4da8d4c422d841c0e5a997bf16dd471c5545d3e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"4da8d4c422d841c0e5a997bf16dd471c5545d3e4":["67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba"],"9ed5f4bd4ee593745097b1ec9f0110b1997a9e58":["5eb2511ababf862ea11e10761c70ee560cd84510","3c897483ab479f5d1bcdd40400d20ef417b3b837"],"f494bc636a1302995e4930fdccd371eeda452f87":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9abfb16d083560e0a83d5c27b03f42ae7b5b22bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","9ed5f4bd4ee593745097b1ec9f0110b1997a9e58"],"3c897483ab479f5d1bcdd40400d20ef417b3b837":["4da8d4c422d841c0e5a997bf16dd471c5545d3e4"],"9abfb16d083560e0a83d5c27b03f42ae7b5b22bb":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"67ef8e48a766655ce28a63ceb24b5f4c0a35b1ba":["f494bc636a1302995e4930fdccd371eeda452f87"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}