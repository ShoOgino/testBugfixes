{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","commits":[{"id":"36d13f271b6649357e07f71f7e46559479f69b5b","date":1523888226,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[],boolean).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType) && f.name().equals(config.softDeletesField) == false) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates, boolean enforceFieldExistence) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (enforceFieldExistence && !globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType) && f.name().equals(config.softDeletesField) == false) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType) && f.name().equals(config.softDeletesField) == false) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b","date":1526493560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType) && f.name().equals(config.softDeletesField) == false) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0);\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (globalFieldNumberMap.contains(f.name(), dvType) == false) {\n        // if this field doesn't exists we try to add it. if it exists and the DV type doesn't match we\n        // get a consistent error message as if you try to do that during an indexing operation.\n        globalFieldNumberMap.addOrGet(f.name(), -1, IndexOptions.NONE, dvType, 0, 0, f.name().equals(config.softDeletesField));\n        assert globalFieldNumberMap.contains(f.name(), dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n\n      switch (dvType) {\n        case NUMERIC:\n          Long value = (Long)f.numericValue();\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), value);\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f6652c943595e92c187ee904c382863013eae28f":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b"],"36d13f271b6649357e07f71f7e46559479f69b5b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["36d13f271b6649357e07f71f7e46559479f69b5b"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6652c943595e92c187ee904c382863013eae28f"]},"commit2Childs":{"f6652c943595e92c187ee904c382863013eae28f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["36d13f271b6649357e07f71f7e46559479f69b5b"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"36d13f271b6649357e07f71f7e46559479f69b5b":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["19eeb2dc8bb97107a6c38ad3c7fe91da9ad5019b"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}