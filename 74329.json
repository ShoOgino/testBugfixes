{"path":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newField(random, \"id\", \"\", StringField.TYPE_STORED);\n    Field randField = newField(random, \"rand\", \"\", StringField.TYPE_STORED);\n    Field bodyField = newField(random, \"body\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setValue(pad(r));\n        bodyField.setValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newField(random, \"id\", \"\", StringField.TYPE_STORED);\n    Field randField = newField(random, \"rand\", \"\", StringField.TYPE_STORED);\n    Field bodyField = newField(random, \"body\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setValue(pad(r));\n        bodyField.setValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newField(random, \"id\", \"\", StringField.TYPE_STORED);\n    Field randField = newField(random, \"rand\", \"\", StringField.TYPE_STORED);\n    Field bodyField = newField(random, \"body\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newField(random, \"id\", \"\", StringField.TYPE_STORED);\n    Field randField = newField(random, \"rand\", \"\", StringField.TYPE_STORED);\n    Field bodyField = newField(random, \"body\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setValue(pad(r));\n        bodyField.setValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":["3f59cacf51112a3af6d01ca16002ca03feec1c93"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newField(random, \"id\", \"\", StringField.TYPE_STORED);\n    Field randField = newField(random, \"rand\", \"\", StringField.TYPE_STORED);\n    Field bodyField = newField(random, \"body\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    _TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    doc.add(idField);\n    doc.add(intIdField);\n    doc.add(floatIdField);\n    doc.add(longIdField);\n    doc.add(doubleIdField);\n    doc.add(randField);\n    doc.add(bodyField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        intIdField.setIntValue(d);\n        floatIdField.setFloatValue(d);\n        longIdField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        bodyField.setStringValue(\"body\");\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, TEST_VERSION_CURRENT, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.shutdown();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new DimensionalIntField(\"id_int\", 0);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new DimensionalFloatField(\"id_float\", 0);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new DimensionalLongField(\"id_long\", 0);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DimensionalDoubleField(\"id_double\", 0);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntField(\"id_int\", 0, Store.YES);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatField(\"id_float\", 0, Store.YES);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongField(\"id_long\", 0, Store.YES);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoubleField(\"id_double\", 0, Store.YES);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter#build(Random,TestIndex).mjava","sourceNew":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new IntPoint(\"id_int\", 0);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new FloatPoint(\"id_float\", 0);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new LongPoint(\"id_long\", 0);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DoublePoint(\"id_double\", 0);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","sourceOld":"  private static IndexReader build(Random random, TestIndex index) throws IOException {\n    /* build an index */\n    \n    Document doc = new Document();\n    Field idField = newStringField(random, \"id\", \"\", Field.Store.YES);\n    Field idDVField = new SortedDocValuesField(\"id\", new BytesRef());\n    Field intIdField = new DimensionalIntField(\"id_int\", 0);\n    Field intDVField = new NumericDocValuesField(\"id_int\", 0);\n    Field floatIdField = new DimensionalFloatField(\"id_float\", 0);\n    Field floatDVField = new NumericDocValuesField(\"id_float\", 0);\n    Field longIdField = new DimensionalLongField(\"id_long\", 0);\n    Field longDVField = new NumericDocValuesField(\"id_long\", 0);\n    Field doubleIdField = new DimensionalDoubleField(\"id_double\", 0);\n    Field doubleDVField = new NumericDocValuesField(\"id_double\", 0);\n    Field randField = newStringField(random, \"rand\", \"\", Field.Store.YES);\n    Field randDVField = new SortedDocValuesField(\"rand\", new BytesRef());\n    Field bodyField = newStringField(random, \"body\", \"\", Field.Store.NO);\n    Field bodyDVField = new SortedDocValuesField(\"body\", new BytesRef());\n    doc.add(idField);\n    doc.add(idDVField);\n    doc.add(intIdField);\n    doc.add(intDVField);\n    doc.add(floatIdField);\n    doc.add(floatDVField);\n    doc.add(longIdField);\n    doc.add(longDVField);\n    doc.add(doubleIdField);\n    doc.add(doubleDVField);\n    doc.add(randField);\n    doc.add(randDVField);\n    doc.add(bodyField);\n    doc.add(bodyDVField);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, index.index, \n                                                     newIndexWriterConfig(random, new MockAnalyzer(random))\n                                                     .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(TestUtil.nextInt(random, 50, 1000)).setMergePolicy(newLogMergePolicy()));\n    TestUtil.reduceOpenFiles(writer.w);\n\n    while(true) {\n\n      int minCount = 0;\n      int maxCount = 0;\n\n      for (int d = minId; d <= maxId; d++) {\n        idField.setStringValue(pad(d));\n        idDVField.setBytesValue(new BytesRef(pad(d)));\n        intIdField.setIntValue(d);\n        intDVField.setLongValue(d);\n        floatIdField.setFloatValue(d);\n        floatDVField.setLongValue(Float.floatToRawIntBits(d));\n        longIdField.setLongValue(d);\n        longDVField.setLongValue(d);\n        doubleIdField.setDoubleValue(d);\n        doubleDVField.setLongValue(Double.doubleToRawLongBits(d));\n        int r = index.allowNegativeRandomInts ? random.nextInt() : random\n          .nextInt(Integer.MAX_VALUE);\n        if (index.maxR < r) {\n          index.maxR = r;\n          maxCount = 1;\n        } else if (index.maxR == r) {\n          maxCount++;\n        }\n\n        if (r < index.minR) {\n          index.minR = r;\n          minCount = 1;\n        } else if (r == index.minR) {\n          minCount++;\n        }\n        randField.setStringValue(pad(r));\n        randDVField.setBytesValue(new BytesRef(pad(r)));\n        bodyField.setStringValue(\"body\");\n        bodyDVField.setBytesValue(new BytesRef(\"body\"));\n        writer.addDocument(doc);\n      }\n\n      if (minCount == 1 && maxCount == 1) {\n        // our subclasses rely on only 1 doc having the min or\n        // max, so, we loop until we satisfy that.  it should be\n        // exceedingly rare (Yonik calculates 1 in ~429,000)\n        // times) that this loop requires more than one try:\n        IndexReader ir = writer.getReader();\n        writer.close();\n        return ir;\n      }\n\n      // try again\n      writer.deleteAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["770342641f7b505eaa8dccdc666158bff2419109"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["04f07771a2a7dd3a395700665ed839c3dae2def2","59a0020b413d44dd79d85d7a66ed5004265fb453"],"6613659748fe4411a7dcf85266e55db1f95f7315":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"770342641f7b505eaa8dccdc666158bff2419109":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"770342641f7b505eaa8dccdc666158bff2419109":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["37a0f60745e53927c4c876cfe5b5a58170f0646c","59a0020b413d44dd79d85d7a66ed5004265fb453"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","d0ef034a4f10871667ae75181537775ddcf8ade4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6613659748fe4411a7dcf85266e55db1f95f7315"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["770342641f7b505eaa8dccdc666158bff2419109"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}