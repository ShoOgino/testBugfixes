{"path":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random, 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random, 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random, 2), _TestUtil.randomUnicodeString(random, 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random, 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random, 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random, 2), _TestUtil.randomUnicodeString(random, 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random, 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random, 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random, 2), _TestUtil.randomUnicodeString(random, 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb07ab105350b80ed9d63ca64b117084ed7391bc","date":1344824719,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = CoalescedDeletes.mergedIterator(subs);\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c7a37580e62e8384ea11b972c15c00221cf64fa","date":1344870636,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[_TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = _TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(_TestUtil.randomUnicodeString(random(), 2), _TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<Term>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<Term>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<Iterator<Term>>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c1ca350a30f47355b5b27ad048195d462059727","date":1416523641,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    // NOTE: currenlty using diamond operator on MergedIterator (without explicit Term class) causes\n    // errors on ecj used for javadoc lint\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d90294f61f1156e3708019cde37e7069bafc5151","date":1416530088,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    // NOTE: currenlty using diamond operator on MergedIterator (without explicit Term class) causes\n    // errors on ecj used for javadoc lint\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e40d330ea7c711163302325e49a2c3d752cbcd4","date":1416557423,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    // NOTE: currenlty using diamond operator on MergedIterator (without explicit Term class) causes\n    // errors on Eclipse Compiler (ecj) used for javadoc lint\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    Iterator<Term> actual = new MergedIterator<>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n\n    while (true) {\n      if (actual.next()) {\n        field = actual.field();\n        if (field == null) {\n          break;\n        }\n        lastTerm = null;\n        //System.out.println(\"\\nTEST: new field: \" + field);\n      }\n      if (lastTerm != null && lastTerm.equals(actual.term())) {\n        continue;\n      }\n      //System.out.println(\"TEST: iter: field=\" + field + \" term=\" + actual.term());\n      lastTerm = BytesRef.deepCopyOf(actual.term());\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, actual.term()));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        Term term = new Term(TestUtil.randomUnicodeString(random(), 2), TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      for (Term ref: terms) {\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    List<Iterator<Term>> subs = new ArrayList<>();\n    for (int i = 0; i < pb.length; i++) {\n      subs.add(pb[i].iterator());\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n    // NOTE: currenlty using diamond operator on MergedIterator (without explicit Term class) causes\n    // errors on Eclipse Compiler (ecj) used for javadoc lint\n    Iterator<Term> actual = new MergedIterator<Term>(subs.toArray(new Iterator[0]));\n    while (actual.hasNext()) {\n      assertTrue(expected.hasNext());\n      assertEquals(expected.next(), actual.next());\n    }\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2","1e40d330ea7c711163302325e49a2c3d752cbcd4","6613659748fe4411a7dcf85266e55db1f95f7315"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"258f227b48a4dbfc180f6ec70f172469d6a2bef8","date":1428687213,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n    BytesRef term;\n    while ((term = actual.next()) != null) {\n      if (field != actual.field()) {\n        field = actual.field();\n        lastTerm = null;\n      }\n      if (lastTerm != null && lastTerm.equals(term)) {\n        continue;\n      }\n      lastTerm = BytesRef.deepCopyOf(term);\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, term));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n\n    while (true) {\n      if (actual.next()) {\n        field = actual.field();\n        if (field == null) {\n          break;\n        }\n        lastTerm = null;\n        //System.out.println(\"\\nTEST: new field: \" + field);\n      }\n      if (lastTerm != null && lastTerm.equals(actual.term())) {\n        continue;\n      }\n      //System.out.println(\"TEST: iter: field=\" + field + \" term=\" + actual.term());\n      lastTerm = BytesRef.deepCopyOf(actual.term());\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, actual.term()));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n    BytesRef term;\n    while ((term = actual.next()) != null) {\n      if (field != actual.field()) {\n        field = actual.field();\n        lastTerm = null;\n      }\n      if (lastTerm != null && lastTerm.equals(term)) {\n        continue;\n      }\n      lastTerm = BytesRef.deepCopyOf(term);\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, term));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n    BytesRef term;\n    while ((term = actual.next()) != null) {\n      if (field != actual.field()) {\n        field = actual.field();\n        lastTerm = null;\n      }\n      if (lastTerm != null && lastTerm.equals(term)) {\n        continue;\n      }\n      lastTerm = BytesRef.deepCopyOf(term);\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, term));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPrefixCodedTerms#testMergeRandom().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testMergeRandom() {\n    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];\n    Set<Term> superSet = new TreeSet<>();\n    \n    for (int i = 0; i < pb.length; i++) {\n      Set<Term> terms = new TreeSet<>();\n      int nterms = TestUtil.nextInt(random(), 0, 10000);\n      for (int j = 0; j < nterms; j++) {\n        String field = TestUtil.randomUnicodeString(random(), 2);\n        //String field = TestUtil.randomSimpleString(random(), 2);\n        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));\n        terms.add(term);\n      }\n      superSet.addAll(terms);\n    \n      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();\n      //System.out.println(\"TEST: sub \" + i + \" has \" + terms.size() + \" terms\");\n      for (Term ref: terms) {\n        //System.out.println(\"  add \" + ref.field() + \" \" + ref.bytes());\n        b.add(ref);\n      }\n      pb[i] = b.finish();\n    }\n    \n    Iterator<Term> expected = superSet.iterator();\n\n    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));\n    String field = \"\";\n\n    BytesRef lastTerm = null;\n    BytesRef term;\n    while ((term = actual.next()) != null) {\n      if (field != actual.field()) {\n        field = actual.field();\n        lastTerm = null;\n      }\n      if (lastTerm != null && lastTerm.equals(term)) {\n        continue;\n      }\n      lastTerm = BytesRef.deepCopyOf(term);\n      assertTrue(expected.hasNext());\n\n      Term expectedTerm = expected.next();\n      assertEquals(expectedTerm, new Term(field, term));\n    }\n\n    assertFalse(expected.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c1ca350a30f47355b5b27ad048195d462059727":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d90294f61f1156e3708019cde37e7069bafc5151":["2c1ca350a30f47355b5b27ad048195d462059727"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","0c7a37580e62e8384ea11b972c15c00221cf64fa"],"6613659748fe4411a7dcf85266e55db1f95f7315":["0c7a37580e62e8384ea11b972c15c00221cf64fa"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["258f227b48a4dbfc180f6ec70f172469d6a2bef8"],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","0c7a37580e62e8384ea11b972c15c00221cf64fa"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["258f227b48a4dbfc180f6ec70f172469d6a2bef8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["258f227b48a4dbfc180f6ec70f172469d6a2bef8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"0c7a37580e62e8384ea11b972c15c00221cf64fa":["fb07ab105350b80ed9d63ca64b117084ed7391bc"],"1e40d330ea7c711163302325e49a2c3d752cbcd4":["d90294f61f1156e3708019cde37e7069bafc5151"],"258f227b48a4dbfc180f6ec70f172469d6a2bef8":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7e4c214a1f904dde76f5611b56d4081533055b3b":["1e40d330ea7c711163302325e49a2c3d752cbcd4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"2c1ca350a30f47355b5b27ad048195d462059727":["d90294f61f1156e3708019cde37e7069bafc5151"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2c1ca350a30f47355b5b27ad048195d462059727"],"d90294f61f1156e3708019cde37e7069bafc5151":["1e40d330ea7c711163302325e49a2c3d752cbcd4"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["0c7a37580e62e8384ea11b972c15c00221cf64fa","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0c7a37580e62e8384ea11b972c15c00221cf64fa":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","6613659748fe4411a7dcf85266e55db1f95f7315","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"1e40d330ea7c711163302325e49a2c3d752cbcd4":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"258f227b48a4dbfc180f6ec70f172469d6a2bef8":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["258f227b48a4dbfc180f6ec70f172469d6a2bef8"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["fb07ab105350b80ed9d63ca64b117084ed7391bc","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}