{"path":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","commits":[{"id":"637a392e2e05d4e1179ac3c532cfeef0cde977ba","date":1376347977,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<String>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<String>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49368dc30c6d7f57e2547707f2a26a2e790dc587","date":1378306664,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","sourceNew":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<String>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      assert child[0]==\"child_s\" && child[2]==\"parentchild_s\": Arrays.toString(child);\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","sourceOld":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<String>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#addGrandChildren(List[String[]]).mjava","sourceNew":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      assert child[0]==\"child_s\" && child[2]==\"parentchild_s\": Arrays.toString(child);\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","sourceOld":"  private static void addGrandChildren(List<String[]> block) {\n    List<String> grandChildren = new ArrayList<String>(xyz);\n    // add grandchildren after children\n    for (ListIterator<String[]> iter = block.listIterator(); iter.hasNext();) {\n      String[] child = iter.next();\n      assert child[0]==\"child_s\" && child[2]==\"parentchild_s\": Arrays.toString(child);\n      String child_s = child[1];\n      String parentchild_s = child[3];\n      int grandChildPos = 0;\n      boolean lastLoopButStillHasGrCh = !iter.hasNext()\n          && !grandChildren.isEmpty();\n      while (!grandChildren.isEmpty()\n          && ((grandChildPos = random().nextInt(grandChildren.size() * 2)) < grandChildren\n              .size() || lastLoopButStillHasGrCh)) {\n        grandChildPos = grandChildPos >= grandChildren.size() ? 0\n            : grandChildPos;\n        iter.add(new String[] {\"grand_s\", grandChildren.remove(grandChildPos),\n            \"grand_child_s\", child_s, \"grand_parentchild_s\", parentchild_s});\n      }\n    }\n    // and reverse after that\n    Collections.reverse(block);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["49368dc30c6d7f57e2547707f2a26a2e790dc587"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"49368dc30c6d7f57e2547707f2a26a2e790dc587":["637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","49368dc30c6d7f57e2547707f2a26a2e790dc587"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"49368dc30c6d7f57e2547707f2a26a2e790dc587":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}