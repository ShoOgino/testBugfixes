{"path":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  > <code>startTerm</code>, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  > <code>startTerm</code>, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  > <code>startTerm</code>, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator(null);\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator(null);\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms that\n   *  are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only accept terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(iterator(null), compiled);\n    } else {\n      return new AutomatonTermsEnum(iterator(null), compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator(null);\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61eadeb75db46a857947318760374f73002b0354","date":1480710364,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   *  <p>This is an expert low-level API and will only work\n   *  for {@code NORMAL} compiled automata.  To handle any\n   *  compiled automata you should instead use\n   *  {@link CompiledAutomaton#getTermsEnum} instead.\n   *\n   *  <p><b>NOTE</b>: the returned TermsEnum cannot seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   *  <p>This is an expert low-level API and will only work\n   *  for {@code NORMAL} compiled automata.  To handle any\n   *  compiled automata you should instead use\n   *  {@link CompiledAutomaton#getTermsEnum} instead.\n   *\n   *  <p><b>NOTE</b>: the returned TermsEnum cannot seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   * <p><b>NOTE</b>: the returned TermsEnum cannot\n   * seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#intersect(CompiledAutomaton,BytesRef).mjava","sourceNew":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   *  <p>This is an expert low-level API and will only work\n   *  for {@code NORMAL} compiled automata.  To handle any\n   *  compiled automata you should instead use\n   *  {@link CompiledAutomaton#getTermsEnum} instead.\n   *\n   *  <p><b>NOTE</b>: the returned TermsEnum cannot seek</p>.\n   */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a TermsEnum that iterates over all terms and\n   *  documents that are accepted by the provided {@link\n   *  CompiledAutomaton}.  If the <code>startTerm</code> is\n   *  provided then the returned enum will only return terms\n   *  {@code > startTerm}, but you still must call\n   *  next() first to get to the first term.  Note that the\n   *  provided <code>startTerm</code> must be accepted by\n   *  the automaton.\n   *\n   *  <p>This is an expert low-level API and will only work\n   *  for {@code NORMAL} compiled automata.  To handle any\n   *  compiled automata you should instead use\n   *  {@link CompiledAutomaton#getTermsEnum} instead.\n   *\n   *  <p><b>NOTE</b>: the returned TermsEnum cannot seek</p>.\n   *\n   *  <p><b>NOTE</b>: the terms dictionary is free to\n   *  return arbitrary terms as long as the resulted visited\n   *  docs is the same.  E.g., {@link BlockTreeTermsWriter}\n   *  creates auto-prefix terms during indexing to reduce the\n   *  number of terms visited. */\n  public TermsEnum intersect(CompiledAutomaton compiled, final BytesRef startTerm) throws IOException {\n    \n    // TODO: could we factor out a common interface b/w\n    // CompiledAutomaton and FST?  Then we could pass FST there too,\n    // and likely speed up resolving terms to deleted docs ... but\n    // AutomatonTermsEnum makes this tricky because of its on-the-fly cycle\n    // detection\n    \n    // TODO: eventually we could support seekCeil/Exact on\n    // the returned enum, instead of only being able to seek\n    // at the start\n\n    TermsEnum termsEnum = iterator();\n\n    if (compiled.type != CompiledAutomaton.AUTOMATON_TYPE.NORMAL) {\n      throw new IllegalArgumentException(\"please use CompiledAutomaton.getTermsEnum instead\");\n    }\n\n    if (startTerm == null) {\n      return new AutomatonTermsEnum(termsEnum, compiled);\n    } else {\n      return new AutomatonTermsEnum(termsEnum, compiled) {\n        @Override\n        protected BytesRef nextSeekTerm(BytesRef term) throws IOException {\n          if (term == null) {\n            term = startTerm;\n          }\n          return super.nextSeekTerm(term);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["3e8715d826e588419327562287d5d6a8040d63d6"],"61eadeb75db46a857947318760374f73002b0354":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["61eadeb75db46a857947318760374f73002b0354"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["7e4c214a1f904dde76f5611b56d4081533055b3b","3e8715d826e588419327562287d5d6a8040d63d6"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"9856095f7afb5a607bf5e65077615ed91273508c":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","61eadeb75db46a857947318760374f73002b0354"],"3e8715d826e588419327562287d5d6a8040d63d6":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd96a930cc08d72beee719cc11ce465b9d9861c3"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["61eadeb75db46a857947318760374f73002b0354","9856095f7afb5a607bf5e65077615ed91273508c"],"61eadeb75db46a857947318760374f73002b0354":["dd96a930cc08d72beee719cc11ce465b9d9861c3","9856095f7afb5a607bf5e65077615ed91273508c"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"7e4c214a1f904dde76f5611b56d4081533055b3b":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"3e8715d826e588419327562287d5d6a8040d63d6":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}