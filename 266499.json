{"path":"lucene/core/src/test/org/apache/lucene/index/TestFieldInfos#testFieldAttributes().mjava","commits":[{"id":"1dbcafacd03baeb0f18199de611a1619606073c5","date":1546559081,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldInfos#testFieldAttributes().mjava","pathOld":"/dev/null","sourceNew":"  public void testFieldAttributes() throws Exception{\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n\n    FieldType type1 = new FieldType();\n    type1.setStored(true);\n    type1.putAttribute(\"testKey1\", \"testValue1\");\n\n    Document d1 = new Document();\n    d1.add(new Field(\"f1\", \"v1\", type1));\n    FieldType type2 = new FieldType(type1);\n    //changing the value after copying shouldn't impact the original type1\n    type2.putAttribute(\"testKey1\", \"testValue2\");\n    writer.addDocument(d1);\n    writer.commit();\n\n    Document d2 = new Document();\n    type1.putAttribute(\"testKey1\", \"testValueX\");\n    type1.putAttribute(\"testKey2\", \"testValue2\");\n    d2.add(new Field(\"f1\", \"v2\", type1));\n    d2.add(new Field(\"f2\", \"v2\", type2));\n    writer.addDocument(d2);\n    writer.commit();\n    writer.forceMerge(1);\n\n    IndexReader reader = writer.getReader();\n    FieldInfos fis = FieldInfos.getMergedFieldInfos(reader);\n    assertEquals(fis.size(), 2);\n    Iterator<FieldInfo>  it = fis.iterator();\n    while(it.hasNext()) {\n      FieldInfo fi = it.next();\n      switch (fi.name) {\n        case \"f1\":\n          // testKey1 can point to either testValue1 or testValueX based on the order\n          // of merge, but we see textValueX winning here since segment_2 is merged on segment_1.\n          assertEquals(\"testValueX\", fi.getAttribute(\"testKey1\"));\n          assertEquals(\"testValue2\", fi.getAttribute(\"testKey2\"));\n          break;\n        case \"f2\":\n          assertEquals(\"testValue2\", fi.getAttribute(\"testKey1\"));\n          break;\n        default:\n          assertFalse(\"Unknown field\", true);\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1dbcafacd03baeb0f18199de611a1619606073c5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1dbcafacd03baeb0f18199de611a1619606073c5"]},"commit2Childs":{"1dbcafacd03baeb0f18199de611a1619606073c5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1dbcafacd03baeb0f18199de611a1619606073c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}