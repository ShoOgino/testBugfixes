{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#handleFilterExclusions().mjava","commits":[{"id":"9e47fba8dd946896c408eb448f6199f5a9f0da2d","date":1434234768,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#handleFilterExclusions().mjava","pathOld":"/dev/null","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"]},"commit2Childs":{"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}