{"path":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrClient solr = new HttpSolrClient(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a39e2b1b10e1030ae81cfabe5ade68d2b9917c03","date":1421346288,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrClient solr = new HttpSolrClient(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrClient solr = new HttpSolrClient(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrClient solr = new HttpSolrClient(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca20be81c9284c840498143264e583ccbb8525a","date":1438705932,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8677448a186f4abd32218787f7ae73ad38f575cf","date":1477484362,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86d2df3ca94d97c62f70b0d321f5f597de2d3eb3","date":1503399053,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b79a5db147a1c6f95d1625ddbc3561ef56955225","date":1528848080,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n\n      log.debug(\"Running healthcheck for \"+collection);\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n\n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000);\n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);\n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n\n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n\n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n\n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();\n        for (Replica r : slice.getReplicas()) {\n\n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n\n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl,\n              replicaStatus, numDocs, isLeader, uptime, memory));\n        }\n\n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);\n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n\n        shardList.add(shardHealth.asMap());\n      }\n\n\n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());\n      report.put(\"shards\", shardList);\n\n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.debug(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000); \n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n\n      log.debug(\"Running healthcheck for {}\", collection);\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n\n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000);\n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);\n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n\n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n\n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard {} due to: {}\", shardName, exc);\n        }\n\n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();\n        for (Replica r : slice.getReplicas()) {\n\n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n\n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: {} when trying to reach: {}\", exc, coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl,\n              replicaStatus, numDocs, isLeader, uptime, memory));\n        }\n\n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);\n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n\n        shardList.add(shardHealth.asMap());\n      }\n\n\n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());\n      report.put(\"shards\", shardList);\n\n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      raiseLogLevelUnlessVerbose(cli);\n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n\n      log.debug(\"Running healthcheck for \"+collection);\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      if (docCollection == null || docCollection.getSlices() == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n\n      Collection<Slice> slices = docCollection.getSlices();\n      // Test http code using a HEAD request first, fail fast if authentication failure\n      String urlForColl = zkStateReader.getLeaderUrl(collection, slices.stream().findFirst().get().getName(), 1000);\n      attemptHttpHead(urlForColl, cloudSolrClient.getHttpClient());\n\n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);\n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n\n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n\n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n\n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();\n        for (Replica r : slice.getReplicas()) {\n\n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n\n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = Replica.State.DOWN.toString();\n          } else {\n            // query this replica directly to get doc count and assess health\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(DISTRIB, \"false\");\n            try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n\n              String solrUrl = solr.getBaseURL();\n\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2, true);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + coreUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = Replica.State.DOWN.toString();\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl,\n              replicaStatus, numDocs, isLeader, uptime, memory));\n        }\n\n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);\n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n\n        shardList.add(shardHealth.asMap());\n      }\n\n\n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());\n      report.put(\"shards\", shardList);\n\n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      echo(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"344b0840364d990b29b97467bfcc766ff8325d11":["01624b85de12fb02335810bdf325124e59040772"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["4ca20be81c9284c840498143264e583ccbb8525a"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["8677448a186f4abd32218787f7ae73ad38f575cf"],"a39e2b1b10e1030ae81cfabe5ade68d2b9917c03":["bafca15d8e408346a67f4282ad1143b88023893b"],"01624b85de12fb02335810bdf325124e59040772":["8677448a186f4abd32218787f7ae73ad38f575cf"],"b79a5db147a1c6f95d1625ddbc3561ef56955225":["86d2df3ca94d97c62f70b0d321f5f597de2d3eb3"],"4ca20be81c9284c840498143264e583ccbb8525a":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["86d2df3ca94d97c62f70b0d321f5f597de2d3eb3","b79a5db147a1c6f95d1625ddbc3561ef56955225"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["6f4c5d3859373c3a74734e85efa122b17514e3e8","344b0840364d990b29b97467bfcc766ff8325d11"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","86d2df3ca94d97c62f70b0d321f5f597de2d3eb3"],"8677448a186f4abd32218787f7ae73ad38f575cf":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","8677448a186f4abd32218787f7ae73ad38f575cf"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["4ca20be81c9284c840498143264e583ccbb8525a","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"86d2df3ca94d97c62f70b0d321f5f597de2d3eb3":["344b0840364d990b29b97467bfcc766ff8325d11"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["a39e2b1b10e1030ae81cfabe5ade68d2b9917c03"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["b79a5db147a1c6f95d1625ddbc3561ef56955225"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["86d2df3ca94d97c62f70b0d321f5f597de2d3eb3","b79a5db147a1c6f95d1625ddbc3561ef56955225"]},"commit2Childs":{"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","86d2df3ca94d97c62f70b0d321f5f597de2d3eb3"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bafca15d8e408346a67f4282ad1143b88023893b":["a39e2b1b10e1030ae81cfabe5ade68d2b9917c03"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"a39e2b1b10e1030ae81cfabe5ade68d2b9917c03":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"01624b85de12fb02335810bdf325124e59040772":["344b0840364d990b29b97467bfcc766ff8325d11"],"b79a5db147a1c6f95d1625ddbc3561ef56955225":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4ca20be81c9284c840498143264e583ccbb8525a":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["4ca20be81c9284c840498143264e583ccbb8525a"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"8677448a186f4abd32218787f7ae73ad38f575cf":["6f4c5d3859373c3a74734e85efa122b17514e3e8","01624b85de12fb02335810bdf325124e59040772","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["8677448a186f4abd32218787f7ae73ad38f575cf","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"86d2df3ca94d97c62f70b0d321f5f597de2d3eb3":["b79a5db147a1c6f95d1625ddbc3561ef56955225","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","3a7809d1d753b67f48b1a706e17034bf8b624ea3","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","3a7809d1d753b67f48b1a706e17034bf8b624ea3","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}