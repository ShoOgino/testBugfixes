{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersIndexOutput#getChecksum().mjava","commits":[{"id":"fad01f81cc24b33263ccec7dbff3fb907702f91e","date":1535461373,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersIndexOutput#getChecksum().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public long getChecksum() throws IOException {\n    ensureOpen();\n\n    if (checksum == null) {\n      throw new IOException(\"This index output has no checksum computing ability: \" + toString());\n    }\n\n    // Compute checksum on the current content of the delegate.\n    //\n    // This way we can override more methods and pass them directly to the delegate for efficiency of writing,\n    // while allowing the checksum to be correctly computed on the current content of the output buffer (IndexOutput\n    // is per-thread, so no concurrent changes).\n    if (lastChecksumPosition != delegate.size()) {\n      lastChecksumPosition = delegate.size();\n      checksum.reset();\n      byte [] buffer = null;\n      for (ByteBuffer bb : delegate.toBufferList()) {\n        if (bb.hasArray()) {\n          checksum.update(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining());\n        } else {\n          if (buffer == null) buffer = new byte [1024 * 4];\n\n          bb = bb.asReadOnlyBuffer();\n          int remaining = bb.remaining();\n          while (remaining > 0) {\n            int len = Math.min(remaining, buffer.length);\n            bb.get(buffer, 0, len);\n            checksum.update(buffer, 0, len);\n            remaining -= len;\n          }\n        }\n      }\n      lastChecksum = checksum.getValue(); \n    }\n    return lastChecksum;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b7c65f55f6bfe02eef00e3561cf25e5e5c86552","date":1592303817,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersIndexOutput#getChecksum().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersIndexOutput#getChecksum().mjava","sourceNew":"  @Override\n  public long getChecksum() throws IOException {\n    ensureOpen();\n\n    if (checksum == null) {\n      throw new IOException(\"This index output has no checksum computing ability: \" + toString());\n    }\n\n    // Compute checksum on the current content of the delegate.\n    //\n    // This way we can override more methods and pass them directly to the delegate for efficiency of writing,\n    // while allowing the checksum to be correctly computed on the current content of the output buffer (IndexOutput\n    // is per-thread, so no concurrent changes).\n    if (lastChecksumPosition != delegate.size()) {\n      lastChecksumPosition = delegate.size();\n      checksum.reset();\n      for (ByteBuffer bb : delegate.toBufferList()) {\n        checksum.update(bb);\n      }\n      lastChecksum = checksum.getValue();\n    }\n    return lastChecksum;\n  }\n\n","sourceOld":"  @Override\n  public long getChecksum() throws IOException {\n    ensureOpen();\n\n    if (checksum == null) {\n      throw new IOException(\"This index output has no checksum computing ability: \" + toString());\n    }\n\n    // Compute checksum on the current content of the delegate.\n    //\n    // This way we can override more methods and pass them directly to the delegate for efficiency of writing,\n    // while allowing the checksum to be correctly computed on the current content of the output buffer (IndexOutput\n    // is per-thread, so no concurrent changes).\n    if (lastChecksumPosition != delegate.size()) {\n      lastChecksumPosition = delegate.size();\n      checksum.reset();\n      byte [] buffer = null;\n      for (ByteBuffer bb : delegate.toBufferList()) {\n        if (bb.hasArray()) {\n          checksum.update(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining());\n        } else {\n          if (buffer == null) buffer = new byte [1024 * 4];\n\n          bb = bb.asReadOnlyBuffer();\n          int remaining = bb.remaining();\n          while (remaining > 0) {\n            int len = Math.min(remaining, buffer.length);\n            bb.get(buffer, 0, len);\n            checksum.update(buffer, 0, len);\n            remaining -= len;\n          }\n        }\n      }\n      lastChecksum = checksum.getValue(); \n    }\n    return lastChecksum;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0b7c65f55f6bfe02eef00e3561cf25e5e5c86552":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0b7c65f55f6bfe02eef00e3561cf25e5e5c86552"]},"commit2Childs":{"0b7c65f55f6bfe02eef00e3561cf25e5e5c86552":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["0b7c65f55f6bfe02eef00e3561cf25e5e5c86552"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}