{"path":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c36db4818c5eba16bdcbedab4f06dd69ae59190","date":1329160108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeReopen();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeReopen();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.getSearcherManager().isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager().acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      manager.getSearcherManager().release(acquire);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c380c22ff3b659b2d7412a3335f853d354d17568","date":1329505731,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeReopen();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeReopen();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.getSearcherManager().isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager().acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      manager.getSearcherManager().release(acquire);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd3d3f2795e41d3a2c43747d73774dd5b596d686","date":1358192909,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(random().nextBoolean() ? NoMergePolicy.COMPOUND_FILES : NoMergePolicy.NO_COMPOUND_FILES);\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(random().nextBoolean() ? NoMergePolicy.COMPOUND_FILES : NoMergePolicy.NO_COMPOUND_FILES);\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2045b132a2396bb23dff28d2d9f349a6907d36e","date":1367513076,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(random().nextBoolean() ? NoMergePolicy.COMPOUND_FILES : NoMergePolicy.NO_COMPOUND_FILES);\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final TrackingIndexWriter writer = new TrackingIndexWriter(_writer);\n    final SearcherManager manager = new SearcherManager(_writer, false, null);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    writer.addDocument(doc);\n    manager.maybeRefresh();\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    final ControlledRealTimeReopenThread<IndexSearcher> thread = new ControlledRealTimeReopenThread<IndexSearcher>(writer, manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        try {\n          thread.waitForGeneration(lastGen);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(ie);\n        }\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(random().nextBoolean() ? NoMergePolicy.COMPOUND_FILES : NoMergePolicy.NO_COMPOUND_FILES);\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter _writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager.TrackingIndexWriter writer = new NRTManager.TrackingIndexWriter(_writer);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newTextField(\"test\", \"test\", Field.Store.YES));\n    long gen = writer.addDocument(doc);\n    manager.maybeRefresh();\n    assertFalse(gen < manager.getCurrentSearchingGen());\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          signal.await();\n          manager.maybeRefresh();\n          writer.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeRefresh(); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    _writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = writer.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n\n    assertFalse(manager.isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher searcher = manager.acquire();\n    try {\n      assertEquals(2, searcher.getIndexReader().numDocs());\n    } finally {\n      manager.release(searcher);\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      @Override\n      public void run() {\n        manager.waitForGeneration(lastGen);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeRefresh();\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, _writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["04f07771a2a7dd3a395700665ed839c3dae2def2","7530de27b87b961b51f01bd1299b7004d46e8823"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["cd3d3f2795e41d3a2c43747d73774dd5b596d686"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd3d3f2795e41d3a2c43747d73774dd5b596d686"],"c380c22ff3b659b2d7412a3335f853d354d17568":["2c36db4818c5eba16bdcbedab4f06dd69ae59190"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd3d3f2795e41d3a2c43747d73774dd5b596d686":["7530de27b87b961b51f01bd1299b7004d46e8823"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["c380c22ff3b659b2d7412a3335f853d354d17568"],"7530de27b87b961b51f01bd1299b7004d46e8823":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"2c36db4818c5eba16bdcbedab4f06dd69ae59190":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2045b132a2396bb23dff28d2d9f349a6907d36e"]},"commit2Childs":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"c380c22ff3b659b2d7412a3335f853d354d17568":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2c36db4818c5eba16bdcbedab4f06dd69ae59190"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd3d3f2795e41d3a2c43747d73774dd5b596d686":["c2045b132a2396bb23dff28d2d9f349a6907d36e","c4015cd39dff8d4dec562d909f9766debac53aa6"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd3d3f2795e41d3a2c43747d73774dd5b596d686"],"2c36db4818c5eba16bdcbedab4f06dd69ae59190":["c380c22ff3b659b2d7412a3335f853d354d17568"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}