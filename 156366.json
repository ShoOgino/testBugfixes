{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","commits":[{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result) throws IOException {\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: always collect counts or not???\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      processStats(bucket, result, count);\n      processSubs(bucket, q, result);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result) throws IOException {\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: always collect counts or not???\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      processStats(bucket, result, count);\n      processSubs(bucket, q, result);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"11ab475c994c79138885cc8a30b2641d929cdc43":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["11ab475c994c79138885cc8a30b2641d929cdc43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["58b93c361b4f6fe193e84bfd27ea523366eada52"]},"commit2Childs":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"11ab475c994c79138885cc8a30b2641d929cdc43":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["11ab475c994c79138885cc8a30b2641d929cdc43","8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"8908009aaa8e9318b455c1c22b83e0e87738228a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8908009aaa8e9318b455c1c22b83e0e87738228a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}