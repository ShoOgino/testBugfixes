{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","commits":[{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrosses(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"  \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrosses(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"  \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"  \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9","date":1462223095,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"   Considering points \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"  \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"   Considering points \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7068f8ae7a1c26fc559b74e13088efa5f67bd1bf","date":1462474060,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVector.x * t1 + x0;\n      final double point1Y = lineVector.y * t1 + y0;\n      final double point1Z = lineVector.z * t1 + z0;\n      final double point2X = lineVector.x * t2 + x0;\n      final double point2Y = lineVector.y * t2 + y0;\n      final double point2Z = lineVector.z * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"   Considering points \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f62d3e07d022fc0a93a17d141edb605494aa3ee7","date":1462480525,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVector.x * t1 + x0;\n      final double point1Y = lineVector.y * t1 + y0;\n      final double point1Z = lineVector.z * t1 + z0;\n      final double point2X = lineVector.x * t2 + x0;\n      final double point2Y = lineVector.y * t2 + y0;\n      final double point2Z = lineVector.z * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"   Considering points \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);\n    if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVector.x * lineVector.x * planetModel.inverseAbSquared +\n      lineVector.y * lineVector.y * planetModel.inverseAbSquared +\n      lineVector.z * lineVector.z * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      GeoPoint point1 = new GeoPoint(lineVector.x * t1 + x0, lineVector.y * t1 + y0, lineVector.z * t1 + z0);\n      GeoPoint point2 = new GeoPoint(lineVector.x * t2 + x0, lineVector.y * t2 + y0, lineVector.z * t2 + z0);\n      //verifyPoint(planetModel, point1, q);\n      //verifyPoint(planetModel, point2, q);\n      //System.err.println(\"   Considering points \"+point1+\" and \"+point2);\n      if (point1.isWithin(bounds, moreBounds)) {\n        if (point2.isWithin(bounds, moreBounds))\n          return new GeoPoint[]{point1, point2};\n        return new GeoPoint[]{point1};\n      }\n      if (point2.isWithin(bounds, moreBounds))\n        return new GeoPoint[]{point2};\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findCrossings(PlanetModel,Plane,Membership[],Membership[]).mjava","sourceNew":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / zScaling d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/zScaling^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/zScaling^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / zScaling^2 + 2CC0t / zScaling^2 + C0^2 / zScaling^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / zScaling^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / zScaling^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / zScaling^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseXYScalingSquared +\n      lineVectorY * lineVectorY * planetModel.inverseXYScalingSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseZScalingSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseXYScalingSquared + lineVectorY * y0 * planetModel.inverseXYScalingSquared + lineVectorZ * z0 * planetModel.inverseZScalingSquared);\n    final double C = x0 * x0 * planetModel.inverseXYScalingSquared + y0 * y0 * planetModel.inverseXYScalingSquared + z0 * z0 * planetModel.inverseZScalingSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the points between two planes, where one plane crosses the other, given a set of bounds.\n   * Crossing is not just intersection; the planes cannot touch at just one point on the ellipsoid,\n   * but must cross at two.\n   *\n   * @param planetModel is the planet model to use in finding points.\n   * @param q          is the plane to intersect with.\n   * @param bounds     is the set of bounds.\n   * @param moreBounds is another set of bounds.\n   * @return the intersection point(s) on the ellipsoid, if there are any.\n   */\n  protected GeoPoint[] findCrossings(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {\n    // This code in this method is very similar to findIntersections(), but eliminates the cases where\n    // crossings are detected.\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      return NO_POINTS;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    double x0;\n    double y0;\n    double z0;\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomYZ;\n      x0 = 0.0;\n      y0 = (-this.D * q.z - this.z * -q.D) * denom;\n      z0 = (this.y * -q.D + this.D * q.y) * denom;\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXZ;\n      x0 = (-this.D * q.z - this.z * -q.D) * denom;\n      y0 = 0.0;\n      z0 = (this.x * -q.D + this.D * q.x) * denom;\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        return NO_POINTS;\n      }\n      final double denom = 1.0 / denomXY;\n      x0 = (-this.D * q.y - this.y * -q.D) * denom;\n      y0 = (this.x * -q.D + this.D * q.x) * denom;\n      z0 = 0.0;\n    }\n\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      // One point of intersection: cannot be a crossing.\n      return NO_POINTS;\n    } else if (BsquaredMinus > 0.0) {\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      if (point1Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point1X, point1Y, point1Z)) {\n            point1Valid = false;\n            break;\n          }\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n      if (point2Valid) {\n        for (final Membership bound : moreBounds) {\n          if (!bound.isWithin(point2X, point2Y, point2Z)) {\n            point2Valid = false;\n            break;\n          }\n        }\n      }\n\n      if (point1Valid && point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z), new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      if (point1Valid) {\n        return new GeoPoint[]{new GeoPoint(point1X, point1Y, point1Z)};\n      }\n      if (point2Valid) {\n        return new GeoPoint[]{new GeoPoint(point2X, point2Y, point2Z)};\n      }\n      return NO_POINTS;\n    } else {\n      // No solutions.\n      return NO_POINTS;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9","f62d3e07d022fc0a93a17d141edb605494aa3ee7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["f62d3e07d022fc0a93a17d141edb605494aa3ee7"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7068f8ae7a1c26fc559b74e13088efa5f67bd1bf":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","f62d3e07d022fc0a93a17d141edb605494aa3ee7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"f62d3e07d022fc0a93a17d141edb605494aa3ee7":["7068f8ae7a1c26fc559b74e13088efa5f67bd1bf"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"]},"commit2Childs":{"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7068f8ae7a1c26fc559b74e13088efa5f67bd1bf","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7068f8ae7a1c26fc559b74e13088efa5f67bd1bf":["f62d3e07d022fc0a93a17d141edb605494aa3ee7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"f62d3e07d022fc0a93a17d141edb605494aa3ee7":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}