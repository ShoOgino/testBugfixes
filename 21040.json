{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0716ddfa41d3662d014c42086a700ad78fc5dcb","date":1275676935,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    if (merge.mergeFiles != null) {\n      deleter.decRef(merge.mergeFiles);\n      merge.mergeFiles = null;\n    }\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5","date":1290247889,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    if (merge.mergeFiles != null) {\n      deleter.decRef(merge.mergeFiles);\n      merge.mergeFiles = null;\n    }\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    if (merge.mergeFiles != null) {\n      deleter.decRef(merge.mergeFiles);\n      merge.mergeFiles = null;\n    }\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    if (merge.increfDone)\n      decrefMergeSegments(merge);\n\n    if (merge.mergeFiles != null) {\n      deleter.decRef(merge.mergeFiles);\n      merge.mergeFiles = null;\n    }\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","date":1297940445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++)\n        mergingSegments.remove(sourceSegments.info(i));\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01e5948db9a07144112d2f08f28ca2e3cd880348","date":1301759232,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5270fb4f55a1b77663dda53cb8090c083f0a23b3","date":1305050821,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n    \n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final SegmentInfos sourceSegments = merge.segments;\n      final int end = sourceSegments.size();\n      for(int i=0;i<end;i++) {\n        mergingSegments.remove(sourceSegments.info(i));\n      }\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // forceMerge, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // Optimize, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#mergeFinish(MergePolicy.OneMerge).mjava","sourceNew":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // forceMerge, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","sourceOld":"  /** Does fininishing for a merge, which is fast but holds\n   *  the synchronized lock on IndexWriter instance. */\n  final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException {\n\n    // forceMerge, addIndexes or finishMerges may be waiting\n    // on merges to finish.\n    notifyAll();\n\n    // It's possible we are called twice, eg if there was an\n    // exception inside mergeInit\n    if (merge.registerDone) {\n      final List<SegmentInfo> sourceSegments = merge.segments;\n      for(SegmentInfo info : sourceSegments) {\n        mergingSegments.remove(info);\n      }\n      // TODO: if we remove the add in _mergeInit, we should\n      // also remove this:\n      mergingSegments.remove(merge.info);\n      merge.registerDone = false;\n    }\n\n    runningMerges.remove(merge);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["3bb13258feba31ab676502787ab2e1779f129b7a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["01e5948db9a07144112d2f08f28ca2e3cd880348","45669a651c970812a680841b97a77cce06af559f"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["c0716ddfa41d3662d014c42086a700ad78fc5dcb","8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"01e5948db9a07144112d2f08f28ca2e3cd880348":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"c0716ddfa41d3662d014c42086a700ad78fc5dcb":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"45669a651c970812a680841b97a77cce06af559f":["bde51b089eb7f86171eb3406e38a274743f9b7ac","01e5948db9a07144112d2f08f28ca2e3cd880348"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"3bb13258feba31ab676502787ab2e1779f129b7a":["c0716ddfa41d3662d014c42086a700ad78fc5dcb","8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","3bb13258feba31ab676502787ab2e1779f129b7a"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","01e5948db9a07144112d2f08f28ca2e3cd880348","a3776dccca01c11e7046323cfad46a3b4a471233","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c0716ddfa41d3662d014c42086a700ad78fc5dcb":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a"],"01e5948db9a07144112d2f08f28ca2e3cd880348":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","45669a651c970812a680841b97a77cce06af559f"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"45669a651c970812a680841b97a77cce06af559f":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"3bb13258feba31ab676502787ab2e1779f129b7a":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["45669a651c970812a680841b97a77cce06af559f"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}