{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","commits":[{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","pathOld":"/dev/null","sourceNew":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        return new Node(newEdge, minimumValue, maximumValue);\n      }\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n        // The node is contained in the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        rval.within = node.within;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        // The new edge overlaps the minimum value, but not the maximum value.\n        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n        final double lesserMaximum = Math.nextDown(node.minimumValue);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n        return addEdge(node, newEdge, node.minimumValue, maximumValue);\n      case OVERLAPS_MAXIMUM:\n        // The new edge overlaps the maximum value, but not the minimum value.\n        // Need to create two entries, one on the greater side, and one back into the current node.\n        final double greaterMinimum = Math.nextUp(node.maximumValue);\n        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n        return addEdge(node, newEdge, minimumValue, node.maximumValue);\n      case LESS:\n        // The new edge is clearly less than the current node.\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43631d6552f924eb58c0b507e3e10215c53754f8","date":1461863675,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","sourceNew":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\"Creating new node \"+rval+\" for edge \"+newEdge+\" in tree \"+this);\n        return rval;\n      }\n      //System.err.println(\"Adding edge \"+newEdge+\" into node \"+node+\" in tree \"+this);\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n        // The node is contained in the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\" Inserting new node \"+rval+\" at head of current 'within' chain in tree \"+this);\n        rval.within = node;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        //System.err.println(\" Adding edge into 'within' chain in tree \"+this);\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        // The new edge overlaps the minimum value, but not the maximum value.\n        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n        //System.err.println(\" Inserting edge into BOTH lesser chain and within chain in tree \"+this);\n        final double lesserMaximum = Math.nextDown(node.minimumValue);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n        return addEdge(node, newEdge, node.minimumValue, maximumValue);\n      case OVERLAPS_MAXIMUM:\n        // The new edge overlaps the maximum value, but not the minimum value.\n        // Need to create two entries, one on the greater side, and one back into the current node.\n        //System.err.println(\" Inserting edge into BOTH greater chain and within chain in tree \"+this);\n        final double greaterMinimum = Math.nextUp(node.maximumValue);\n        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n        return addEdge(node, newEdge, minimumValue, node.maximumValue);\n      case LESS:\n        // The new edge is clearly less than the current node.\n        //System.err.println(\" Edge goes into the lesser chain in tree \"+this);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        //System.err.println(\" Edge goes into the greater chain in tree \"+this);\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","sourceOld":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        return new Node(newEdge, minimumValue, maximumValue);\n      }\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n        // The node is contained in the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        rval.within = node.within;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        // The new edge overlaps the minimum value, but not the maximum value.\n        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n        final double lesserMaximum = Math.nextDown(node.minimumValue);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n        return addEdge(node, newEdge, node.minimumValue, maximumValue);\n      case OVERLAPS_MAXIMUM:\n        // The new edge overlaps the maximum value, but not the minimum value.\n        // Need to create two entries, one on the greater side, and one back into the current node.\n        final double greaterMinimum = Math.nextUp(node.maximumValue);\n        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n        return addEdge(node, newEdge, minimumValue, node.maximumValue);\n      case LESS:\n        // The new edge is clearly less than the current node.\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","pathOld":"/dev/null","sourceNew":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\"Creating new node \"+rval+\" for edge \"+newEdge+\" in tree \"+this);\n        return rval;\n      }\n      //System.err.println(\"Adding edge \"+newEdge+\" into node \"+node+\" in tree \"+this);\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n        // The node is contained in the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\" Inserting new node \"+rval+\" at head of current 'within' chain in tree \"+this);\n        rval.within = node;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        //System.err.println(\" Adding edge into 'within' chain in tree \"+this);\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        // The new edge overlaps the minimum value, but not the maximum value.\n        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n        //System.err.println(\" Inserting edge into BOTH lesser chain and within chain in tree \"+this);\n        final double lesserMaximum = Math.nextDown(node.minimumValue);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n        return addEdge(node, newEdge, node.minimumValue, maximumValue);\n      case OVERLAPS_MAXIMUM:\n        // The new edge overlaps the maximum value, but not the minimum value.\n        // Need to create two entries, one on the greater side, and one back into the current node.\n        //System.err.println(\" Inserting edge into BOTH greater chain and within chain in tree \"+this);\n        final double greaterMinimum = Math.nextUp(node.maximumValue);\n        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n        return addEdge(node, newEdge, minimumValue, node.maximumValue);\n      case LESS:\n        // The new edge is clearly less than the current node.\n        //System.err.println(\" Edge goes into the lesser chain in tree \"+this);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        //System.err.println(\" Edge goes into the greater chain in tree \"+this);\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9167ab2d333bb6419d787660d5738852c9f1db60","date":1462255679,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","sourceNew":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\"Creating new node \"+rval+\" for edge \"+newEdge+\" in tree \"+this);\n        return rval;\n      }\n      //System.err.println(\"Adding edge \"+newEdge+\" into node \"+node+\" in tree \"+this);\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n       {\n          final double lesserMaximum = Math.nextDown(node.minimumValue);\n          final double greaterMinimum = Math.nextUp(node.maximumValue);\n          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n          return addEdge(node, newEdge, node.minimumValue, node.maximumValue);\n       }\n      case EXACT:\n        // The node is exactly equal to the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\" Inserting new node \"+rval+\" at head of current 'within' chain in tree \"+this);\n        rval.within = node;\n        rval.lesser = node.lesser;\n        rval.greater = node.greater;\n        node.lesser = null;\n        node.greater = null;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        //System.err.println(\" Adding edge into 'within' chain in tree \"+this);\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        {\n          // The new edge overlaps the minimum value, but not the maximum value.\n          // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n          //System.err.println(\" Inserting edge into BOTH lesser chain and within chain in tree \"+this);\n          final double lesserMaximum = Math.nextDown(node.minimumValue);\n          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n          return addEdge(node, newEdge, node.minimumValue, maximumValue);\n        }\n      case OVERLAPS_MAXIMUM:\n        {\n          // The new edge overlaps the maximum value, but not the minimum value.\n          // Need to create two entries, one on the greater side, and one back into the current node.\n          //System.err.println(\" Inserting edge into BOTH greater chain and within chain in tree \"+this);\n          final double greaterMinimum = Math.nextUp(node.maximumValue);\n          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n          return addEdge(node, newEdge, minimumValue, node.maximumValue);\n        }\n      case LESS:\n        // The new edge is clearly less than the current node.\n        //System.err.println(\" Edge goes into the lesser chain in tree \"+this);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        //System.err.println(\" Edge goes into the greater chain in tree \"+this);\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","sourceOld":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\"Creating new node \"+rval+\" for edge \"+newEdge+\" in tree \"+this);\n        return rval;\n      }\n      //System.err.println(\"Adding edge \"+newEdge+\" into node \"+node+\" in tree \"+this);\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n        // The node is contained in the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\" Inserting new node \"+rval+\" at head of current 'within' chain in tree \"+this);\n        rval.within = node;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        //System.err.println(\" Adding edge into 'within' chain in tree \"+this);\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        // The new edge overlaps the minimum value, but not the maximum value.\n        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n        //System.err.println(\" Inserting edge into BOTH lesser chain and within chain in tree \"+this);\n        final double lesserMaximum = Math.nextDown(node.minimumValue);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n        return addEdge(node, newEdge, node.minimumValue, maximumValue);\n      case OVERLAPS_MAXIMUM:\n        // The new edge overlaps the maximum value, but not the minimum value.\n        // Need to create two entries, one on the greater side, and one back into the current node.\n        //System.err.println(\" Inserting edge into BOTH greater chain and within chain in tree \"+this);\n        final double greaterMinimum = Math.nextUp(node.maximumValue);\n        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n        return addEdge(node, newEdge, minimumValue, node.maximumValue);\n      case LESS:\n        // The new edge is clearly less than the current node.\n        //System.err.println(\" Edge goes into the lesser chain in tree \"+this);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        //System.err.println(\" Edge goes into the greater chain in tree \"+this);\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"083674ea80108c4053d9526cdef6f77b2494e551","date":1462313169,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#addEdge(Node,Edge,double,double).mjava","sourceNew":null,"sourceOld":"    /** Worker method for adding an edge.\n     * @param node is the node to add into.\n     * @param newEdge is the new edge to add.\n     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.\n     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.\n     * @return the updated node reference.\n     */\n    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {\n      if (node == null) {\n        // Create and return a new node\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\"Creating new node \"+rval+\" for edge \"+newEdge+\" in tree \"+this);\n        return rval;\n      }\n      //System.err.println(\"Adding edge \"+newEdge+\" into node \"+node+\" in tree \"+this);\n      // Compare with what's here\n      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);\n      switch (result) {\n      case CONTAINED:\n       {\n          final double lesserMaximum = Math.nextDown(node.minimumValue);\n          final double greaterMinimum = Math.nextUp(node.maximumValue);\n          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n          return addEdge(node, newEdge, node.minimumValue, node.maximumValue);\n       }\n      case EXACT:\n        // The node is exactly equal to the range provided.  We need to create a new node and insert\n        // it into the \"within\" chain.\n        final Node rval = new Node(newEdge, minimumValue, maximumValue);\n        //System.err.println(\" Inserting new node \"+rval+\" at head of current 'within' chain in tree \"+this);\n        rval.within = node;\n        rval.lesser = node.lesser;\n        rval.greater = node.greater;\n        node.lesser = null;\n        node.greater = null;\n        return rval;\n      case WITHIN:\n        // The new edge is within the node provided\n        //System.err.println(\" Adding edge into 'within' chain in tree \"+this);\n        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);\n        return node;\n      case OVERLAPS_MINIMUM:\n        {\n          // The new edge overlaps the minimum value, but not the maximum value.\n          // Here we need to create TWO entries: one for the lesser side, and one for the within chain.\n          //System.err.println(\" Inserting edge into BOTH lesser chain and within chain in tree \"+this);\n          final double lesserMaximum = Math.nextDown(node.minimumValue);\n          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);\n          return addEdge(node, newEdge, node.minimumValue, maximumValue);\n        }\n      case OVERLAPS_MAXIMUM:\n        {\n          // The new edge overlaps the maximum value, but not the minimum value.\n          // Need to create two entries, one on the greater side, and one back into the current node.\n          //System.err.println(\" Inserting edge into BOTH greater chain and within chain in tree \"+this);\n          final double greaterMinimum = Math.nextUp(node.maximumValue);\n          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);\n          return addEdge(node, newEdge, minimumValue, node.maximumValue);\n        }\n      case LESS:\n        // The new edge is clearly less than the current node.\n        //System.err.println(\" Edge goes into the lesser chain in tree \"+this);\n        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);\n        return node;\n      case GREATER:\n        // The new edge is clearly greater than the current node.\n        //System.err.println(\" Edge goes into the greater chain in tree \"+this);\n        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);\n        return node;\n      default:\n        throw new RuntimeException(\"Unexpected comparison result: \"+result);\n      }\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"083674ea80108c4053d9526cdef6f77b2494e551":["9167ab2d333bb6419d787660d5738852c9f1db60"],"43631d6552f924eb58c0b507e3e10215c53754f8":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43631d6552f924eb58c0b507e3e10215c53754f8"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9167ab2d333bb6419d787660d5738852c9f1db60":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["083674ea80108c4053d9526cdef6f77b2494e551"]},"commit2Childs":{"083674ea80108c4053d9526cdef6f77b2494e551":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43631d6552f924eb58c0b507e3e10215c53754f8":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["9167ab2d333bb6419d787660d5738852c9f1db60"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["43631d6552f924eb58c0b507e3e10215c53754f8"],"9167ab2d333bb6419d787660d5738852c9f1db60":["083674ea80108c4053d9526cdef6f77b2494e551"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}