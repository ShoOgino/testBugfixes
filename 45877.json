{"path":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","commits":[{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","sourceOld":"  private void handleKeyRequest(String[] keys, SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    rsp.getValues().add(\"metrics\", result);\n    if (errors.size() > 0) {\n      rsp.getValues().add(\"errors\", errors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"033183e9e2da4609614733f0226a38c88c49ed36","date":1557334549,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","sourceNew":"  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      if (injectedSysProps != null\n          && SolrMetricManager.JVM_REGISTRY.equals(registryName)\n          && \"system.properties\".equals(metricName) && injectedSysProps.containsKey(propertyName)) {\n        result.add(registryName+\":\"+metricName+\":\"+propertyName, injectedSysProps.get(propertyName));\n        continue;\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","sourceOld":"  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      if (injectedSysProps != null\n          && SolrMetricManager.JVM_REGISTRY.equals(registryName)\n          && \"system.properties\".equals(metricName) && injectedSysProps.containsKey(propertyName)) {\n        result.add(registryName+\":\"+metricName+\":\"+propertyName, injectedSysProps.get(propertyName));\n        continue;\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","sourceOld":"  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      if (injectedSysProps != null\n          && SolrMetricManager.JVM_REGISTRY.equals(registryName)\n          && \"system.properties\".equals(metricName) && injectedSysProps.containsKey(propertyName)) {\n        result.add(registryName+\":\"+metricName+\":\"+propertyName, injectedSysProps.get(propertyName));\n        continue;\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"233211c3dbff6f367588be5bbb4ac77f72eae193","date":1602085975,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHandler#handleKeyRequest(String[],BiConsumer[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap<Object> result = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> errors = new SimpleOrderedMap<>();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      Predicate<CharSequence> propertyFilter = MetricUtils.ALL_PROPERTIES;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      if (injectedSysProps != null\n          && SolrMetricManager.JVM_REGISTRY.equals(registryName)\n          && \"system.properties\".equals(metricName) && injectedSysProps.containsKey(propertyName)) {\n        result.add(registryName+\":\"+metricName+\":\"+propertyName, injectedSysProps.get(propertyName));\n        continue;\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else if ((v instanceof MapWriter) && propertyName != null) {\n          ((MapWriter) v)._forEachEntry((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {\n    SimpleOrderedMap result = new SimpleOrderedMap();\n    SimpleOrderedMap errors = new SimpleOrderedMap();\n    for (String key : keys) {\n      if (key == null || key.isEmpty()) {\n        continue;\n      }\n      String[] parts = KEY_REGEX.split(key);\n      if (parts.length < 2 || parts.length > 3) {\n        errors.add(key, \"at least two and at most three colon-separated parts must be provided\");\n        continue;\n      }\n      final String registryName = unescape(parts[0]);\n      final String metricName = unescape(parts[1]);\n      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;\n      if (!metricManager.hasRegistry(registryName)) {\n        errors.add(key, \"registry '\" + registryName + \"' not found\");\n        continue;\n      }\n      MetricRegistry registry = metricManager.registry(registryName);\n      Metric m = registry.getMetrics().get(metricName);\n      if (m == null) {\n        errors.add(key, \"metric '\" + metricName + \"' not found\");\n        continue;\n      }\n      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;\n      if (propertyName != null) {\n        propertyFilter = (name) -> name.equals(propertyName);\n        // use escaped versions\n        key = parts[0] + \":\" + parts[1];\n      }\n      if (injectedSysProps != null\n          && SolrMetricManager.JVM_REGISTRY.equals(registryName)\n          && \"system.properties\".equals(metricName) && injectedSysProps.containsKey(propertyName)) {\n        result.add(registryName+\":\"+metricName+\":\"+propertyName, injectedSysProps.get(propertyName));\n        continue;\n      }\n      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, \":\", (k, v) -> {\n        if ((v instanceof Map) && propertyName != null) {\n          ((Map)v).forEach((k1, v1) -> result.add(k + \":\" + k1, v1));\n        } else {\n          result.add(k, v);\n        }\n      });\n    }\n    consumer.accept(\"metrics\", result);\n    if (errors.size() > 0) {\n      consumer.accept(\"errors\", errors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba055e19afc289adcb5bedaf68513793a7254012":["033183e9e2da4609614733f0226a38c88c49ed36"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"233211c3dbff6f367588be5bbb4ac77f72eae193":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["233211c3dbff6f367588be5bbb4ac77f72eae193"],"033183e9e2da4609614733f0226a38c88c49ed36":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"]},"commit2Childs":{"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["033183e9e2da4609614733f0226a38c88c49ed36"],"ba055e19afc289adcb5bedaf68513793a7254012":["233211c3dbff6f367588be5bbb4ac77f72eae193"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"233211c3dbff6f367588be5bbb4ac77f72eae193":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"033183e9e2da4609614733f0226a38c88c49ed36":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}