{"path":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","commits":[{"id":"e4fccad460342b1af30cb328cc8297751a218d78","date":1541177339,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Polygon2D.Edge#crossesTriangle(double,double,double,double,double,double).mjava","sourceNew":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (outside == false) {\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {\n            return true;\n          }\n        }\n\n        if (left != null) {\n          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n","sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (outside == false) {\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if (orient(dx, dy, ex, ey, ax, ay) * orient(dx, dy, ex, ey, bx, by) <= 0 &&\n              orient(ax, ay, bx, by, dx, dy) * orient(ax, ay, bx, by, ex, ey) <= 0) {\n            return true;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if (orient(dx, dy, ex, ey, bx, by) * orient(dx, dy, ex, ey, cx, cy) <= 0 &&\n              orient(bx, by, cx, cy, dx, dy) * orient(bx, by, cx, cy, ex, ey) <= 0) {\n            return true;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if (orient(dx, dy, ex, ey, cx, cy) * orient(dx, dy, ex, ey, ax, ay) <= 0 &&\n              orient(cx, cy, ax, ay, dx, dy) * orient(cx, cy, ax, ay, ex, ey) <= 0) {\n            return true;\n          }\n        }\n\n        if (left != null) {\n          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5ee4d410ec4b99dc713f05e20a22e802b89a92f","date":1548973182,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#relateTriangle(double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","sourceNew":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    Relation relateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      Relation r = Relation.CELL_OUTSIDE_QUERY;\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (outside == false) {\n          int insideEdges = 0;\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if ((r = lineRelateLine(ax, ay, bx, by, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if ((r = lineRelateLine(bx, by, cx, cy, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if ((r = lineRelateLine(cx, cy, ax, ay, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n          if (insideEdges == 3) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n\n        if (left != null) {\n          if ((r = left.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {\n            return r;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if ((r = right.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {\n            return r;\n          }\n        }\n      }\n      return r;\n    }\n\n","sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (outside == false) {\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {\n            return true;\n          }\n        }\n\n        if (left != null) {\n          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dffcd36f1a87df1300807d9580eb05aa37726397","date":1552376454,"type":1,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#relateTriangle(double,double,double,double,double,double).mjava","sourceNew":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (dateline == false && outside == false) {\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {\n            return true;\n          }\n        }\n\n        if (left != null) {\n          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n","sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    Relation relateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      Relation r = Relation.CELL_OUTSIDE_QUERY;\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (outside == false) {\n          int insideEdges = 0;\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if ((r = lineRelateLine(ax, ay, bx, by, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if ((r = lineRelateLine(bx, by, cx, cy, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if ((r = lineRelateLine(cx, cy, ax, ay, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {\n            return r;\n          } else if (r == Relation.CELL_INSIDE_QUERY) {\n            ++insideEdges;\n          }\n          if (insideEdges == 3) {\n            // fully inside, we can return\n            return Relation.CELL_INSIDE_QUERY;\n          } else {\n            //reset relation to not crossing\n            r =  Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n\n        if (left != null) {\n          if ((r = left.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {\n            return r;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if ((r = right.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {\n            return r;\n          }\n        }\n      }\n      return r;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc005279ab64cbf458ccef2ada610bc1a04b6139","date":1554992856,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","sourceNew":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute min lat of triangle bounding box\n      double triMinLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      if (triMinLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // compute remaining bounding box of triangle\n        double triMinLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n        double triMaxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n        double triMaxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < triMinLat && ey < triMinLat) ||\n            (dy > triMaxLat && ey > triMaxLat) ||\n            (dx < triMinLon && ex < triMinLon) ||\n            (dx > triMaxLon && ex > triMaxLon);\n\n        if (outside == false) {\n          if (lineCrossesLine(dx, dy, ex, ey, ax, ay, bx, by) ||\n              lineCrossesLine(dx, dy, ex, ey, bx, by, cx, cy) ||\n              lineCrossesLine(dx, dy, ex, ey, cx, cy, ax, ay)) {\n            return true;\n          }\n        }\n\n        if (left != null && left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n\n        if (right != null && triMaxLat >= low && right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n","sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute bounding box of triangle\n      double minLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n      double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n      double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n      if (minLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minLat && ey < minLat) ||\n            (dy > maxLat && ey > maxLat) ||\n            (dx < minLon && ex < minLon) ||\n            (dx > maxLon && ex > maxLon);\n\n        if (dateline == false && outside == false) {\n          // does triangle's first edge intersect polyline?\n          // ax, ay -> bx, by\n          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's second edge intersect polyline?\n          // bx, by -> cx, cy\n          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {\n            return true;\n          }\n\n          // does triangle's third edge intersect polyline?\n          // cx, cy -> ax, ay\n          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {\n            return true;\n          }\n        }\n\n        if (left != null) {\n          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n\n        if (right != null && maxLat >= low) {\n          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","date":1571074565,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree#crossesTriangle(double,double,double,double,double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","sourceNew":"  /** Returns true if the triangle crosses any edge in this edge subtree */\n  protected boolean crossesTriangle(double minX, double maxX, double minY, double maxY,\n                          double ax, double ay, double bx, double by, double cx, double cy) {\n      if (minY <= max) {\n        double dy = y1;\n        double ey = y2;\n        double dx = x1;\n        double ex = x2;\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < minY && ey < minY) ||\n            (dy > maxY && ey > maxY) ||\n            (dx < minX && ex < minX) ||\n            (dx > maxX && ex > maxX);\n\n        if (outside == false) {\n          if (lineCrossesLine(dx, dy, ex, ey, ax, ay, bx, by) ||\n              lineCrossesLine(dx, dy, ex, ey, bx, by, cx, cy) ||\n              lineCrossesLine(dx, dy, ex, ey, cx, cy, ax, ay)) {\n            return true;\n          }\n        }\n\n        if (left != null && left.crossesTriangle(minX, maxX, minY, maxY, ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n\n        if (right != null && maxY >= low && right.crossesTriangle(minX, maxX, minY, maxY, ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n","sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute min lat of triangle bounding box\n      double triMinLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      if (triMinLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // compute remaining bounding box of triangle\n        double triMinLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n        double triMaxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n        double triMaxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < triMinLat && ey < triMinLat) ||\n            (dy > triMaxLat && ey > triMaxLat) ||\n            (dx < triMinLon && ex < triMinLon) ||\n            (dx > triMaxLon && ex > triMaxLon);\n\n        if (outside == false) {\n          if (lineCrossesLine(dx, dy, ex, ey, ax, ay, bx, by) ||\n              lineCrossesLine(dx, dy, ex, ey, bx, by, cx, cy) ||\n              lineCrossesLine(dx, dy, ex, ey, cx, cy, ax, ay)) {\n            return true;\n          }\n        }\n\n        if (left != null && left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n\n        if (right != null && triMaxLat >= low && right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":4,"author":"jimczi","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree.Edge#crossesTriangle(double,double,double,double,double,double).mjava","sourceNew":null,"sourceOld":"    /** Returns true if the triangle crosses any edge in this edge subtree */\n    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {\n      // compute min lat of triangle bounding box\n      double triMinLat = StrictMath.min(StrictMath.min(ay, by), cy);\n      if (triMinLat <= max) {\n        double dy = lat1;\n        double ey = lat2;\n        double dx = lon1;\n        double ex = lon2;\n\n        // compute remaining bounding box of triangle\n        double triMinLon = StrictMath.min(StrictMath.min(ax, bx), cx);\n        double triMaxLat = StrictMath.max(StrictMath.max(ay, by), cy);\n        double triMaxLon = StrictMath.max(StrictMath.max(ax, bx), cx);\n\n        // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n        // if not, don't waste our time trying more complicated stuff\n        boolean outside = (dy < triMinLat && ey < triMinLat) ||\n            (dy > triMaxLat && ey > triMaxLat) ||\n            (dx < triMinLon && ex < triMinLon) ||\n            (dx > triMaxLon && ex > triMaxLon);\n\n        if (outside == false) {\n          if (lineCrossesLine(dx, dy, ex, ey, ax, ay, bx, by) ||\n              lineCrossesLine(dx, dy, ex, ey, bx, by, cx, cy) ||\n              lineCrossesLine(dx, dy, ex, ey, cx, cy, ax, ay)) {\n            return true;\n          }\n        }\n\n        if (left != null && left.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n\n        if (right != null && triMaxLat >= low && right.crossesTriangle(ax, ay, bx, by, cx, cy)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["fc005279ab64cbf458ccef2ada610bc1a04b6139"],"dffcd36f1a87df1300807d9580eb05aa37726397":["a5ee4d410ec4b99dc713f05e20a22e802b89a92f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e4fccad460342b1af30cb328cc8297751a218d78":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fc005279ab64cbf458ccef2ada610bc1a04b6139":["dffcd36f1a87df1300807d9580eb05aa37726397"],"a5ee4d410ec4b99dc713f05e20a22e802b89a92f":["e4fccad460342b1af30cb328cc8297751a218d78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fc005279ab64cbf458ccef2ada610bc1a04b6139","b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"]},"commit2Childs":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"dffcd36f1a87df1300807d9580eb05aa37726397":["fc005279ab64cbf458ccef2ada610bc1a04b6139"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e4fccad460342b1af30cb328cc8297751a218d78"],"e4fccad460342b1af30cb328cc8297751a218d78":["a5ee4d410ec4b99dc713f05e20a22e802b89a92f"],"fc005279ab64cbf458ccef2ada610bc1a04b6139":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","b0b597c65628ca9e73913a07e81691f8229bae35"],"a5ee4d410ec4b99dc713f05e20a22e802b89a92f":["dffcd36f1a87df1300807d9580eb05aa37726397"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}