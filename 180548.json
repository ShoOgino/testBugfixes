{"path":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91734704545771bc67b698ec3f02114473413958","date":1325238045,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6e3376a314fcc2b31bc46d399c2ff23552b78d6","date":1325780477,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91734704545771bc67b698ec3f02114473413958":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["91734704545771bc67b698ec3f02114473413958"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"91734704545771bc67b698ec3f02114473413958":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["91734704545771bc67b698ec3f02114473413958"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}