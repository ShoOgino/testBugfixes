{"path":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","commits":[{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    inputFactory = XMLInputFactory.newInstance();\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    }\n    catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    inputFactory.setXMLReporter(xmllog);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5d511528a3d157ee978d8854e33ff698571cb22","date":1348740642,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    inputFactory = XMLInputFactory.newInstance();\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    }\n    catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    inputFactory.setXMLReporter(xmllog);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a37199bd55514578124567c8e305e61d305c46d","date":1363609732,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // nocommit: still true in 1.7?\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaad731398623a50d93e77042f2a0dabe29815db","date":1363612044,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // nocommit: still true in 1.7?\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#init(SolrParams).mjava","sourceNew":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: {}\", inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds={}\", xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.debug(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aaad731398623a50d93e77042f2a0dabe29815db":["0a37199bd55514578124567c8e305e61d305c46d"],"126d6ad24eed13163ba0959435d5a80e5672837c":["aaad731398623a50d93e77042f2a0dabe29815db","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"0a37199bd55514578124567c8e305e61d305c46d":["b5d511528a3d157ee978d8854e33ff698571cb22"],"042e4d934397657ba04c82b46cc5665076bc5c58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["aaad731398623a50d93e77042f2a0dabe29815db","126d6ad24eed13163ba0959435d5a80e5672837c"],"575e66bd4b2349209027f6801184da7fc3cba13f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b5d511528a3d157ee978d8854e33ff698571cb22":["042e4d934397657ba04c82b46cc5665076bc5c58"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["aaad731398623a50d93e77042f2a0dabe29815db"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["aaad731398623a50d93e77042f2a0dabe29815db","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"aaad731398623a50d93e77042f2a0dabe29815db":["126d6ad24eed13163ba0959435d5a80e5672837c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","7f0c8426396c925de8db3ed3f8ff40fd73670a5c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"126d6ad24eed13163ba0959435d5a80e5672837c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0a37199bd55514578124567c8e305e61d305c46d":["aaad731398623a50d93e77042f2a0dabe29815db"],"042e4d934397657ba04c82b46cc5665076bc5c58":["b5d511528a3d157ee978d8854e33ff698571cb22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042e4d934397657ba04c82b46cc5665076bc5c58"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["575e66bd4b2349209027f6801184da7fc3cba13f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b5d511528a3d157ee978d8854e33ff698571cb22":["0a37199bd55514578124567c8e305e61d305c46d"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}