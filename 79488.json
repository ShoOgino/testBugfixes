{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","commits":[{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.getCollectionStates().containsKey(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String sourceLeaderUrl = zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName());\n    if (sourceLeaderUrl.startsWith(\"http://\")) sourceLeaderUrl = sourceLeaderUrl.substring(7);\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6b2d5e51d862b5b78848bd345017e21796ced620","4d261656348f8dccddcd7f3c362e66111af53d44","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1dca57049fb75fd60d90723d142769094a0402be","date":1385096736,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.getCollectionStates().containsKey(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.getCollectionStates().containsKey(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String sourceLeaderUrl = zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName());\n    if (sourceLeaderUrl.startsWith(\"http://\")) sourceLeaderUrl = sourceLeaderUrl.substring(7);\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["4ddb837927b3de29503b68a05fec256665edab50","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cdc8313ba7bdaaa48ff54059d0eabff4436ab175","date":1386102048,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.getCollectionStates().containsKey(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ef0a91e147ef5c263ff965642f847b554b13ba2","date":1386676110,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.getCollectionStates().containsKey(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", splitKey,\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(splitKey);\n        if (rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String sourceLeaderUrl = zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName());\n    if (sourceLeaderUrl.startsWith(\"http://\")) sourceLeaderUrl = sourceLeaderUrl.substring(7);\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d261656348f8dccddcd7f3c362e66111af53d44","date":1388756351,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = clusterState.getLeader(tempSourceCollectionName, tempSourceSlice.getName());\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":["da888af1ab894358122a22229051215f58cf4d54"],"bugIntro":["6b2d5e51d862b5b78848bd345017e21796ced620"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b2d5e51d862b5b78848bd345017e21796ced620","date":1391975998,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":["da888af1ab894358122a22229051215f58cf4d54","4d261656348f8dccddcd7f3c362e66111af53d44"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getZkClient().getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["cc9dd0d6ff8e58a4ce40ba13d20664a95589de3d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b","date":1392108367,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a","date":1392108948,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8497bb4f9de61b5520423bd9af88ea11a6e109e7","date":1393245090,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6225820ca5f401e2fe460f36e4a919a384cef6c","date":1393272577,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = targetSlice.getLeader();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = sourceSlice.getLeader();\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 60000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        // TODO: look at using nanoTime here?\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean added = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.currentTimeMillis() + 60000;\n    boolean added = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":5,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    HashMap<String, String> requestMap = new HashMap<String, String>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    String nodeName = targetLeader.getNodeName();\n    setupAsyncRequest(asyncId, requestMap, params, nodeName);\n\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    completeAsyncRequest(asyncId, requestMap, results);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        // TODO: look at using nanoTime here?\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean added = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    if(asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    setupAsyncRequest(asyncId, requestMap, params, tempNodeName);\n\n    sendShardRequest(tempNodeName, params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    completeAsyncRequest(asyncId, requestMap, results);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n\n    setupAsyncRequest(asyncId, requestMap, params, targetLeader.getNodeName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create replica of temporary collection in target leader node.\");\n\n    completeAsyncRequest(asyncId, requestMap, results);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    setupAsyncRequest(asyncId, requestMap, params, tempSourceLeader.getNodeName());\n\n    sendShardRequest(tempSourceLeader.getNodeName(), params);\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    completeAsyncRequest(asyncId, requestMap, results);\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    setupAsyncRequest(asyncId, requestMap, params, sourceLeader.getNodeName());\n\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    completeAsyncRequest(asyncId, requestMap, results);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    setupAsyncRequest(asyncId, requestMap, params, targetLeader.getNodeName());\n\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    completeAsyncRequest(asyncId, requestMap, results);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice, DocCollection targetCollection, Slice targetSlice, String splitKey, int timeout, NamedList results) throws KeeperException, InterruptedException {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      try {\n        deleteCollection(new ZkNodeProps(props), results);\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to request node to buffer updates\");\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        // TODO: look at using nanoTime here?\n        \"expireAt\", String.valueOf(System.currentTimeMillis() + timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean added = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      Map<String, RoutingRule> rules = zkStateReader.getClusterState().getSlice(sourceCollection.getName(), sourceSlice.getName()).getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = ZkNodeProps.makeMap(\n        QUEUE_OPERATION, CREATECOLLECTION,\n        \"name\", tempSourceCollectionName,\n        REPLICATION_FACTOR, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    log.info(\"Creating temporary collection: \" + props);\n    createCollection(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica1\";\n    String coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(sourceLeader.getNodeName()), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection leader or timed out waiting for it to come up\");\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    sendShardRequest(sourceLeader.getNodeName(), params);\n    collectShardResponses(results, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    String tempCollectionReplica2 = tempSourceCollectionName + \"_\" + tempSourceSlice.getName() + \"_replica2\";\n    params.set(CoreAdminParams.NAME, tempCollectionReplica2);\n    params.set(CoreAdminParams.COLLECTION, tempSourceCollectionName);\n    params.set(CoreAdminParams.SHARD, tempSourceSlice.getName());\n    sendShardRequest(targetLeader.getNodeName(), params);\n\n    coreNodeName = waitForCoreNodeName(clusterState.getCollection(tempSourceCollectionName),\n        zkStateReader.getBaseUrlForNodeName(targetLeader.getNodeName()), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(ZkStateReader.ACTIVE); // todo introduce asynchronous actions\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()));\n\n    collectShardResponses(results, true,\n        \"MIGRATE failed to create temp collection replica or timed out waiting for them to come up\");\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \" + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName());\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n    sendShardRequest(targetLeader.getNodeName(), params);\n    collectShardResponses(results, true,\n        \"MIGRATE failed to request node to apply buffered updates\");\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = ZkNodeProps.makeMap(\n          QUEUE_OPERATION, DELETECOLLECTION,\n          \"name\", tempSourceCollectionName);\n      deleteCollection(new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","ee31282189f924712ed9ad83e3073e0c207a1a53"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4d261656348f8dccddcd7f3c362e66111af53d44":["5ef0a91e147ef5c263ff965642f847b554b13ba2"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a":["6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b"],"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["cdc8313ba7bdaaa48ff54059d0eabff4436ab175"],"da888af1ab894358122a22229051215f58cf4d54":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6b2d5e51d862b5b78848bd345017e21796ced620":["4d261656348f8dccddcd7f3c362e66111af53d44"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["6b2d5e51d862b5b78848bd345017e21796ced620"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1dca57049fb75fd60d90723d142769094a0402be":["da888af1ab894358122a22229051215f58cf4d54"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","5ef0a91e147ef5c263ff965642f847b554b13ba2"],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["afd709fe548f0ddbaa0a678015e7c3d41ff1c87a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"cdc8313ba7bdaaa48ff54059d0eabff4436ab175":["1dca57049fb75fd60d90723d142769094a0402be"]},"commit2Childs":{"4d261656348f8dccddcd7f3c362e66111af53d44":["6b2d5e51d862b5b78848bd345017e21796ced620"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b":["afd709fe548f0ddbaa0a678015e7c3d41ff1c87a"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["4d261656348f8dccddcd7f3c362e66111af53d44","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"da888af1ab894358122a22229051215f58cf4d54":["1dca57049fb75fd60d90723d142769094a0402be","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"6b2d5e51d862b5b78848bd345017e21796ced620":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["da888af1ab894358122a22229051215f58cf4d54"],"1dca57049fb75fd60d90723d142769094a0402be":["cdc8313ba7bdaaa48ff54059d0eabff4436ab175"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"cdc8313ba7bdaaa48ff54059d0eabff4436ab175":["5ef0a91e147ef5c263ff965642f847b554b13ba2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}