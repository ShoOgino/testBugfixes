{"path":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","commits":[{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final AtomicReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term, boolean cache)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final AtomicReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes, cache)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":1,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final AtomicReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term, boolean cache)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final AtomicReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes, cache)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final AtomicReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator(null);\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Fields fields = ctx.reader().fields();\n      if (fields != null) {\n        final Terms terms = fields.terms(field);\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(bytes)) { \n            final TermState termState = termsEnum.termState();\n            //if (DEBUG) System.out.println(\"    found\");\n            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n          }\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":["60ba444201d2570214b6fcf1d15600dc1a01f548","e2297162a22c55456e200caef2cbcb00fe381120","fa1a999d6674423e5c4ac858b410283f6fe03f20","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator(null);\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermStates#build(IndexReaderContext,Term,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":"  /**\n   * Creates a {@link TermStates} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermStates}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   *\n   * @param needsStats if {@code true} then all leaf contexts will be visited up-front to\n   *                   collect term statistics.  Otherwise, the {@link TermState} objects\n   *                   will be built only when requested\n   */\n  public static TermStates build(IndexReaderContext context, Term term, boolean needsStats)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final TermStates perReaderTermState = new TermStates(needsStats ? null : term, context);\n    if (needsStats) {\n      for (final LeafReaderContext ctx : context.leaves()) {\n        //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n        TermsEnum termsEnum = loadTermsEnum(ctx, term);\n        if (termsEnum != null) {\n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"b94236357aaa22b76c10629851fe4e376e0cea82":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","a6e9f769521480a623f897c0d59089b919fa4239"],"a6e9f769521480a623f897c0d59089b919fa4239":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}