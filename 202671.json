{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!new CategoryPath(me, me.length()-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!new CategoryPath(me, me.length()-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!new CategoryPath(me, me.length()-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!new CategoryPath(me, me.length()-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29e1a91414f603bce5a59a5cb61fa8603997de87","date":1363597288,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(0));\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = tr.getParent(ordinal);\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    // check parent of of invalid ordinals:\n    try {\n      tr.getParent(-1);\n      fail(\"getParent for -1 should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      tr.getParent(TaxonomyReader.INVALID_ORDINAL);\n      fail(\"getParent for INVALID_ORDINAL should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    try {\n      int parent = tr.getParent(tr.getSize());\n      fail(\"getParent for getSize() should throw exception, but returned \"+parent);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      FacetLabel me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      FacetLabel parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      FacetLabel me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      FacetLabel parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      CategoryPath me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      CategoryPath parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderParent().mjava","sourceNew":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal &lt;=&gt; category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      FacetLabel me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      FacetLabel parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Tests for TaxonomyReader's getParent() method.\n    We check it by comparing its results to those we could have gotten by\n    looking at the category string paths (where the parentage is obvious).\n    Note that after testReaderBasic(), we already know we can trust the\n    ordinal <=> category conversions.\n    \n    Note: At the moment, the parent methods in the reader are deprecated,\n    but this does not mean they should not be tested! Until they are\n    removed (*if* they are removed), these tests should remain to see\n    that they still work correctly.\n   */\n\n  @Test\n  public void testReaderParent() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // check that the parent of the root ordinal is the invalid ordinal:\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[0]);\n\n    // check parent of non-root ordinals:\n    for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {\n      FacetLabel me = tr.getPath(ordinal);\n      int parentOrdinal = parents[ordinal];\n      FacetLabel parent = tr.getPath(parentOrdinal);\n      if (parent==null) {\n        fail(\"Parent of \"+ordinal+\" is \"+parentOrdinal+\n        \", but this is not a valid category.\");\n      }\n      // verify that the parent is indeed my parent, according to the strings\n      if (!me.subpath(me.length-1).equals(parent)) {\n        fail(\"Got parent \"+parentOrdinal+\" for ordinal \"+ordinal+\n            \" but categories are \"+showcat(parent)+\" and \"+showcat(me)+\n            \" respectively.\");\n      }\n    }\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"29e1a91414f603bce5a59a5cb61fa8603997de87":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["29e1a91414f603bce5a59a5cb61fa8603997de87","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["29e1a91414f603bce5a59a5cb61fa8603997de87"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","29e1a91414f603bce5a59a5cb61fa8603997de87"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"29e1a91414f603bce5a59a5cb61fa8603997de87":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}