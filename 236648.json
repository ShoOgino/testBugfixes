{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/SocketProxy.Bridge.Pump#run().mjava","commits":[{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":1,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on {} due to: \", src, e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on {} due to \",src, e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(\"Error when reading from {}\", src, ste);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from: {}\", src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"read/write failed, reason: {}\", e.getLocalizedMessage());\n          }\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(\"Error when closing InputStream on socket: {}\", src, exc);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(\"{} when closing OutputStream on socket: {}\", exc, destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"]},"commit2Childs":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}