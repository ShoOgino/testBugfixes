{"path":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","commits":[{"id":"2b2e7536fb06d1abad6c7543a0657bdad5242c5e","date":1341417762,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<Integer, DocInfo>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);  // real-time get isn't currently supported with delete-by-query\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n        // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(75));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            writePermission.acquire();\n\n            int oper = rand.nextInt(10);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                  version = snapshotCount++;\n                }\n\n                synchronized (stateChangeLock) {\n                  // These commits won't take affect if we are in recovery mode,\n                  // so change the version to -1 so we won't update our model.\n                  if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  // install this model snapshot only if it's newer than the current one\n                  // install this model only if we are not in recovery mode.\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id;\n\n            if (rand.nextBoolean()) {\n              id = rand.nextInt(ndocs);\n            } else {\n              id = lastId;  // reuse the last ID half of the time to force more race conditions\n            }\n\n            // set the lastId before we actually change it sometimes to try and\n            // uncover more race conditions between writing and reading\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            DocInfo info = model.get(id);\n\n            long val = info.val;\n            long nextVal = Math.abs(val)+1;\n\n            // the version we set on the update should determine who wins\n            // These versions are not derived from the actual leader update handler hand hence this\n            // test may need to change depending on how we handle version numbers.\n            long version = testVersion.incrementAndGet();\n\n            // yield after getting the next version to increase the odds of updates happening out of order\n            if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n            // }   // end sync\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n            \n            \n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<Integer, DocInfo>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"/dev/null","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<Integer, DocInfo>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<Integer, DocInfo>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6554f36a4636755009195a7840518bf6b4f03d6c","date":1481906808,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5de502b5478255493125e7e801411ba17a6682ec","date":1490974101,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f20fd35e3055a0c5b387df0b986a68d65d86441","date":1491045405,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bab9eeea60eefbea2957be27b8d1923095df771","date":1525498218,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1c374690db69470f6aa4bffc43dcacf1f4e3e49","date":1529007399,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","2b2e7536fb06d1abad6c7543a0657bdad5242c5e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  // 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n// 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3714bcf66a68a1600e9dd11442fc1b33b62ef088","date":1556832005,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  // 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  // 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressRecovery#testStressRecovery().mjava","sourceNew":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  // 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              @SuppressWarnings({\"rawtypes\"})\n              Map rsp = (Map) Utils.fromJSONString(response);\n              @SuppressWarnings({\"rawtypes\"})\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates updates coming from the leader and sometimes being reordered\n  // and tests the ability to buffer updates and apply them later\n  @Test\n  // 12-Jun-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  // fewer write threads to give recovery thread more of a chance\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  // number of recovery loops to perform\n    int nReadThreads = 2 + random().nextInt(10);  // fewer read threads to give writers more of a chance\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    // These commits won't take affect if we are in recovery mode,\n                    // so change the version to -1 so we won't update our model.\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    // install this model snapshot only if it's newer than the current one\n                    // install this model only if we are not in recovery mode.\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                // TODO: returning versions for these types of updates is redundant\n                // but if we do return, they had better be equal\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              // throttle reads (don't completely stop)\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              // TODO: some sort of validation that the latest version is >= to the latest version we added?\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      // before we start buffering updates, we want to point\n      // visibleModel away from the live model.\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      // sometimes wait for a second to allow time for writers to write something\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            // wait a short period of time for recovery to complete (and to give a chance for more writers to concurrently add docs)\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            // idle one more write thread\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              // if we hit the end, back up and give a few write permits\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            // throttle readers so they don't steal too much CPU from the recovery thread\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      // put all writers back at full blast\n      for (Semaphore writePerm : writePermissions) {\n        // I don't think semaphores check for overflow, so we need to check mow many remain\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      // put back readers at full blast and point back to live model\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2b2e7536fb06d1abad6c7543a0657bdad5242c5e"],"5de502b5478255493125e7e801411ba17a6682ec":["6554f36a4636755009195a7840518bf6b4f03d6c"],"6554f36a4636755009195a7840518bf6b4f03d6c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":["6554f36a4636755009195a7840518bf6b4f03d6c"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"e98520789adb1d5ad05afb4956eca0944a929688":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["4bab9eeea60eefbea2957be27b8d1923095df771","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6554f36a4636755009195a7840518bf6b4f03d6c"],"4bab9eeea60eefbea2957be27b8d1923095df771":["5de502b5478255493125e7e801411ba17a6682ec"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b2e7536fb06d1abad6c7543a0657bdad5242c5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"2b2e7536fb06d1abad6c7543a0657bdad5242c5e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["4bab9eeea60eefbea2957be27b8d1923095df771"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["4bab9eeea60eefbea2957be27b8d1923095df771","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6554f36a4636755009195a7840518bf6b4f03d6c","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"5de502b5478255493125e7e801411ba17a6682ec":["4bab9eeea60eefbea2957be27b8d1923095df771"],"6554f36a4636755009195a7840518bf6b4f03d6c":["5de502b5478255493125e7e801411ba17a6682ec","6f20fd35e3055a0c5b387df0b986a68d65d86441","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":[],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["e98520789adb1d5ad05afb4956eca0944a929688"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"4bab9eeea60eefbea2957be27b8d1923095df771":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a1c374690db69470f6aa4bffc43dcacf1f4e3e49","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fe33227f6805edab2036cbb80645cc4e2d1fa424","2b2e7536fb06d1abad6c7543a0657bdad5242c5e"],"2b2e7536fb06d1abad6c7543a0657bdad5242c5e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["6f20fd35e3055a0c5b387df0b986a68d65d86441","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}