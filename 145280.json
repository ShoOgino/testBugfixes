{"path":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","commits":[{"id":"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","date":1509089658,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e664487f12f836ec07e7c44c5ddc682388a15cf","date":1521303713,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n    \n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n    \n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ecd141e96e7a7a65822d7fada5ddc585b21149","date":1534786652,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n    \n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n\n    if (schemaField.getType().getNumberType() == null) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n            schemaField.getName(), schemaField);\n      }\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeNumberFromDV(SchemaField,long,boolean).mjava","sourceNew":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n\n    if (schemaField.getType().getNumberType() == null) {\n      log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n          schemaField.getName(), schemaField);\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private Object decodeNumberFromDV(SchemaField schemaField, long value, boolean sortableNumeric) {\n    // note: This special-case is unfortunate; if we have to add any more than perhaps the fieldType should\n    //  have this method so that specific field types can customize it.\n    if (schemaField.getType() instanceof LatLonPointSpatialField) {\n      return LatLonPointSpatialField.decodeDocValueToString(value);\n    }\n\n    if (schemaField.getType().getNumberType() == null) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Couldn't decode docValues for field: [{}], schemaField: [{}], numberType is unknown\",\n            schemaField.getName(), schemaField);\n      }\n      return null;\n    }\n\n    switch (schemaField.getType().getNumberType()) {\n      case INTEGER:\n        final int raw = (int)value;\n        if (schemaField.getType() instanceof AbstractEnumField) {\n          return ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw);\n        } else {\n          return raw;\n        }\n      case LONG:\n        return value;\n      case FLOAT:\n        if (sortableNumeric) {\n          return NumericUtils.sortableIntToFloat((int)value);\n        } else {\n          return Float.intBitsToFloat((int)value);\n        }\n      case DOUBLE:\n        if (sortableNumeric) {\n          return NumericUtils.sortableLongToDouble(value);\n        } else {\n          return Double.longBitsToDouble(value);\n        }\n      case DATE:\n        return new Date(value);\n      default:\n        // catched all possible values, this line will never be reached\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"575e66bd4b2349209027f6801184da7fc3cba13f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["203e3fcf513c02ee2c07015f2ce277e26dc60907","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}