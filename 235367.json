{"path":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","commits":[{"id":"d7052f725a053aa55424f966831826f61b798bf1","date":1158258681,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n\n    boolean fromRAM = false;\n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n      if (!fromRAM && (reader.directory() == this.ramDirectory)) {\n        fromRAM = true;\n      }\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n        directory);\n    if (fromRAM) {\n      sourceSegments.removeAllElements();\n      if (mergedDocCount > 0)\n        segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      if (mergedDocCount > 0)\n        segmentInfos.set(minSegment, newSegment);\n      else\n        sourceSegments.remove(minSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    synchronized (directory) {                 // in- & inter-process sync\n      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            segmentInfos.write(directory);     // commit before deleting\n            return null;\n          }\n        }.run();\n    }\n    \n    deleteSegments(segmentsToDelete);  // delete now-unused segments\n\n    if (useCompoundFile) {\n      final Vector filesToDelete = merger.createCompoundFile(mergedName + \".tmp\");\n      synchronized (directory) { // in- & inter-process sync\n        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            // make compound file visible for SegmentReaders\n            directory.renameFile(mergedName + \".tmp\", mergedName + \".cfs\");\n            return null;\n          }\n        }.run();\n      }\n\n      // delete now unused files of segment \n      deleteFiles(filesToDelete);   \n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /** Merges the named range of segments, replacing them in the stack with a\n   * single segment. */\n  private final void mergeSegments(int minSegment, int end)\n    throws IOException {\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n\n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = segmentInfos.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n    }\n\n    // update 1-doc segments counter accordin to range of merged segments\n    if (singleDocSegmentsCount>0) {\n      singleDocSegmentsCount = Math.min(singleDocSegmentsCount, segmentInfos.size()-end);\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n      segmentInfos.remove(i);\n    segmentInfos.set(minSegment, new SegmentInfo(mergedName, mergedDocCount,\n                                            directory));\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    synchronized (directory) {                 // in- & inter-process sync\n      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            segmentInfos.write(directory);     // commit before deleting\n            return null;\n          }\n        }.run();\n    }\n    \n    deleteSegments(segmentsToDelete);  // delete now-unused segments\n\n    if (useCompoundFile) {\n      final Vector filesToDelete = merger.createCompoundFile(mergedName + \".tmp\");\n      synchronized (directory) { // in- & inter-process sync\n        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            // make compound file visible for SegmentReaders\n            directory.renameFile(mergedName + \".tmp\", mergedName + \".cfs\");\n            return null;\n          }\n        }.run();\n      }\n\n      // delete now unused files of segment \n      deleteFiles(filesToDelete);   \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c","date":1158614762,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n\n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n        directory);\n    if (sourceSegments == ramSegmentInfos) {\n      sourceSegments.removeAllElements();\n      segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      segmentInfos.set(minSegment, newSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    synchronized (directory) {                 // in- & inter-process sync\n      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            segmentInfos.write(directory);     // commit before deleting\n            return null;\n          }\n        }.run();\n    }\n    \n    deleteSegments(segmentsToDelete);  // delete now-unused segments\n\n    if (useCompoundFile) {\n      final Vector filesToDelete = merger.createCompoundFile(mergedName + \".tmp\");\n      synchronized (directory) { // in- & inter-process sync\n        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            // make compound file visible for SegmentReaders\n            directory.renameFile(mergedName + \".tmp\", mergedName + \".cfs\");\n            return null;\n          }\n        }.run();\n      }\n\n      // delete now unused files of segment \n      deleteFiles(filesToDelete);   \n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n\n    boolean fromRAM = false;\n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n      if (!fromRAM && (reader.directory() == this.ramDirectory)) {\n        fromRAM = true;\n      }\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n        directory);\n    if (fromRAM) {\n      sourceSegments.removeAllElements();\n      if (mergedDocCount > 0)\n        segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      if (mergedDocCount > 0)\n        segmentInfos.set(minSegment, newSegment);\n      else\n        sourceSegments.remove(minSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    synchronized (directory) {                 // in- & inter-process sync\n      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            segmentInfos.write(directory);     // commit before deleting\n            return null;\n          }\n        }.run();\n    }\n    \n    deleteSegments(segmentsToDelete);  // delete now-unused segments\n\n    if (useCompoundFile) {\n      final Vector filesToDelete = merger.createCompoundFile(mergedName + \".tmp\");\n      synchronized (directory) { // in- & inter-process sync\n        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            // make compound file visible for SegmentReaders\n            directory.renameFile(mergedName + \".tmp\", mergedName + \".cfs\");\n            return null;\n          }\n        }.run();\n      }\n\n      // delete now unused files of segment \n      deleteFiles(filesToDelete);   \n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                             directory, false);\n    if (sourceSegments == ramSegmentInfos) {\n      sourceSegments.removeAllElements();\n      segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      segmentInfos.set(minSegment, newSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    segmentInfos.write(directory);     // commit before deleting\n\n    deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n    deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n\n    if (useCompoundFile) {\n      Vector filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n\n      segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n      newSegment.setUseCompoundFile(true);\n      segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n\n      deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n\n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n        directory);\n    if (sourceSegments == ramSegmentInfos) {\n      sourceSegments.removeAllElements();\n      segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      segmentInfos.set(minSegment, newSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    synchronized (directory) {                 // in- & inter-process sync\n      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            segmentInfos.write(directory);     // commit before deleting\n            return null;\n          }\n        }.run();\n    }\n    \n    deleteSegments(segmentsToDelete);  // delete now-unused segments\n\n    if (useCompoundFile) {\n      final Vector filesToDelete = merger.createCompoundFile(mergedName + \".tmp\");\n      synchronized (directory) { // in- & inter-process sync\n        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {\n          public Object doBody() throws IOException {\n            // make compound file visible for SegmentReaders\n            directory.renameFile(mergedName + \".tmp\", mergedName + \".cfs\");\n            return null;\n          }\n        }.run();\n      }\n\n      // delete now unused files of segment \n      deleteFiles(filesToDelete);   \n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":["6b772434f9f358356f8eedc2e017b9ddfb2615ec"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si);\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false);\n\n\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n\n          if (!inTransaction) {\n            // Now save the SegmentInfo instances that\n            // we are replacing:\n            rollback = (SegmentInfos) segmentInfos.clone();\n          }\n\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n    for (int i = minSegment; i < end; i++) {\n      SegmentInfo si = sourceSegments.info(i);\n      if (infoStream != null)\n        infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n      IndexReader reader = SegmentReader.get(si);\n      merger.add(reader);\n      if ((reader.directory() == this.directory) || // if we own the directory\n          (reader.directory() == this.ramDirectory))\n        segmentsToDelete.addElement(reader);   // queue segment for deletion\n    }\n\n    int mergedDocCount = merger.merge();\n\n    if (infoStream != null) {\n      infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n    }\n\n    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                             directory, false);\n    if (sourceSegments == ramSegmentInfos) {\n      sourceSegments.removeAllElements();\n      segmentInfos.addElement(newSegment);\n    } else {\n      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n        sourceSegments.remove(i);\n      segmentInfos.set(minSegment, newSegment);\n    }\n\n    // close readers before we attempt to delete now-obsolete segments\n    merger.closeReaders();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    segmentInfos.write(directory);     // commit before deleting\n\n    deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n    deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n\n    if (useCompoundFile) {\n      Vector filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n\n      segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n      newSegment.setUseCompoundFile(true);\n      segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n\n      deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":["6b772434f9f358356f8eedc2e017b9ddfb2615ec"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8969a184df55d25d61e85be785987fbf830d4028","date":1168143561,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si);\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false, true);\n\n\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n\n          if (!inTransaction) {\n            // Now save the SegmentInfo instances that\n            // we are replacing:\n            rollback = (SegmentInfos) segmentInfos.clone();\n          }\n\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si);\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false);\n\n\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n\n          if (!inTransaction) {\n            // Now save the SegmentInfo instances that\n            // we are replacing:\n            rollback = (SegmentInfos) segmentInfos.clone();\n          }\n\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b772434f9f358356f8eedc2e017b9ddfb2615ec","date":1170327312,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    boolean mergeFlag = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n     if (mergeFlag) {\n      if (infoStream != null) infoStream.print(\"merging segments\");\n      merger = new SegmentMerger(this, mergedName);\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n     }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n       if (mergeFlag) {\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false, true);\n       }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || !onlyRamDocsToFlush())) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n       if (mergeFlag) {\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n       }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          doAfterFlushRamSegments(mergeFlag);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && onlyRamDocsToFlush()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (mergeFlag) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // including the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && mergeFlag) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    final String mergedName = newSegmentName();\n    if (infoStream != null) infoStream.print(\"merging segments\");\n    SegmentMerger merger = new SegmentMerger(this, mergedName);\n    \n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si);\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false, true);\n\n\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n\n          if (!inTransaction) {\n            // Now save the SegmentInfo instances that\n            // we are replacing:\n            rollback = (SegmentInfos) segmentInfos.clone();\n          }\n\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":["eeefd99c477417e5c7c574228461ebafe92469d4","284c1d3c8b19931bf6f312fae7470487f5d9e580","db628922a5eb84f4c7e097a23b99c6fcfc46e084"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42a18cb0bca2c4ac9747f31c7a74fac90c661f39","date":1171363388,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if ((reader.directory() == this.directory) || // if we own the directory\n              (reader.directory() == this.ramDirectory))\n            segmentsToDelete.addElement(reader);   // queue segment for deletion\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // Includes the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && doMerge) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    boolean mergeFlag = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n     if (mergeFlag) {\n      if (infoStream != null) infoStream.print(\"merging segments\");\n      merger = new SegmentMerger(this, mergedName);\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = sourceSegments.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n        merger.add(reader);\n        if ((reader.directory() == this.directory) || // if we own the directory\n            (reader.directory() == this.ramDirectory))\n          segmentsToDelete.addElement(reader);   // queue segment for deletion\n      }\n     }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n       if (mergeFlag) {\n        mergedDocCount = merger.merge();\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false, true);\n       }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || !onlyRamDocsToFlush())) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n       if (mergeFlag) {\n        if (sourceSegments == ramSegmentInfos) {\n          segmentInfos.addElement(newSegment);\n        } else {\n          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n            sourceSegments.remove(i);\n\n          segmentInfos.set(minSegment, newSegment);\n        }\n       }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          doAfterFlushRamSegments(mergeFlag);\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && onlyRamDocsToFlush()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (mergeFlag) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // including the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && mergeFlag) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if ((reader.directory() == this.directory) || // if we own the directory\n              (reader.directory() == this.ramDirectory))\n            segmentsToDelete.addElement(reader);   // queue segment for deletion\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // Includes the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && doMerge) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if ((reader.directory() == this.directory) || // if we own the directory\n              (reader.directory() == this.ramDirectory))\n            segmentsToDelete.addElement(reader);   // queue segment for deletion\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // Includes the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && doMerge) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":["db628922a5eb84f4c7e097a23b99c6fcfc46e084"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final List ramSegmentsToDelete = new ArrayList();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n    boolean anyDeletes = (bufferedDeleteTerms.size() != 0);\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if (reader.directory() == this.ramDirectory) {\n            ramSegmentsToDelete.add(si);\n          }\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n        \n        if (sourceSegments != ramSegmentInfos || anyDeletes) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n        \n        checkpoint();\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else {\n\n          // Must rollback so our state matches index:\n          if (sourceSegments == ramSegmentInfos && !anyDeletes) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created and now unreferenced files:\n          deleter.refresh();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    // Delete the RAM segments\n    deleter.deleteDirect(ramDirectory, ramSegmentsToDelete);\n\n    // Give deleter a chance to remove files now.\n    deleter.checkpoint(segmentInfos, autoCommit);\n\n    if (useCompoundFile && doMerge) {\n\n      boolean success = false;\n\n      try {\n\n        merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        checkpoint();\n        success = true;\n\n      } finally {\n        if (!success) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.refresh();\n        }\n      }\n      \n      // Give deleter a chance to remove files now.\n      deleter.checkpoint(segmentInfos, autoCommit);\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final Vector segmentsToDelete = new Vector();\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if ((reader.directory() == this.directory) || // if we own the directory\n              (reader.directory() == this.ramDirectory))\n            segmentsToDelete.addElement(reader);   // queue segment for deletion\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n\n        if (!inTransaction\n            && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          // Should not be necessary: no prior commit should\n          // have left pending files, so just defensive:\n          deleter.clearPendingFiles();\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit before deleting\n        } else {\n          commitPending = true;\n        }\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else if (!inTransaction) {  \n\n          // Must rollback so our state matches index:\n\n          if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Erase any pending files that we were going to delete:\n          // i.e. old del files added by SegmentReader.doCommit() \n          deleter.clearPendingFiles();\n\n          // Delete any partially created files:\n          deleter.deleteFile(nextSegmentsFileName);\n          deleter.findDeletableFiles();\n          deleter.deleteFiles();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    if (!inTransaction) {\n      // Attempt to delete all files we just obsoleted:\n      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments\n      // Includes the old del files\n      deleter.commitPendingFiles();\n    } else {\n      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file\n      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments\n    }\n\n    if (useCompoundFile && doMerge) {\n\n      segmentsInfosFileName = nextSegmentsFileName;\n      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n      Vector filesToDelete;\n\n      boolean success = false;\n\n      try {\n\n        filesToDelete = merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        if (!inTransaction) {\n          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file\n        }\n        success = true;\n\n      } finally {\n        if (!success && !inTransaction) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.deleteFile(mergedName + \".cfs\");\n          deleter.deleteFile(nextSegmentsFileName);\n        }\n      }\n\n      if (!inTransaction) {\n        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file\n      }\n\n      // We can delete these segments whether or not we are\n      // in a transaction because we had just written them\n      // above so they can't need protection by the\n      // transaction:\n      deleter.deleteFiles(filesToDelete);  // delete now-unused segments\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6dba7919de4ff4ed6ff17f90619203772722f08","date":1180451647,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final List ramSegmentsToDelete = new ArrayList();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n    boolean anyDeletes = (bufferedDeleteTerms.size() != 0);\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si, MERGE_READ_BUFFER_SIZE); // no need to set deleter (yet)\n          merger.add(reader);\n          if (reader.directory() == this.ramDirectory) {\n            ramSegmentsToDelete.add(si);\n          }\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n        \n        if (sourceSegments != ramSegmentInfos || anyDeletes) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n        \n        checkpoint();\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else {\n\n          // Must rollback so our state matches index:\n          if (sourceSegments == ramSegmentInfos && !anyDeletes) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created and now unreferenced files:\n          deleter.refresh();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    // Delete the RAM segments\n    deleter.deleteDirect(ramDirectory, ramSegmentsToDelete);\n\n    // Give deleter a chance to remove files now.\n    deleter.checkpoint(segmentInfos, autoCommit);\n\n    if (useCompoundFile && doMerge) {\n\n      boolean success = false;\n\n      try {\n\n        merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        checkpoint();\n        success = true;\n\n      } finally {\n        if (!success) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.refresh();\n        }\n      }\n      \n      // Give deleter a chance to remove files now.\n      deleter.checkpoint(segmentInfos, autoCommit);\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final List ramSegmentsToDelete = new ArrayList();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n    boolean anyDeletes = (bufferedDeleteTerms.size() != 0);\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)\n          merger.add(reader);\n          if (reader.directory() == this.ramDirectory) {\n            ramSegmentsToDelete.add(si);\n          }\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n        \n        if (sourceSegments != ramSegmentInfos || anyDeletes) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n        \n        checkpoint();\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else {\n\n          // Must rollback so our state matches index:\n          if (sourceSegments == ramSegmentInfos && !anyDeletes) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created and now unreferenced files:\n          deleter.refresh();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    // Delete the RAM segments\n    deleter.deleteDirect(ramDirectory, ramSegmentsToDelete);\n\n    // Give deleter a chance to remove files now.\n    deleter.checkpoint(segmentInfos, autoCommit);\n\n    if (useCompoundFile && doMerge) {\n\n      boolean success = false;\n\n      try {\n\n        merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        checkpoint();\n        success = true;\n\n      } finally {\n        if (!success) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.refresh();\n        }\n      }\n      \n      // Give deleter a chance to remove files now.\n      deleter.checkpoint(segmentInfos, autoCommit);\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#mergeSegments(SegmentInfos,int,int).mjava","sourceNew":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  private final int mergeSegments(int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    final String mergedName = newSegmentName();\n    \n    SegmentMerger merger = null;\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (infoStream != null) infoStream.print(\"merging segments\");\n\n      // Check whether this merge will allow us to skip\n      // merging the doc stores (stored field & vectors).\n      // This is a very substantial optimization (saves tons\n      // of IO) that can only be applied with\n      // autoCommit=false.\n\n      Directory lastDir = directory;\n      String lastDocStoreSegment = null;\n      boolean mergeDocStores = false;\n      boolean doFlushDocStore = false;\n      int next = -1;\n\n      // Test each segment to be merged\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = segmentInfos.info(i);\n\n        // If it has deletions we must merge the doc stores\n        if (si.hasDeletions())\n          mergeDocStores = true;\n\n        // If it has its own (private) doc stores we must\n        // merge the doc stores\n        if (-1 == si.getDocStoreOffset())\n          mergeDocStores = true;\n\n        // If it has a different doc store segment than\n        // previous segments, we must merge the doc stores\n        String docStoreSegment = si.getDocStoreSegment();\n        if (docStoreSegment == null)\n          mergeDocStores = true;\n        else if (lastDocStoreSegment == null)\n          lastDocStoreSegment = docStoreSegment;\n        else if (!lastDocStoreSegment.equals(docStoreSegment))\n          mergeDocStores = true;\n\n        // Segments' docScoreOffsets must be in-order,\n        // contiguous.  For the default merge policy now\n        // this will always be the case but for an arbitrary\n        // merge policy this may not be the case\n        if (-1 == next)\n          next = si.getDocStoreOffset() + si.docCount;\n        else if (next != si.getDocStoreOffset())\n          mergeDocStores = true;\n        else\n          next = si.getDocStoreOffset() + si.docCount;\n      \n        // If the segment comes from a different directory\n        // we must merge\n        if (lastDir != si.dir)\n          mergeDocStores = true;\n\n        // If the segment is referencing the current \"live\"\n        // doc store outputs then we must merge\n        if (si.getDocStoreOffset() != -1 && si.getDocStoreSegment().equals(docWriter.getDocStoreSegment()))\n          doFlushDocStore = true;\n      }\n\n      final int docStoreOffset;\n      final String docStoreSegment;\n      final boolean docStoreIsCompoundFile;\n      if (mergeDocStores) {\n        docStoreOffset = -1;\n        docStoreSegment = null;\n        docStoreIsCompoundFile = false;\n      } else {\n        SegmentInfo si = segmentInfos.info(minSegment);        \n        docStoreOffset = si.getDocStoreOffset();\n        docStoreSegment = si.getDocStoreSegment();\n        docStoreIsCompoundFile = si.getDocStoreIsCompoundFile();\n      }\n\n      if (mergeDocStores && doFlushDocStore)\n        // SegmentMerger intends to merge the doc stores\n        // (stored fields, vectors), and at least one of the\n        // segments to be merged refers to the currently\n        // live doc stores.\n        flushDocStores();\n\n      merger = new SegmentMerger(this, mergedName);\n\n      for (int i = minSegment; i < end; i++) {\n        SegmentInfo si = segmentInfos.info(i);\n        if (infoStream != null)\n          infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n        IndexReader reader = SegmentReader.get(si, MERGE_READ_BUFFER_SIZE, mergeDocStores); // no need to set deleter (yet)\n        merger.add(reader);\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        mergedDocCount = merger.merge(mergeDocStores);\n\n        if (infoStream != null) {\n          infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n        }\n\n        newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                     directory, false, true,\n                                     docStoreOffset,\n                                     docStoreSegment,\n                                     docStoreIsCompoundFile);\n        \n        rollback = (SegmentInfos) segmentInfos.clone();\n\n        for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n          segmentInfos.remove(i);\n\n        segmentInfos.set(minSegment, newSegment);\n\n        checkpoint();\n\n        success = true;\n\n      } finally {\n        if (!success) {\n          if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created and now unreferenced files:\n          deleter.refresh();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      merger.closeReaders();\n    }\n\n    // Give deleter a chance to remove files now.\n    deleter.checkpoint(segmentInfos, autoCommit);\n\n    if (useCompoundFile) {\n\n      boolean success = false;\n\n      try {\n\n        merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        checkpoint();\n        success = true;\n\n      } finally {\n        if (!success) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.refresh();\n        }\n      }\n      \n      // Give deleter a chance to remove files now.\n      deleter.checkpoint(segmentInfos, autoCommit);\n    }\n\n    return mergedDocCount;\n  }\n\n","sourceOld":"  /**\n   * Merges the named range of segments, replacing them in the stack with a\n   * single segment.\n   */\n  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)\n    throws CorruptIndexException, IOException {\n\n    // We may be called solely because there are deletes\n    // pending, in which case doMerge is false:\n    boolean doMerge = end > 0;\n    final String mergedName = newSegmentName();\n    SegmentMerger merger = null;\n\n    final List ramSegmentsToDelete = new ArrayList();\n\n    SegmentInfo newSegment = null;\n\n    int mergedDocCount = 0;\n    boolean anyDeletes = (bufferedDeleteTerms.size() != 0);\n\n    // This is try/finally to make sure merger's readers are closed:\n    try {\n\n      if (doMerge) {\n        if (infoStream != null) infoStream.print(\"merging segments\");\n        merger = new SegmentMerger(this, mergedName);\n\n        for (int i = minSegment; i < end; i++) {\n          SegmentInfo si = sourceSegments.info(i);\n          if (infoStream != null)\n            infoStream.print(\" \" + si.name + \" (\" + si.docCount + \" docs)\");\n          IndexReader reader = SegmentReader.get(si, MERGE_READ_BUFFER_SIZE); // no need to set deleter (yet)\n          merger.add(reader);\n          if (reader.directory() == this.ramDirectory) {\n            ramSegmentsToDelete.add(si);\n          }\n        }\n      }\n\n      SegmentInfos rollback = null;\n      boolean success = false;\n\n      // This is try/finally to rollback our internal state\n      // if we hit exception when doing the merge:\n      try {\n\n        if (doMerge) {\n          mergedDocCount = merger.merge();\n\n          if (infoStream != null) {\n            infoStream.println(\" into \"+mergedName+\" (\"+mergedDocCount+\" docs)\");\n          }\n\n          newSegment = new SegmentInfo(mergedName, mergedDocCount,\n                                       directory, false, true);\n        }\n        \n        if (sourceSegments != ramSegmentInfos || anyDeletes) {\n          // Now save the SegmentInfo instances that\n          // we are replacing:\n          rollback = (SegmentInfos) segmentInfos.clone();\n        }\n\n        if (doMerge) {\n          if (sourceSegments == ramSegmentInfos) {\n            segmentInfos.addElement(newSegment);\n          } else {\n            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new\n              sourceSegments.remove(i);\n\n            segmentInfos.set(minSegment, newSegment);\n          }\n        }\n\n        if (sourceSegments == ramSegmentInfos) {\n          maybeApplyDeletes(doMerge);\n          doAfterFlush();\n        }\n        \n        checkpoint();\n\n        success = true;\n\n      } finally {\n\n        if (success) {\n          // The non-ram-segments case is already committed\n          // (above), so all the remains for ram segments case\n          // is to clear the ram segments:\n          if (sourceSegments == ramSegmentInfos) {\n            ramSegmentInfos.removeAllElements();\n          }\n        } else {\n\n          // Must rollback so our state matches index:\n          if (sourceSegments == ramSegmentInfos && !anyDeletes) {\n            // Simple case: newSegment may or may not have\n            // been added to the end of our segment infos,\n            // so just check & remove if so:\n            if (newSegment != null && \n                segmentInfos.size() > 0 && \n                segmentInfos.info(segmentInfos.size()-1) == newSegment) {\n              segmentInfos.remove(segmentInfos.size()-1);\n            }\n          } else if (rollback != null) {\n            // Rollback the individual SegmentInfo\n            // instances, but keep original SegmentInfos\n            // instance (so we don't try to write again the\n            // same segments_N file -- write once):\n            segmentInfos.clear();\n            segmentInfos.addAll(rollback);\n          }\n\n          // Delete any partially created and now unreferenced files:\n          deleter.refresh();\n        }\n      }\n    } finally {\n      // close readers before we attempt to delete now-obsolete segments\n      if (doMerge) merger.closeReaders();\n    }\n\n    // Delete the RAM segments\n    deleter.deleteDirect(ramDirectory, ramSegmentsToDelete);\n\n    // Give deleter a chance to remove files now.\n    deleter.checkpoint(segmentInfos, autoCommit);\n\n    if (useCompoundFile && doMerge) {\n\n      boolean success = false;\n\n      try {\n\n        merger.createCompoundFile(mergedName + \".cfs\");\n        newSegment.setUseCompoundFile(true);\n        checkpoint();\n        success = true;\n\n      } finally {\n        if (!success) {  \n          // Must rollback:\n          newSegment.setUseCompoundFile(false);\n          deleter.refresh();\n        }\n      }\n      \n      // Give deleter a chance to remove files now.\n      deleter.checkpoint(segmentInfos, autoCommit);\n    }\n\n    return mergedDocCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d7052f725a053aa55424f966831826f61b798bf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1b54a9bc667895a2095a886184bf69a3179e63df":["42a18cb0bca2c4ac9747f31c7a74fac90c661f39"],"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c":["d7052f725a053aa55424f966831826f61b798bf1"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["f6dba7919de4ff4ed6ff17f90619203772722f08"],"6b772434f9f358356f8eedc2e017b9ddfb2615ec":["8969a184df55d25d61e85be785987fbf830d4028"],"eeefd99c477417e5c7c574228461ebafe92469d4":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["db98d4535286b6e306e0cf1d1d4bfff5933fdc3c"],"42a18cb0bca2c4ac9747f31c7a74fac90c661f39":["6b772434f9f358356f8eedc2e017b9ddfb2615ec"],"f6dba7919de4ff4ed6ff17f90619203772722f08":["8b6187898fc4413ccd18229711786550a280383c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b6187898fc4413ccd18229711786550a280383c":["1b54a9bc667895a2095a886184bf69a3179e63df"],"8969a184df55d25d61e85be785987fbf830d4028":["eeefd99c477417e5c7c574228461ebafe92469d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"]},"commit2Childs":{"d7052f725a053aa55424f966831826f61b798bf1":["db98d4535286b6e306e0cf1d1d4bfff5933fdc3c"],"1b54a9bc667895a2095a886184bf69a3179e63df":["8b6187898fc4413ccd18229711786550a280383c"],"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6b772434f9f358356f8eedc2e017b9ddfb2615ec":["42a18cb0bca2c4ac9747f31c7a74fac90c661f39"],"eeefd99c477417e5c7c574228461ebafe92469d4":["8969a184df55d25d61e85be785987fbf830d4028"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["eeefd99c477417e5c7c574228461ebafe92469d4"],"42a18cb0bca2c4ac9747f31c7a74fac90c661f39":["1b54a9bc667895a2095a886184bf69a3179e63df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d7052f725a053aa55424f966831826f61b798bf1"],"f6dba7919de4ff4ed6ff17f90619203772722f08":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"8b6187898fc4413ccd18229711786550a280383c":["f6dba7919de4ff4ed6ff17f90619203772722f08"],"8969a184df55d25d61e85be785987fbf830d4028":["6b772434f9f358356f8eedc2e017b9ddfb2615ec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}