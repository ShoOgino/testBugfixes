{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","commits":[{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN);\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d044a068e0d16ff314fb7f93fa75194d5360a6ff","date":1355610187,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80ba0e0ced6273399ff97caaf301445b9fd24895","date":1356802943,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f6b3cc527ea5b77c571754501c277df01d94a11","date":1356846899,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getCoreNodeName(descriptor);\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getNodeName() + \"_\"\n            + descriptor.getName();\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getCoreNodeName(descriptor);\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = getCoreNodeName(descriptor);\n        try {\n          descriptor.getCloudDescriptor().isLeader = false;\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb1e46c944af7c0e22927ee89c130927b8f30bf8","date":1387825214,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n        \n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[] {coreZkNodeName,  collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n        \n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            return;\n          }\n\n        } catch (NoNodeException e) {\n         return;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n        \n        try {\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbcfc050b9f253136eaa5950b57248b2109eac11","date":1427308993,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n        \n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[] {coreZkNodeName,  collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n        \n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n          \n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[] {coreZkNodeName,  collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, Replica.State.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, Replica.State.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, ZkStateReader.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, ZkStateReader.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f1bee4bba8988141f8357bda2ccd9405926c4e5","date":1449703835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, Replica.State.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, Replica.State.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, Replica.State.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, Replica.State.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4820e7931c05e4eb25ac34917774fbacab59c3a3","date":1454991883,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName()); \n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      for (CoreDescriptor descriptor : descriptors) {\n        try {\n          descriptor.getCloudDescriptor().setLeader(false);\n          publish(descriptor, Replica.State.DOWN, updateLastPublished);\n        } catch (Exception e) {\n          if (isClosed) {\n            return;\n          }\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          try {\n            publish(descriptor, Replica.State.DOWN);\n          } catch (Exception e2) {\n            SolrException.log(log, \"\", e2);\n            continue;\n          }\n        }\n      }\n\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName());\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName()); \n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bbb0b5c5101d175049b4ced1462f4c266d32fc63","date":1559534216,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) throws SessionExpiredException {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName());\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (SessionExpiredException e) {\n          // zk has to reconnect\n          throw e;\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          log.warn(\"There was a problem while making a best effort to ensure the leader has seen us as down, this is not unexpected as Zookeeper has just reconnected after a session expiration\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName());\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c560208bc8842ee884b76b08784ccb132f05b48","date":1585344697,"type":5,"author":"Mike","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(Supplier[List[CoreDescriptor]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#registerAllCoresAsDown(CurrentCoreDescriptorProvider,boolean).mjava","sourceNew":"  private void registerAllCoresAsDown(\n      final Supplier<List<CoreDescriptor>> registerOnReconnect, boolean updateLastPublished) throws SessionExpiredException {\n    List<CoreDescriptor> descriptors = registerOnReconnect.get();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName());\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (SessionExpiredException e) {\n          // zk has to reconnect\n          throw e;\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          log.warn(\"There was a problem while making a best effort to ensure the leader has seen us as down, this is not unexpected as Zookeeper has just reconnected after a session expiration\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void registerAllCoresAsDown(\n      final CurrentCoreDescriptorProvider registerOnReconnect, boolean updateLastPublished) throws SessionExpiredException {\n    List<CoreDescriptor> descriptors = registerOnReconnect\n        .getCurrentDescriptors();\n    if (isClosed) return;\n    if (descriptors != null) {\n      // before registering as live, make sure everyone is in a\n      // down state\n      publishNodeAsDown(getNodeName());\n      for (CoreDescriptor descriptor : descriptors) {\n        // if it looks like we are going to be the leader, we don't\n        // want to wait for the following stuff\n        CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n        String collection = cloudDesc.getCollectionName();\n        String slice = cloudDesc.getShardId();\n        try {\n\n          int children = zkStateReader\n              .getZkClient()\n              .getChildren(\n                  ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection\n                      + \"/leader_elect/\" + slice + \"/election\", null, true).size();\n          if (children == 0) {\n            log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n            continue;\n          }\n\n        } catch (NoNodeException e) {\n          log.debug(\"looks like we are going to be the leader for collection {} shard {}\", collection, slice);\n          continue;\n        } catch (InterruptedException e2) {\n          Thread.currentThread().interrupt();\n        } catch (SessionExpiredException e) {\n          // zk has to reconnect\n          throw e;\n        } catch (KeeperException e) {\n          log.warn(\"\", e);\n          Thread.currentThread().interrupt();\n        }\n\n        final String coreZkNodeName = descriptor.getCloudDescriptor().getCoreNodeName();\n        try {\n          log.debug(\"calling waitForLeaderToSeeDownState for coreZkNodeName={} collection={} shard={}\", new Object[]{coreZkNodeName, collection, slice});\n          waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n        } catch (Exception e) {\n          log.warn(\"There was a problem while making a best effort to ensure the leader has seen us as down, this is not unexpected as Zookeeper has just reconnected after a session expiration\", e);\n          if (isClosed) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a6378064655e76cd7b908b1cab4ce425b384b508","4f6b3cc527ea5b77c571754501c277df01d94a11"],"cb1e46c944af7c0e22927ee89c130927b8f30bf8":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"1c560208bc8842ee884b76b08784ccb132f05b48":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["d044a068e0d16ff314fb7f93fa75194d5360a6ff"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["fbcfc050b9f253136eaa5950b57248b2109eac11"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cb1e46c944af7c0e22927ee89c130927b8f30bf8","fbcfc050b9f253136eaa5950b57248b2109eac11"],"a6378064655e76cd7b908b1cab4ce425b384b508":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d044a068e0d16ff314fb7f93fa75194d5360a6ff":["a6378064655e76cd7b908b1cab4ce425b384b508"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["4f6b3cc527ea5b77c571754501c277df01d94a11"],"4f6b3cc527ea5b77c571754501c277df01d94a11":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1c560208bc8842ee884b76b08784ccb132f05b48"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["cb1e46c944af7c0e22927ee89c130927b8f30bf8"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"cb1e46c944af7c0e22927ee89c130927b8f30bf8":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fbcfc050b9f253136eaa5950b57248b2109eac11"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"1c560208bc8842ee884b76b08784ccb132f05b48":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["4f6b3cc527ea5b77c571754501c277df01d94a11"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["cb1e46c944af7c0e22927ee89c130927b8f30bf8","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a6378064655e76cd7b908b1cab4ce425b384b508":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d044a068e0d16ff314fb7f93fa75194d5360a6ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a6378064655e76cd7b908b1cab4ce425b384b508"],"d044a068e0d16ff314fb7f93fa75194d5360a6ff":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["1c560208bc8842ee884b76b08784ccb132f05b48"],"4f6b3cc527ea5b77c571754501c277df01d94a11":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}