{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","commits":[{"id":"de3459a54b4c8751d9ef19b035577e2418064be7","date":1520297996,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        Map<String, String> properties = fetchCollectionProperties(coll, this);\n        watchedCollectionProps.put(coll, properties);\n        if (notifyWatchers) {\n          notifyPropsWatchers(coll, properties);\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["14ad5f6d86e47603e934be859694ffbba27cd436"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14ad5f6d86e47603e934be859694ffbba27cd436","date":1522709785,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (coll) { // We only have one PropsWatcher instance per collection, so it's fine to sync on coll\n          Map<String, String> properties = fetchCollectionProperties(coll, this);\n          watchedCollectionProps.put(coll, properties);\n          /*\n           * Note that if two events were fired close to each other and the second one arrived first, we would read the collectionprops.json\n           * twice for the same data and notify watchers (in case of notifyWatchers==true) twice for the same data, however it's guaranteed\n           * that after processing both events, watchedCollectionProps will have the latest data written to ZooKeeper and that the watchers\n           * won't be called with out of order data\n           * \n           */\n          if (notifyWatchers) {\n            notifyPropsWatchers(coll, properties);\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        Map<String, String> properties = fetchCollectionProperties(coll, this);\n        watchedCollectionProps.put(coll, properties);\n        if (notifyWatchers) {\n          notifyPropsWatchers(coll, properties);\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","bugFix":["de3459a54b4c8751d9ef19b035577e2418064be7"],"bugIntro":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (coll) { // We only have one PropsWatcher instance per collection, so it's fine to sync on coll\n          Map<String, String> properties = fetchCollectionProperties(coll, this);\n          watchedCollectionProps.put(coll, properties);\n          /*\n           * Note that if two events were fired close to each other and the second one arrived first, we would read the collectionprops.json\n           * twice for the same data and notify watchers (in case of notifyWatchers==true) twice for the same data, however it's guaranteed\n           * that after processing both events, watchedCollectionProps will have the latest data written to ZooKeeper and that the watchers\n           * won't be called with out of order data\n           * \n           */\n          if (notifyWatchers) {\n            notifyPropsWatchers(coll, properties);\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (coll) { // We only have one PropsWatcher instance per collection, so it's fine to sync on coll\n          Map<String, String> properties = fetchCollectionProperties(coll, this);\n          watchedCollectionProps.put(coll, properties);\n          /*\n           * Note that if two events were fired close to each other and the second one arrived first, we would read the collectionprops.json\n           * twice for the same data and notify watchers (in case of notifyWatchers==true) twice for the same data, however it's guaranteed\n           * that after processing both events, watchedCollectionProps will have the latest data written to ZooKeeper and that the watchers\n           * won't be called with out of order data\n           * \n           */\n          if (notifyWatchers) {\n            notifyPropsWatchers(coll, properties);\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e92ecc804db94989e3c224b898b8dc978ebb584f","date":1556036948,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n          VersionedCollectionProps vcp = fetchCollectionProperties(coll, this);\n          Map<String, String> properties = vcp.props;\n          VersionedCollectionProps existingVcp = watchedCollectionProps.get(coll);\n          if (existingVcp == null ||                   // never called before, record what we found\n              vcp.zkVersion > existingVcp.zkVersion || // newer info we should update\n              vcp.zkVersion == -1) {                   // node was deleted start over\n            watchedCollectionProps.put(coll, vcp);\n            if (notifyWatchers) {\n              notifyPropsWatchers(coll, properties);\n            }\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (coll) { // We only have one PropsWatcher instance per collection, so it's fine to sync on coll\n          Map<String, String> properties = fetchCollectionProperties(coll, this);\n          watchedCollectionProps.put(coll, properties);\n          /*\n           * Note that if two events were fired close to each other and the second one arrived first, we would read the collectionprops.json\n           * twice for the same data and notify watchers (in case of notifyWatchers==true) twice for the same data, however it's guaranteed\n           * that after processing both events, watchedCollectionProps will have the latest data written to ZooKeeper and that the watchers\n           * won't be called with out of order data\n           * \n           */\n          if (notifyWatchers) {\n            notifyPropsWatchers(coll, properties);\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","bugFix":["14ad5f6d86e47603e934be859694ffbba27cd436"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad04daa4b07fab11f19bb17a8b556b0dde898d7f","date":1560262372,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n          VersionedCollectionProps vcp = fetchCollectionProperties(coll, this);\n          Map<String, String> properties = vcp.props;\n          VersionedCollectionProps existingVcp = watchedCollectionProps.get(coll);\n          if (existingVcp == null ||                   // never called before, record what we found\n              vcp.zkVersion > existingVcp.zkVersion || // newer info we should update\n              vcp.zkVersion == -1) {                   // node was deleted start over\n            watchedCollectionProps.put(coll, vcp);\n            if (notifyWatchers) {\n              notifyPropsWatchers(coll, properties);\n            }\n            if (vcp.zkVersion == -1 && existingVcp != null) { // Collection DELETE detected\n\n              // We should not be caching a collection that has been deleted.\n              watchedCollectionProps.remove(coll);\n\n              // core ref counting not relevant here, don't need canRemove(), we just sent\n              // a notification of an empty set of properties, no reason to watch what doesn't exist.\n              collectionPropsObservers.remove(coll);\n\n              // This is the one time we know it's safe to throw this out. We just failed to set the watch\n              // due to an NoNodeException, so it isn't held by ZK and can't re-set itself due to an update.\n              collectionPropsWatchers.remove(coll);\n            }\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n          VersionedCollectionProps vcp = fetchCollectionProperties(coll, this);\n          Map<String, String> properties = vcp.props;\n          VersionedCollectionProps existingVcp = watchedCollectionProps.get(coll);\n          if (existingVcp == null ||                   // never called before, record what we found\n              vcp.zkVersion > existingVcp.zkVersion || // newer info we should update\n              vcp.zkVersion == -1) {                   // node was deleted start over\n            watchedCollectionProps.put(coll, vcp);\n            if (notifyWatchers) {\n              notifyPropsWatchers(coll, properties);\n            }\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.PropsWatcher#refreshAndWatch(boolean).mjava","sourceNew":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n          VersionedCollectionProps vcp = fetchCollectionProperties(coll, this);\n          Map<String, String> properties = vcp.props;\n          VersionedCollectionProps existingVcp = watchedCollectionProps.get(coll);\n          if (existingVcp == null ||                   // never called before, record what we found\n              vcp.zkVersion > existingVcp.zkVersion || // newer info we should update\n              vcp.zkVersion == -1) {                   // node was deleted start over\n            watchedCollectionProps.put(coll, vcp);\n            if (notifyWatchers) {\n              notifyPropsWatchers(coll, properties);\n            }\n            if (vcp.zkVersion == -1 && existingVcp != null) { // Collection DELETE detected\n\n              // We should not be caching a collection that has been deleted.\n              watchedCollectionProps.remove(coll);\n\n              // core ref counting not relevant here, don't need canRemove(), we just sent\n              // a notification of an empty set of properties, no reason to watch what doesn't exist.\n              collectionPropsObservers.remove(coll);\n\n              // This is the one time we know it's safe to throw this out. We just failed to set the watch\n              // due to an NoNodeException, so it isn't held by ZK and can't re-set itself due to an update.\n              collectionPropsWatchers.remove(coll);\n            }\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: \", e);\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","sourceOld":"    /**\n     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in\n     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers\n     */\n    void refreshAndWatch(boolean notifyWatchers) {\n      try {\n        synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n          VersionedCollectionProps vcp = fetchCollectionProperties(coll, this);\n          Map<String, String> properties = vcp.props;\n          VersionedCollectionProps existingVcp = watchedCollectionProps.get(coll);\n          if (existingVcp == null ||                   // never called before, record what we found\n              vcp.zkVersion > existingVcp.zkVersion || // newer info we should update\n              vcp.zkVersion == -1) {                   // node was deleted start over\n            watchedCollectionProps.put(coll, vcp);\n            if (notifyWatchers) {\n              notifyPropsWatchers(coll, properties);\n            }\n            if (vcp.zkVersion == -1 && existingVcp != null) { // Collection DELETE detected\n\n              // We should not be caching a collection that has been deleted.\n              watchedCollectionProps.remove(coll);\n\n              // core ref counting not relevant here, don't need canRemove(), we just sent\n              // a notification of an empty set of properties, no reason to watch what doesn't exist.\n              collectionPropsObservers.remove(coll);\n\n              // This is the one time we know it's safe to throw this out. We just failed to set the watch\n              // due to an NoNodeException, so it isn't held by ZK and can't re-set itself due to an update.\n              collectionPropsWatchers.remove(coll);\n            }\n          }\n        }\n      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"Lost collection property watcher for {} due to ZK error\", coll, e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.error(\"Lost collection property watcher for {} due to the thread being interrupted\", coll, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"de3459a54b4c8751d9ef19b035577e2418064be7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14ad5f6d86e47603e934be859694ffbba27cd436":["de3459a54b4c8751d9ef19b035577e2418064be7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["14ad5f6d86e47603e934be859694ffbba27cd436"]},"commit2Childs":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"de3459a54b4c8751d9ef19b035577e2418064be7":["14ad5f6d86e47603e934be859694ffbba27cd436"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de3459a54b4c8751d9ef19b035577e2418064be7"],"14ad5f6d86e47603e934be859694ffbba27cd436":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}