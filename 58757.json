{"path":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","commits":[{"id":"c7e79e31f55cbb444e3023d430a340658755aa31","date":1357666399,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin].ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery q = new BooleanQuery(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n            return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n\n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery q = new BooleanQuery(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n      } else {\n\n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n\n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin].ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery q = new BooleanQuery(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n            return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n\n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery q = new BooleanQuery(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n      } else {\n\n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n\n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          q.setDisableCoord(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery q = new BooleanQuery(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          q.setDisableCoord(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          // should we disable coord?\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          q.setDisableCoord(disableCoord);\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return QueryUtils.build(q, parser);\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return QueryUtils.build(q, parser);\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getAliasedQuery().mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return QueryUtils.build(q, parser);\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    protected Query getAliasedQuery() throws SyntaxError {\n      Alias a = aliases.get(field);\n      this.validateCyclicAliasing(field);\n      if (a != null) {\n        List<Query> lst = getQueries(a);\n        if (lst == null || lst.size()==0)\n          return getQuery();\n        // make a DisjunctionMaxQuery in this case too... it will stop\n        // the \"mm\" processing from making everything required in the case\n        // that the query expanded to multiple clauses.\n        // DisMaxQuery.rewrite() removes itself if there is just a single clause anyway.\n        // if (lst.size()==1) return lst.get(0);\n        \n        if (makeDismax) {\n          DisjunctionMaxQuery q = new DisjunctionMaxQuery(lst, a.tie);\n          return q;\n        } else {\n          BooleanQuery.Builder q = new BooleanQuery.Builder();\n          for (Query sub : lst) {\n            q.add(sub, BooleanClause.Occur.SHOULD);\n          }\n          return q.build();\n        }\n      } else {\n        \n        // verify that a fielded query is actually on a field that exists... if not,\n        // then throw an exception to get us out of here, and we'll treat it like a\n        // literal when we try the escape+re-parse.\n        if (exceptions) {\n          FieldType ft = schema.getFieldTypeNoEx(field);\n          if (ft == null && null == MagicFieldName.get(field)) {\n            throw unknownField;\n          }\n        }\n        \n        return getQuery();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c7e79e31f55cbb444e3023d430a340658755aa31"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"39fdbc59d893f5a211736e861fe145798a40b9ff":["c8a0e442f7b61f811680273b25da95994a724466"],"c8a0e442f7b61f811680273b25da95994a724466":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"c7e79e31f55cbb444e3023d430a340658755aa31":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["c8a0e442f7b61f811680273b25da95994a724466","39fdbc59d893f5a211736e861fe145798a40b9ff"],"28288370235ed02234a64753cdbf0c6ec096304a":["c8a0e442f7b61f811680273b25da95994a724466","39fdbc59d893f5a211736e861fe145798a40b9ff"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","c8a0e442f7b61f811680273b25da95994a724466"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c7e79e31f55cbb444e3023d430a340658755aa31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7e79e31f55cbb444e3023d430a340658755aa31","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c8a0e442f7b61f811680273b25da95994a724466":["39fdbc59d893f5a211736e861fe145798a40b9ff","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c7e79e31f55cbb444e3023d430a340658755aa31":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}