{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","commits":[{"id":"7266c313bb3b4fbcde3dcc82556182e1fae90080","date":1400183760,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString() + \" length=\" + target.length);\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n      //if (DEBUG) System.out.println(\"cycle idx=\" + idx);\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n        final boolean saveIsAutoPrefixTerm = currentFrame.isAutoPrefixTerm;\n\n        //if (DEBUG) System.out.println(\"    cycle isAutoPrefix=\" + saveIsAutoPrefixTerm + \" ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        //if (DEBUG) System.out.println(\"      isSubBlock=\" + isSubBlock + \" term/prefix=\" + brToString(term) + \" saveIsAutoPrefixTerm=\" + saveIsAutoPrefixTerm + \" allowAutoPrefixTerms=\" + allowAutoPrefixTerms);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          //if (DEBUG) System.out.println(\"      cmp=\" + cmp);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            if (allowAutoPrefixTerms == false && currentFrame.isAutoPrefixTerm) {\n              continue;\n            }\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else if (allowAutoPrefixTerms || currentFrame.isAutoPrefixTerm == false) {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            //if (DEBUG) System.out.println(\"    fallback prior entry\");\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            currentFrame.isAutoPrefixTerm = saveIsAutoPrefixTerm;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString() + \" length=\" + target.length);\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n      //if (DEBUG) System.out.println(\"cycle idx=\" + idx);\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n        final boolean saveIsAutoPrefixTerm = currentFrame.isAutoPrefixTerm;\n\n        //if (DEBUG) System.out.println(\"    cycle isAutoPrefix=\" + saveIsAutoPrefixTerm + \" ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        //if (DEBUG) System.out.println(\"      isSubBlock=\" + isSubBlock + \" term/prefix=\" + brToString(term) + \" saveIsAutoPrefixTerm=\" + saveIsAutoPrefixTerm + \" allowAutoPrefixTerms=\" + allowAutoPrefixTerms);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          //if (DEBUG) System.out.println(\"      cmp=\" + cmp);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            if (allowAutoPrefixTerms == false && currentFrame.isAutoPrefixTerm) {\n              continue;\n            }\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else if (allowAutoPrefixTerms || currentFrame.isAutoPrefixTerm == false) {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            //if (DEBUG) System.out.println(\"    fallback prior entry\");\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            currentFrame.isAutoPrefixTerm = saveIsAutoPrefixTerm;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n        final boolean saveIsAutoPrefixTerm = currentFrame.isAutoPrefixTerm;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            if (allowAutoPrefixTerms == false && currentFrame.isAutoPrefixTerm) {\n              continue;\n            }\n            return;\n          } else if (allowAutoPrefixTerms || currentFrame.isAutoPrefixTerm == false) {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            currentFrame.isAutoPrefixTerm = saveIsAutoPrefixTerm;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString() + \" length=\" + target.length);\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n      //if (DEBUG) System.out.println(\"cycle idx=\" + idx);\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n        final boolean saveIsAutoPrefixTerm = currentFrame.isAutoPrefixTerm;\n\n        //if (DEBUG) System.out.println(\"    cycle isAutoPrefix=\" + saveIsAutoPrefixTerm + \" ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        //if (DEBUG) System.out.println(\"      isSubBlock=\" + isSubBlock + \" term/prefix=\" + brToString(term) + \" saveIsAutoPrefixTerm=\" + saveIsAutoPrefixTerm + \" allowAutoPrefixTerms=\" + allowAutoPrefixTerms);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          //if (DEBUG) System.out.println(\"      cmp=\" + cmp);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            if (allowAutoPrefixTerms == false && currentFrame.isAutoPrefixTerm) {\n              continue;\n            }\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else if (allowAutoPrefixTerms || currentFrame.isAutoPrefixTerm == false) {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            //if (DEBUG) System.out.println(\"    fallback prior entry\");\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            currentFrame.isAutoPrefixTerm = saveIsAutoPrefixTerm;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n        final boolean saveIsAutoPrefixTerm = currentFrame.isAutoPrefixTerm;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            if (allowAutoPrefixTerms == false && currentFrame.isAutoPrefixTerm) {\n              continue;\n            }\n            return;\n          } else if (allowAutoPrefixTerms || currentFrame.isAutoPrefixTerm == false) {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            currentFrame.isAutoPrefixTerm = saveIsAutoPrefixTerm;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveLengthPos = currentFrame.suffixLengthsReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.suffixLengthsReader.setPosition(saveLengthPos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<BytesRef> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savNextEnt = currentFrame.nextEnt;\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                // Advance to next floor block\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt = savNextEnt;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7266c313bb3b4fbcde3dcc82556182e1fae90080"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["3e8715d826e588419327562287d5d6a8040d63d6"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"7266c313bb3b4fbcde3dcc82556182e1fae90080":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["4d637064d608752565d4f9f41b2497dfdfdde50e","3e8715d826e588419327562287d5d6a8040d63d6"],"9407318969e8504257b4c5764c65755a043e5404":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"3e8715d826e588419327562287d5d6a8040d63d6":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9407318969e8504257b4c5764c65755a043e5404"]},"commit2Childs":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["9407318969e8504257b4c5764c65755a043e5404"],"7266c313bb3b4fbcde3dcc82556182e1fae90080":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d637064d608752565d4f9f41b2497dfdfdde50e","7266c313bb3b4fbcde3dcc82556182e1fae90080"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"9407318969e8504257b4c5764c65755a043e5404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3e8715d826e588419327562287d5d6a8040d63d6":["59db5e5f780185e0155d296a323e440a6ecfd3b6","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}