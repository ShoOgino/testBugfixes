{"path":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680afea24788497408a554fb2e56812496e8c7c4","date":1282663439,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4946500259641951dbd7f8a61956bf14bef3f60","date":1283284212,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(sim, 1, Arrays.asList(scorers), null);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e00f80591de714c6975f454e33e0fa5218b5902","date":1294514405,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, false, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, false, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4","date":1295478199,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, false, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5e679b9c5f68f1f331de920ae8366af75b44060","date":1295555804,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, false, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790e1fde4caa765b3faaad3fbcd25c6973450336","date":1296689245,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Similarity sim = Similarity.getDefault();\n    Scorer[] scorers = new Scorer[] {new Scorer(sim) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    BooleanScorer bs = new BooleanScorer(null, sim, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd86d8c5713fc65e119372f12a3c5fdc47987b56","date":1318525216,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    searcher.close();\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n    \n    assertEquals(\"should have received 3000\", 3000, bs.nextDoc());\n    assertEquals(\"should have received NO_MORE_DOCS\", DocIdSetIterator.NO_MORE_DOCS, bs.nextDoc());\n    searcher.close();\n    ir.close();\n    directory.close();\n    \n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    searcher.close();\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    searcher.close();\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["dd86d8c5713fc65e119372f12a3c5fdc47987b56","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4":["3e00f80591de714c6975f454e33e0fa5218b5902"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","e4946500259641951dbd7f8a61956bf14bef3f60"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["868da859b43505d9d2a023bfeae6dd0c795f5295","e5e679b9c5f68f1f331de920ae8366af75b44060"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["e5e679b9c5f68f1f331de920ae8366af75b44060"],"3e00f80591de714c6975f454e33e0fa5218b5902":["e4946500259641951dbd7f8a61956bf14bef3f60"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["dd86d8c5713fc65e119372f12a3c5fdc47987b56"],"dd86d8c5713fc65e119372f12a3c5fdc47987b56":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["e4946500259641951dbd7f8a61956bf14bef3f60","790e1fde4caa765b3faaad3fbcd25c6973450336"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"680afea24788497408a554fb2e56812496e8c7c4":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e00f80591de714c6975f454e33e0fa5218b5902"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","790e1fde4caa765b3faaad3fbcd25c6973450336"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e4946500259641951dbd7f8a61956bf14bef3f60":["680afea24788497408a554fb2e56812496e8c7c4"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4":["e5e679b9c5f68f1f331de920ae8366af75b44060"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["dd86d8c5713fc65e119372f12a3c5fdc47987b56","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"3e00f80591de714c6975f454e33e0fa5218b5902":["03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4","868da859b43505d9d2a023bfeae6dd0c795f5295"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"dd86d8c5713fc65e119372f12a3c5fdc47987b56":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"680afea24788497408a554fb2e56812496e8c7c4":["e4946500259641951dbd7f8a61956bf14bef3f60"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["e79a6d080bdd5b2a8f56342cf571b5476de04180","790e1fde4caa765b3faaad3fbcd25c6973450336"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","680afea24788497408a554fb2e56812496e8c7c4"],"e4946500259641951dbd7f8a61956bf14bef3f60":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e00f80591de714c6975f454e33e0fa5218b5902","29ef99d61cda9641b6250bf9567329a6e65f901d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}