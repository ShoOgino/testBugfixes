{"path":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f703b580a38c8a12d78077283f2372b6f65312a0","date":1566551787,"type":3,"author":"Julie Tibshirani","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceSortKey natural order\n          int cmp = Double.compare(a.distanceSortKey, b.distanceSortKey);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cdf8ee483a06be1f8c1def79bf43ff90917cf09","date":1566804957,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceSortKey natural order\n          int cmp = Double.compare(a.distanceSortKey, b.distanceSortKey);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (visitor.compare(cell.minPacked, cell.maxPacked) == Relation.CELL_OUTSIDE_QUERY) {\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceSortKey natural order\n          int cmp = Double.compare(a.distanceSortKey, b.distanceSortKey);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7cdf8ee483a06be1f8c1def79bf43ff90917cf09":["f703b580a38c8a12d78077283f2372b6f65312a0"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f703b580a38c8a12d78077283f2372b6f65312a0":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7cdf8ee483a06be1f8c1def79bf43ff90917cf09"]},"commit2Childs":{"7cdf8ee483a06be1f8c1def79bf43ff90917cf09":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["f703b580a38c8a12d78077283f2372b6f65312a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"f703b580a38c8a12d78077283f2372b6f65312a0":["7cdf8ee483a06be1f8c1def79bf43ff90917cf09"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}