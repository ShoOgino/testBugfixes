{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f40c889ffdeb55be3af231b4db0787b92e498aab","date":1489398769,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d848516a5d0b23d183a2ceb4f4fb8634205956","date":1496408348,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41725d3c68dcac6ccfe29dec314c6e56a62cebb4","date":1498237980,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(\"solrconfig-tlog.xml\", \"schema-inplace-updates.xml\");\n\n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n\n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n\n    // validate that the schema was not changed to an unexpected state\n    IndexSchema schema = h.getCore().getLatestSchema();\n    for (String fieldName : Arrays.asList(\"_version_\",\n                                          \"inplace_l_dvo\",\n                                          \"inplace_updatable_float\",\n                                          \"inplace_updatable_int\", \n                                          \"inplace_updatable_float_with_default\",\n                                          \"inplace_updatable_int_with_default\")) {\n      // these fields must only be using docValues to support inplace updates\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(),\n                 field.hasDocValues() && ! field.indexed() && ! field.stored());\n    }\n    for (String fieldName : Arrays.asList(\"title_s\", \"regular_l\", \"stored_i\")) {\n      // these fields must support atomic updates, but not inplace updates (ie: stored)\n      SchemaField field = schema.getField(fieldName);\n      assertTrue(field.toString(), field.stored());\n    }    \n\n    // Don't close this client, it would shutdown the CoreContainer\n    client = new EmbeddedSolrServer(h.getCoreContainer(), h.coreName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["f40c889ffdeb55be3af231b4db0787b92e498aab","70d848516a5d0b23d183a2ceb4f4fb8634205956"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"f40c889ffdeb55be3af231b4db0787b92e498aab":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"41725d3c68dcac6ccfe29dec314c6e56a62cebb4":["70d848516a5d0b23d183a2ceb4f4fb8634205956"],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["f40c889ffdeb55be3af231b4db0787b92e498aab"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["e9017cf144952056066919f1ebc7897ff9bd71b1","41725d3c68dcac6ccfe29dec314c6e56a62cebb4"],"28288370235ed02234a64753cdbf0c6ec096304a":["f40c889ffdeb55be3af231b4db0787b92e498aab","41725d3c68dcac6ccfe29dec314c6e56a62cebb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","f40c889ffdeb55be3af231b4db0787b92e498aab"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"f40c889ffdeb55be3af231b4db0787b92e498aab":["e9017cf144952056066919f1ebc7897ff9bd71b1","70d848516a5d0b23d183a2ceb4f4fb8634205956","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"41725d3c68dcac6ccfe29dec314c6e56a62cebb4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["e9017cf144952056066919f1ebc7897ff9bd71b1","41725d3c68dcac6ccfe29dec314c6e56a62cebb4"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}