{"path":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsCategoryListBuilder#handle(int,CategoryPath).mjava","commits":[{"id":"7a1037d9031f9702ee6912f8751ef1d5320da6d9","date":1357217787,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsCategoryListBuilder#handle(int,CategoryPath).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handle(int ordinal, CategoryPath cp) throws IOException {\n    super.handle(ordinal, cp);\n    \n    // build per-association key BytesRef\n    CategoryAssociation association = associations.getAssociation(cp);\n    if (association == null) {\n      // it is ok to set a null association for a category - it's treated as a\n      // regular category in that case.\n      return;\n    }\n    \n    BytesRef bytes = perAssociationBytes.get(association.getCategoryListID());\n    if (bytes == null) {\n      bytes = new BytesRef();\n      perAssociationBytes.put(association.getCategoryListID(), bytes);\n    }\n    \n    int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded();\n    if (bytes.bytes.length - bytes.length < maxBytesNeeded) {\n      bytes.grow(bytes.bytes.length + maxBytesNeeded);\n    }\n    \n    // reset the output to write from bytes.length (current position) until the end\n    output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n    output.writeInt(ordinal);\n    \n    // encode the association bytes\n    association.serialize(output);\n    \n    // update BytesRef\n    bytes.length = output.getPosition();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsCategoryListBuilder#handle(int,CategoryPath).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handle(int ordinal, CategoryPath cp) throws IOException {\n    super.handle(ordinal, cp);\n    \n    // build per-association key BytesRef\n    CategoryAssociation association = associations.getAssociation(cp);\n    if (association == null) {\n      // it is ok to set a null association for a category - it's treated as a\n      // regular category in that case.\n      return;\n    }\n    \n    BytesRef bytes = perAssociationBytes.get(association.getCategoryListID());\n    if (bytes == null) {\n      bytes = new BytesRef();\n      perAssociationBytes.put(association.getCategoryListID(), bytes);\n    }\n    \n    int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded();\n    if (bytes.bytes.length - bytes.length < maxBytesNeeded) {\n      bytes.grow(bytes.bytes.length + maxBytesNeeded);\n    }\n    \n    // reset the output to write from bytes.length (current position) until the end\n    output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n    output.writeInt(ordinal);\n    \n    // encode the association bytes\n    association.serialize(output);\n    \n    // update BytesRef\n    bytes.length = output.getPosition();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bceb02c33032dd9bbf107cd06d0b74e5db4f110a","date":1357909746,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsCategoryListBuilder#handle(int,CategoryPath).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void handle(int ordinal, CategoryPath cp) throws IOException {\n    super.handle(ordinal, cp);\n    \n    // build per-association key BytesRef\n    CategoryAssociation association = associations.getAssociation(cp);\n    if (association == null) {\n      // it is ok to set a null association for a category - it's treated as a\n      // regular category in that case.\n      return;\n    }\n    \n    BytesRef bytes = perAssociationBytes.get(association.getCategoryListID());\n    if (bytes == null) {\n      bytes = new BytesRef();\n      perAssociationBytes.put(association.getCategoryListID(), bytes);\n    }\n    \n    int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded();\n    if (bytes.bytes.length - bytes.length < maxBytesNeeded) {\n      bytes.grow(bytes.bytes.length + maxBytesNeeded);\n    }\n    \n    // reset the output to write from bytes.length (current position) until the end\n    output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n    output.writeInt(ordinal);\n    \n    // encode the association bytes\n    association.serialize(output);\n    \n    // update BytesRef\n    bytes.length = output.getPosition();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsCategoryListBuilder#handle(int,CategoryPath).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void handle(int ordinal, CategoryPath cp) throws IOException {\n    super.handle(ordinal, cp);\n    \n    // build per-association key BytesRef\n    CategoryAssociation association = associations.getAssociation(cp);\n    if (association == null) {\n      // it is ok to set a null association for a category - it's treated as a\n      // regular category in that case.\n      return;\n    }\n    \n    BytesRef bytes = perAssociationBytes.get(association.getCategoryListID());\n    if (bytes == null) {\n      bytes = new BytesRef();\n      perAssociationBytes.put(association.getCategoryListID(), bytes);\n    }\n    \n    int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded();\n    if (bytes.bytes.length - bytes.length < maxBytesNeeded) {\n      bytes.grow(bytes.bytes.length + maxBytesNeeded);\n    }\n    \n    // reset the output to write from bytes.length (current position) until the end\n    output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n    output.writeInt(ordinal);\n    \n    // encode the association bytes\n    association.serialize(output);\n    \n    // update BytesRef\n    bytes.length = output.getPosition();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a1037d9031f9702ee6912f8751ef1d5320da6d9"],"7a1037d9031f9702ee6912f8751ef1d5320da6d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["7a1037d9031f9702ee6912f8751ef1d5320da6d9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"7a1037d9031f9702ee6912f8751ef1d5320da6d9":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7a1037d9031f9702ee6912f8751ef1d5320da6d9"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}