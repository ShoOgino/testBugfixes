{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","commits":[{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","date":1414017220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a485550d032df41f9ff97f4d97d81e2be011d3ca","date":1414053996,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NO) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f95ce1375367b92d411a06175eab3915fe93c6bc","date":1414788502,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NO) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","date":1415435053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValueType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["3184874f7f3aca850248483485b4995343066875"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["a485550d032df41f9ff97f4d97d81e2be011d3ca"],"556a4aab886d75371b2af129d87be3c2795cea76":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"3184874f7f3aca850248483485b4995343066875":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a485550d032df41f9ff97f4d97d81e2be011d3ca":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","79700663e164dece87bed4adfd3e28bab6cb1385"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3184874f7f3aca850248483485b4995343066875"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["79700663e164dece87bed4adfd3e28bab6cb1385"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["556a4aab886d75371b2af129d87be3c2795cea76"],"299a2348fa24151d150182211b6208a38e5e3450":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","79700663e164dece87bed4adfd3e28bab6cb1385"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"]},"commit2Childs":{"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["a485550d032df41f9ff97f4d97d81e2be011d3ca"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"556a4aab886d75371b2af129d87be3c2795cea76":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"3184874f7f3aca850248483485b4995343066875":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["556a4aab886d75371b2af129d87be3c2795cea76"],"a485550d032df41f9ff97f4d97d81e2be011d3ca":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3184874f7f3aca850248483485b4995343066875","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"79700663e164dece87bed4adfd3e28bab6cb1385":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ca792c26af46bd6c4a08d81117c60440cf6a7e3d","299a2348fa24151d150182211b6208a38e5e3450"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"299a2348fa24151d150182211b6208a38e5e3450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0a22eafe3f72a4c2945eaad9547e6c78816978f4","299a2348fa24151d150182211b6208a38e5e3450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}