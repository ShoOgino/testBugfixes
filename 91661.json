{"path":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException\n\t{\n\t\t\n    OpenBitSet bits=new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n\t\tTerm startTerm=new Term(fieldName);\n\t\tTermEnum te = reader.terms(startTerm);\n\t\tif(te!=null)\n\t\t{\n\t\t\tTerm currTerm=te.term();\n\t\t\twhile((currTerm!=null)&&(currTerm.field()==startTerm.field())) //term fieldnames are interned\n\t\t\t{\n\t\t\t\tint lastDoc=-1;\n\t\t\t\t//set non duplicates\n\t\t\t\tTermDocs td = reader.termDocs(currTerm);\n\t\t\t\tif(td.next())\n\t\t\t\t{\n\t\t\t\t\tif(keepMode==KM_USE_FIRST_OCCURRENCE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbits.set(td.doc());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlastDoc=td.doc();\n\t\t\t\t\t\t}while(td.next());\n\t\t\t\t\t\tbits.set(lastDoc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!te.next())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrTerm=te.term();\n\t\t\t}\n\t\t}\n\t\treturn bits;\n\t}\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException\n\t{\n\t\t\n    OpenBitSet bits=new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n\t\tTerm startTerm=new Term(fieldName);\n\t\tTermEnum te = reader.terms(startTerm);\n\t\tif(te!=null)\n\t\t{\n\t\t\tTerm currTerm=te.term();\n\t\t\twhile((currTerm!=null)&&(currTerm.field()==startTerm.field())) //term fieldnames are interned\n\t\t\t{\n\t\t\t\tint lastDoc=-1;\n\t\t\t\t//set non duplicates\n\t\t\t\tTermDocs td = reader.termDocs(currTerm);\n\t\t\t\tif(td.next())\n\t\t\t\t{\n\t\t\t\t\tif(keepMode==KM_USE_FIRST_OCCURRENCE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbits.set(td.doc());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlastDoc=td.doc();\n\t\t\t\t\t\t}while(td.next());\n\t\t\t\t\t\tbits.set(lastDoc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!te.next())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrTerm=te.term();\n\t\t\t}\n\t\t}\n\t\treturn bits;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != docs.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == docs.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException\n\t{\n\t\t\n    OpenBitSet bits=new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n\t\tTerm startTerm=new Term(fieldName);\n\t\tTermEnum te = reader.terms(startTerm);\n\t\tif(te!=null)\n\t\t{\n\t\t\tTerm currTerm=te.term();\n\t\t\twhile((currTerm!=null)&&(currTerm.field()==startTerm.field())) //term fieldnames are interned\n\t\t\t{\n\t\t\t\tint lastDoc=-1;\n\t\t\t\t//set non duplicates\n\t\t\t\tTermDocs td = reader.termDocs(currTerm);\n\t\t\t\tif(td.next())\n\t\t\t\t{\n\t\t\t\t\tif(keepMode==KM_USE_FIRST_OCCURRENCE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbits.set(td.doc());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlastDoc=td.doc();\n\t\t\t\t\t\t}while(td.next());\n\t\t\t\t\t\tbits.set(lastDoc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!te.next())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrTerm=te.term();\n\t\t\t}\n\t\t}\n\t\treturn bits;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != docs.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == docs.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != docs.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == docs.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != docs.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == docs.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits delDocs = MultiFields.getDeletedDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(delDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","date":1310403131,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private FixedBitSet correctBits(IndexReader reader) throws IOException {\n    FixedBitSet bits = new FixedBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private OpenBitSet correctBits(IndexReader reader) throws IOException {\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e141595402370bee958745de8b1c9de1fa182581","date":1310547892,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private FixedBitSet correctBits(IndexReader reader) throws IOException {\n    FixedBitSet bits = new FixedBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n\n    if (terms == null) {\n      return bits;\n    }\n\n    TermsEnum termsEnum = terms.iterator();\n    DocsEnum docs = null;\n    while (true) {\n      BytesRef currTerm = termsEnum.next();\n      if (currTerm == null) {\n        break;\n      } else {\n        docs = termsEnum.docs(liveDocs, docs);\n        int doc = docs.nextDoc();\n        if (doc != DocsEnum.NO_MORE_DOCS) {\n          if (keepMode == KeepMode.KM_USE_FIRST_OCCURRENCE) {\n            bits.set(doc);\n          } else {\n            int lastDoc = doc;\n            while (true) {\n              lastDoc = doc;\n              doc = docs.nextDoc();\n              if (doc == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n            }\n            bits.set(lastDoc);\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private FixedBitSet correctBits(IndexReader reader) throws IOException {\n    FixedBitSet bits = new FixedBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n    if (terms != null) {\n      TermsEnum termsEnum = terms.iterator();\n      DocsEnum docs = null;\n      while(true) {\n        BytesRef currTerm = termsEnum.next();\n        if (currTerm == null) {\n          break;\n        } else {\n          docs = termsEnum.docs(liveDocs, docs);\n          int doc = docs.nextDoc();\n          if (doc != DocsEnum.NO_MORE_DOCS) {\n            if (keepMode == KM_USE_FIRST_OCCURRENCE) {\n              bits.set(doc);\n            } else {\n              int lastDoc = doc;\n              while (true) {\n                lastDoc = doc;\n                doc = docs.nextDoc();\n                if (doc == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n              }\n              bits.set(lastDoc);\n            }\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f9f2355d68aab1348539f7a1603279405e566a4","date":1313634992,"type":5,"author":"Christopher John Male","isMerge":false,"pathNew":"modules/queries/src/java/org/apache/lucene/queries/DuplicateFilter#correctBits(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/DuplicateFilter#correctBits(IndexReader).mjava","sourceNew":"  private FixedBitSet correctBits(IndexReader reader) throws IOException {\n    FixedBitSet bits = new FixedBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n\n    if (terms == null) {\n      return bits;\n    }\n\n    TermsEnum termsEnum = terms.iterator();\n    DocsEnum docs = null;\n    while (true) {\n      BytesRef currTerm = termsEnum.next();\n      if (currTerm == null) {\n        break;\n      } else {\n        docs = termsEnum.docs(liveDocs, docs);\n        int doc = docs.nextDoc();\n        if (doc != DocsEnum.NO_MORE_DOCS) {\n          if (keepMode == KeepMode.KM_USE_FIRST_OCCURRENCE) {\n            bits.set(doc);\n          } else {\n            int lastDoc = doc;\n            while (true) {\n              lastDoc = doc;\n              doc = docs.nextDoc();\n              if (doc == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n            }\n            bits.set(lastDoc);\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","sourceOld":"  private FixedBitSet correctBits(IndexReader reader) throws IOException {\n    FixedBitSet bits = new FixedBitSet(reader.maxDoc()); //assume all are INvalid\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    Terms terms = reader.fields().terms(fieldName);\n\n    if (terms == null) {\n      return bits;\n    }\n\n    TermsEnum termsEnum = terms.iterator();\n    DocsEnum docs = null;\n    while (true) {\n      BytesRef currTerm = termsEnum.next();\n      if (currTerm == null) {\n        break;\n      } else {\n        docs = termsEnum.docs(liveDocs, docs);\n        int doc = docs.nextDoc();\n        if (doc != DocsEnum.NO_MORE_DOCS) {\n          if (keepMode == KeepMode.KM_USE_FIRST_OCCURRENCE) {\n            bits.set(doc);\n          } else {\n            int lastDoc = doc;\n            while (true) {\n              lastDoc = doc;\n              doc = docs.nextDoc();\n              if (doc == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n            }\n            bits.set(lastDoc);\n          }\n        }\n      }\n    }\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["2dadf0f3286a34a0fee6e788ffce88624bf2984e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e141595402370bee958745de8b1c9de1fa182581":["c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2dadf0f3286a34a0fee6e788ffce88624bf2984e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"1f9f2355d68aab1348539f7a1603279405e566a4":["e141595402370bee958745de8b1c9de1fa182581"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1f9f2355d68aab1348539f7a1603279405e566a4"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["29ef99d61cda9641b6250bf9567329a6e65f901d","2dadf0f3286a34a0fee6e788ffce88624bf2984e","868da859b43505d9d2a023bfeae6dd0c795f5295"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["e141595402370bee958745de8b1c9de1fa182581"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"e141595402370bee958745de8b1c9de1fa182581":["1f9f2355d68aab1348539f7a1603279405e566a4"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"1f9f2355d68aab1348539f7a1603279405e566a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}