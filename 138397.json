{"path":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438e995b4e32916f631722aab36254146830fefb","date":1328903827,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e13c725966e534614aa7fd9e2fc5c5639c71a666","date":1340207761,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    final int ITER = 9;\n\n    long lastDeleteTime = 0;\n    for(int i=0;i<ITER;i++) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      if (i < ITER-1) {\n        // Make sure to sleep long enough so that some commit\n        // points will be deleted:\n        Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n      }\n    }\n\n    // First, make sure the policy in fact deleted something:\n    assertTrue(\"no commits were deleted\", policy.numDelete > 0);\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47e1512544568a22b82c96169d466fae8a4b79e","date":1354519309,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.commit(commitData);\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.commit(commitData);\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70790b11e79a0366b21b2cc5b82d03b6fddcef81","date":1364594206,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    ExpirationTimeDeletionPolicy policy = new ExpirationTimeDeletionPolicy(dir, SECONDS);\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(policy);\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"088a7ef694fd43d5d9a4d200c4005865f773d1e7","date":1371136274,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    if (mp instanceof LogMergePolicy) {\n      ((LogMergePolicy) mp).setUseCompoundFile(true);\n    }\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setUseCompoundFile(true);\n      }\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = _TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<String,String>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<String,String>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.shutdown();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.shutdown();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.shutdown();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.shutdown();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.shutdown();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(TEST_VERSION_CURRENT,\n          new MockAnalyzer(random())).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.shutdown();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.shutdown();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.shutdown();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = new SegmentInfos();\n        sis.read(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f3189d15ef66702bbb45771403a68793d5cd137","date":1433872507,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFiles(Collections.singleton(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen)));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFiles(Collections.singleton(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen)));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    if (dir instanceof MockDirectoryWrapper) {\n      // test manually deletes files\n      ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n    }\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71e1a70f18d64b93db3ef618e606d6df5062f747","date":1466156390,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setLiveCommitData(commitData.entrySet());\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setLiveCommitData(commitData.entrySet());\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":["b47e1512544568a22b82c96169d466fae8a4b79e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setLiveCommitData(commitData.entrySet());\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setLiveCommitData(commitData.entrySet());\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setCommitData(commitData);\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setCommitData(commitData);\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDeletionPolicy#testExpirationTimeDeletionPolicy().mjava","sourceNew":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  // TODO: this wall-clock-dependent test doesn't seem to actually test any deletionpolicy logic?\n  @Nightly\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setLiveCommitData(commitData.entrySet());\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setLiveCommitData(commitData.entrySet());\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Test \"by time expiration\" deletion policy:\n   */\n  public void testExpirationTimeDeletionPolicy() throws IOException, InterruptedException {\n\n    final double SECONDS = 2.0;\n\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setIndexDeletionPolicy(new ExpirationTimeDeletionPolicy(dir, SECONDS));\n    MergePolicy mp = conf.getMergePolicy();\n    mp.setNoCFSRatio(1.0);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ExpirationTimeDeletionPolicy policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n    Map<String,String> commitData = new HashMap<>();\n    commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n    writer.setLiveCommitData(commitData.entrySet());\n    writer.commit();\n    writer.close();\n\n    long lastDeleteTime = 0;\n    final int targetNumDelete = TestUtil.nextInt(random(), 1, 5);\n    while (policy.numDelete < targetNumDelete) {\n      // Record last time when writer performed deletes of\n      // past commits\n      lastDeleteTime = System.currentTimeMillis();\n      conf = newIndexWriterConfig(new MockAnalyzer(random()))\n               .setOpenMode(OpenMode.APPEND)\n               .setIndexDeletionPolicy(policy);\n      mp = conf.getMergePolicy();\n      mp.setNoCFSRatio(1.0);\n      writer = new IndexWriter(dir, conf);\n      policy = (ExpirationTimeDeletionPolicy) writer.getConfig().getIndexDeletionPolicy();\n      for(int j=0;j<17;j++) {\n        addDoc(writer);\n      }\n      commitData = new HashMap<>();\n      commitData.put(\"commitTime\", String.valueOf(System.currentTimeMillis()));\n      writer.setLiveCommitData(commitData.entrySet());\n      writer.commit();\n      writer.close();\n\n      Thread.sleep((int) (1000.0*(SECONDS/5.0)));\n    }\n\n    // Then simplistic check: just verify that the\n    // segments_N's that still exist are in fact within SECONDS\n    // seconds of the last one's mod time, and, that I can\n    // open a reader on each:\n    long gen = SegmentInfos.getLastCommitGeneration(dir);\n    \n    String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                            \"\",\n                                                            gen);\n    boolean oneSecondResolution = true;\n\n    while(gen > 0) {\n      try {\n        IndexReader reader = DirectoryReader.open(dir);\n        reader.close();\n        fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                         \"\",\n                                                         gen);\n\n        // if we are on a filesystem that seems to have only\n        // 1 second resolution, allow +1 second in commit\n        // age tolerance:\n        SegmentInfos sis = SegmentInfos.readCommit(dir, fileName);\n        assertEquals(Version.LATEST, sis.getCommitLuceneVersion());\n        assertEquals(Version.LATEST, sis.getMinSegmentLuceneVersion());\n        long modTime = Long.parseLong(sis.getUserData().get(\"commitTime\"));\n        oneSecondResolution &= (modTime % 1000) == 0;\n        final long leeway = (long) ((SECONDS + (oneSecondResolution ? 1.0:0.0))*1000);\n\n        assertTrue(\"commit point was older than \" + SECONDS + \" seconds (\" + (lastDeleteTime - modTime) + \" msec) but did not get deleted \", lastDeleteTime - modTime <= leeway);\n      } catch (IOException e) {\n        // OK\n        break;\n      }\n      \n      dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n      gen--;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70790b11e79a0366b21b2cc5b82d03b6fddcef81":["b47e1512544568a22b82c96169d466fae8a4b79e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a207d19eac354d649c3f0e2cce070017c78125e":["8f3189d15ef66702bbb45771403a68793d5cd137","b470f36a9372c97283360b1304eacbde22df6c0d"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"8f3189d15ef66702bbb45771403a68793d5cd137":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f3189d15ef66702bbb45771403a68793d5cd137"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["5a207d19eac354d649c3f0e2cce070017c78125e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["8f3189d15ef66702bbb45771403a68793d5cd137","b470f36a9372c97283360b1304eacbde22df6c0d"],"407687e67faf6e1f02a211ca078d8e3eed631027":["e13c725966e534614aa7fd9e2fc5c5639c71a666","b47e1512544568a22b82c96169d466fae8a4b79e"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5a207d19eac354d649c3f0e2cce070017c78125e","71e1a70f18d64b93db3ef618e606d6df5062f747"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["70790b11e79a0366b21b2cc5b82d03b6fddcef81"],"b470f36a9372c97283360b1304eacbde22df6c0d":["8f3189d15ef66702bbb45771403a68793d5cd137","8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"e13c725966e534614aa7fd9e2fc5c5639c71a666":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"b47e1512544568a22b82c96169d466fae8a4b79e":["e13c725966e534614aa7fd9e2fc5c5639c71a666"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["46e4a8bdfbafda795ef9c39a2bc2d47095770299","3384e6013a93e4d11b7d75388693f8d0388602bf"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["438e995b4e32916f631722aab36254146830fefb"],"438e995b4e32916f631722aab36254146830fefb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"]},"commit2Childs":{"70790b11e79a0366b21b2cc5b82d03b6fddcef81":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["438e995b4e32916f631722aab36254146830fefb"],"5a207d19eac354d649c3f0e2cce070017c78125e":["71e1a70f18d64b93db3ef618e606d6df5062f747","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"8f3189d15ef66702bbb45771403a68793d5cd137":["5a207d19eac354d649c3f0e2cce070017c78125e","6bfe104fc023fadc9e709f8d17403d2cc61133fe","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["e13c725966e534614aa7fd9e2fc5c5639c71a666"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["b470f36a9372c97283360b1304eacbde22df6c0d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["3384e6013a93e4d11b7d75388693f8d0388602bf","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["6613659748fe4411a7dcf85266e55db1f95f7315"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"e13c725966e534614aa7fd9e2fc5c5639c71a666":["407687e67faf6e1f02a211ca078d8e3eed631027","b47e1512544568a22b82c96169d466fae8a4b79e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b47e1512544568a22b82c96169d466fae8a4b79e":["70790b11e79a0366b21b2cc5b82d03b6fddcef81","407687e67faf6e1f02a211ca078d8e3eed631027"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["8f3189d15ef66702bbb45771403a68793d5cd137"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"438e995b4e32916f631722aab36254146830fefb":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}