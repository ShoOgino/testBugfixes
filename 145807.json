{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","commits":[{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","date":1350576194,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.pos = arc.posArcsStart;\n        in.skip(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cbc4730743fac2e69e7d622848778d3ad9f2151","date":1502282443,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n\n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n      \n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f80bf2ed75034c50a0549f7a48aa0706ebb8f81","date":1560886096,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      if (arc.arcIdx == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label;\n        if (offset >= arc.numArcs) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          arc.nextArc = arc.posArcsStart - offset * arc.bytesPerArc;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n\n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal that the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      // Arcs are fixed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n\n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags((byte) FST.BIT_LAST_ARC);\n        } else {\n          arc.flags((byte) 0);\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc(follow.target());\n        }\n        arc.output(follow.nextFinalOutput());\n        arc.label(FST.END_LABEL);\n        return arc;\n      } else {\n        return null;\n      }\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          arc.nextArc(arc.posArcsStart() - offset * arc.bytesPerArc());\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx();\n      int mid = 0;\n      int high = arc.numArcs() - 1;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart());\n        in.skipBytes(arc.bytesPerArc() * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx(mid - 1);\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      arc.arcIdx(high + 1);\n      return fst.readNextRealArc(arc, in );\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      if (arc.arcIdx == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label;\n        if (offset >= arc.numArcs) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          arc.nextArc = arc.posArcsStart - offset * arc.bytesPerArc;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n\n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx();\n      int mid = 0;\n      int high = arc.numArcs() - 1;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart());\n        in.skipBytes(arc.bytesPerArc() * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          return fst.readArcByIndex(arc, in, mid);\n        }\n      }\n      if (low == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , high + 1);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags((byte) FST.BIT_LAST_ARC);\n        } else {\n          arc.flags((byte) 0);\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc(follow.target());\n        }\n        arc.output(follow.nextFinalOutput());\n        arc.label(FST.END_LABEL);\n        return arc;\n      } else {\n        return null;\n      }\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          arc.nextArc(arc.posArcsStart() - offset * arc.bytesPerArc());\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx();\n      int mid = 0;\n      int high = arc.numArcs() - 1;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart());\n        in.skipBytes(arc.bytesPerArc() * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx(mid - 1);\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      arc.arcIdx(high + 1);\n      return fst.readNextRealArc(arc, in );\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b115f25f829e48473723bb73c2c09e29f0a3ed0d","date":1564170556,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());\n        }\n      }\n      // Arcs are packed array -- use binary search to find the target.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx();\n      int mid = 0;\n      int high = arc.numArcs() - 1;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart());\n        in.skipBytes(arc.bytesPerArc() * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          return fst.readArcByIndex(arc, in, mid);\n        }\n      }\n      if (low == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , high + 1);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());\n        }\n      }\n      // Arcs are packed array -- use binary search to find the target.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow,\n      Arc<T> arc, BytesReader in) throws IOException {\n    // TODO maybe this is a useful in the FST class - we could simplify some other code like FSTEnum?\n    if (label == FST.END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = FST.BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = FST.END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc != 0 && arc.label != FST.END_LABEL) {\n      if (arc.arcIdx == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label;\n        if (offset >= arc.numArcs) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          arc.nextArc = arc.posArcsStart - offset * arc.bytesPerArc;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      // Arcs are packed array -- use binary search to find\n      // the target.\n\n      int low = arc.arcIdx;\n      int high = arc.numArcs - 1;\n      int mid = 0;\n      // System.out.println(\"do arc array low=\" + low + \" high=\" + high +\n      // \" targetLabel=\" + targetLabel);\n      while (low <= high) {\n        mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc * mid + 1);\n        final int midLabel = fst.readLabel(in);\n        final int cmp = midLabel - label;\n        // System.out.println(\"  cycle low=\" + low + \" high=\" + high + \" mid=\" +\n        // mid + \" midLabel=\" + midLabel + \" cmp=\" + cmp);\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          return fst.readNextRealArc(arc, in);\n        }\n      }\n      if (low == arc.numArcs) {\n        // DEAD END!\n        return null;\n      }\n\n      arc.arcIdx = (low > high ? high : low);\n      return fst.readNextRealArc(arc, in);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target, arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.nodeFlags() == FST.ARCS_FOR_DIRECT_ADDRESSING) {\n        // Fixed length arcs in a direct addressing node.\n        int targetIndex = label - arc.label();\n        if (targetIndex >= arc.numArcs()) {\n          return null;\n        } else if (targetIndex < 0) {\n          return arc;\n        } else {\n          if (arc.bitTable().isBitSet(targetIndex)) {\n            fst.readArcByDirectAddressing(arc, in, targetIndex);\n            assert arc.label() == label;\n          } else {\n            int ceilIndex = arc.bitTable().nextBitSet(targetIndex);\n            assert ceilIndex != -1;\n            fst.readArcByDirectAddressing(arc, in, ceilIndex);\n            assert arc.label() > label;\n          }\n          return arc;\n        }\n      }\n      // Fixed length arcs in a binary search node.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Variable length arcs in a linear scan list,\n    // or special arc with label == FST.END_LABEL.\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.arcIdx() == Integer.MIN_VALUE) {\n        // Arcs are in an array-with-gaps\n        int offset = label - arc.label();\n        if (offset >= arc.numArcs()) {\n          return null;\n        } else if (offset < 0) {\n          return arc;\n        } else {\n          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());\n        }\n      }\n      // Arcs are packed array -- use binary search to find the target.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Linear scan\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06086b5bd0f0d57858f0675becc58edf1f6b7c11","date":1586421397,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_readCeilArc(int,FST[T],Arc[T],Arc[T],BytesReader).mjava","sourceNew":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.nodeFlags() == FST.ARCS_FOR_DIRECT_ADDRESSING) {\n        // Fixed length arcs in a direct addressing node.\n        int targetIndex = label - arc.label();\n        if (targetIndex >= arc.numArcs()) {\n          return null;\n        } else if (targetIndex < 0) {\n          return arc;\n        } else {\n          if (BitTable.isBitSet(targetIndex, arc, in)) {\n            fst.readArcByDirectAddressing(arc, in, targetIndex);\n            assert arc.label() == label;\n          } else {\n            int ceilIndex = BitTable.nextBitSet(targetIndex, arc, in);\n            assert ceilIndex != -1;\n            fst.readArcByDirectAddressing(arc, in, ceilIndex);\n            assert arc.label() > label;\n          }\n          return arc;\n        }\n      }\n      // Fixed length arcs in a binary search node.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Variable length arcs in a linear scan list,\n    // or special arc with label == FST.END_LABEL.\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the first arc greater or equal than the given label into the provided\n   * arc in place and returns it iff found, otherwise return <code>null</code>.\n   * \n   * @param label the label to ceil on\n   * @param fst the fst to operate on\n   * @param follow the arc to follow reading the label from\n   * @param arc the arc to read into in place\n   * @param in the fst's {@link BytesReader}\n   */\n  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {\n    if (label == FST.END_LABEL) {\n      return FST.readEndArc(follow, arc);\n    }\n    if (!FST.targetHasArcs(follow)) {\n      return null;\n    }\n    fst.readFirstTargetArc(follow, arc, in);\n    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {\n      if (arc.nodeFlags() == FST.ARCS_FOR_DIRECT_ADDRESSING) {\n        // Fixed length arcs in a direct addressing node.\n        int targetIndex = label - arc.label();\n        if (targetIndex >= arc.numArcs()) {\n          return null;\n        } else if (targetIndex < 0) {\n          return arc;\n        } else {\n          if (arc.bitTable().isBitSet(targetIndex)) {\n            fst.readArcByDirectAddressing(arc, in, targetIndex);\n            assert arc.label() == label;\n          } else {\n            int ceilIndex = arc.bitTable().nextBitSet(targetIndex);\n            assert ceilIndex != -1;\n            fst.readArcByDirectAddressing(arc, in, ceilIndex);\n            assert arc.label() > label;\n          }\n          return arc;\n        }\n      }\n      // Fixed length arcs in a binary search node.\n      int idx = binarySearch(fst, arc, label);\n      if (idx >= 0) {\n        return fst.readArcByIndex(arc, in, idx);\n      }\n      idx = -1 - idx;\n      if (idx == arc.numArcs()) {\n        // DEAD END!\n        return null;\n      }\n      return fst.readArcByIndex(arc, in , idx);\n    }\n\n    // Variable length arcs in a linear scan list,\n    // or special arc with label == FST.END_LABEL.\n    fst.readFirstRealTargetArc(follow.target(), arc, in);\n\n    while (true) {\n      // System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() >= label) {\n        // System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        fst.readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":["71d31a7d5773508492505519bb5230b87c8937ad"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b115f25f829e48473723bb73c2c09e29f0a3ed0d":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"71d31a7d5773508492505519bb5230b87c8937ad":["b115f25f829e48473723bb73c2c09e29f0a3ed0d"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["9cbc4730743fac2e69e7d622848778d3ad9f2151"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"f8061ddd97f3352007d927dae445884a6f3d857b":["4f80bf2ed75034c50a0549f7a48aa0706ebb8f81","b115f25f829e48473723bb73c2c09e29f0a3ed0d"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["4f80bf2ed75034c50a0549f7a48aa0706ebb8f81"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"cc41b743423981e7ec17a024ce7e107096e472fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["71d31a7d5773508492505519bb5230b87c8937ad"],"4f80bf2ed75034c50a0549f7a48aa0706ebb8f81":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"]},"commit2Childs":{"b115f25f829e48473723bb73c2c09e29f0a3ed0d":["71d31a7d5773508492505519bb5230b87c8937ad","f8061ddd97f3352007d927dae445884a6f3d857b"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["ae67e1f82a53594208ca929f382ee861dad3d7a8","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["b115f25f829e48473723bb73c2c09e29f0a3ed0d"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["8917bfede3b4ca30f4305c1e391e9218959cd723","9cbc4730743fac2e69e7d622848778d3ad9f2151","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"71d31a7d5773508492505519bb5230b87c8937ad":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["4f80bf2ed75034c50a0549f7a48aa0706ebb8f81"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"cc41b743423981e7ec17a024ce7e107096e472fe":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"4f80bf2ed75034c50a0549f7a48aa0706ebb8f81":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","f8061ddd97f3352007d927dae445884a6f3d857b","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}