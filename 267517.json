{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","commits":[{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"352763be0465236f8e2ac188aa1b761cb3e1c9ee","date":1337516554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ace9b78896617dcee984890f3300d45c539c1b15","date":1337655022,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4356000e349e38c9fb48034695b7c309abd54557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["4356000e349e38c9fb48034695b7c309abd54557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ace9b78896617dcee984890f3300d45c539c1b15":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"4356000e349e38c9fb48034695b7c309abd54557":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["ace9b78896617dcee984890f3300d45c539c1b15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4356000e349e38c9fb48034695b7c309abd54557","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ace9b78896617dcee984890f3300d45c539c1b15":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ace9b78896617dcee984890f3300d45c539c1b15","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}