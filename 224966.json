{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#testUpdatingFieldNotPresentInDoc().mjava","commits":[{"id":"9c14208216474e190dcec6327766fd749b8aa965","date":1563380115,"type":0,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#testUpdatingFieldNotPresentInDoc().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testUpdatingFieldNotPresentInDoc() throws Exception {\n    long version1 = addAndGetVersion(sdoc(\"id\", \"1\", \"title_s\", \"first\"), null);\n    long version2 = addAndGetVersion(sdoc(\"id\", \"2\", \"title_s\", \"second\"), null);\n    long version3 = addAndGetVersion(sdoc(\"id\", \"3\", \"title_s\", \"third\"), null);\n    assertU(commit(\"softCommit\", \"false\"));\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='3']\");\n\n    // subsequent updates shouldn't cause docid changes\n    int docid1 = getDocId(\"1\");\n    int docid2 = getDocId(\"2\");\n    int docid3 = getDocId(\"3\");\n\n    // updating fields which are not present in the document\n    // tests both set and inc with different fields\n    version1 = addAndAssertVersion(version1, \"id\", \"1\", \"inplace_updatable_float\", map(\"set\", 200));\n    version2 = addAndAssertVersion(version2, \"id\", \"2\", \"inplace_updatable_float\", map(\"inc\", 100));\n    version3 = addAndAssertVersion(version3, \"id\", \"3\", \"inplace_updatable_float\", map(\"set\", 300));\n    version1 = addAndAssertVersion(version1, \"id\", \"1\", \"inplace_updatable_int\", map(\"set\", 300));\n    assertU(commit(\"softCommit\", \"false\"));\n\n    assertQ(req(\"q\", \"*:*\", \"sort\", \"id asc\", \"fl\", \"*,[docid]\"),\n        \"//*[@numFound='3']\",\n        \"//result/doc[1]/float[@name='inplace_updatable_float'][.='200.0']\",\n        \"//result/doc[1]/int[@name='inplace_updatable_int'][.='300']\",\n        \"//result/doc[2]/float[@name='inplace_updatable_float'][.='100.0']\",\n        \"//result/doc[3]/float[@name='inplace_updatable_float'][.='300.0']\",\n        \"//result/doc[1]/long[@name='_version_'][.='\"+version1+\"']\",\n        \"//result/doc[2]/long[@name='_version_'][.='\"+version2+\"']\",\n        \"//result/doc[3]/long[@name='_version_'][.='\"+version3+\"']\",\n        \"//result/doc[1]/int[@name='[docid]'][.='\"+docid1+\"']\",\n        \"//result/doc[2]/int[@name='[docid]'][.='\"+docid2+\"']\",\n        \"//result/doc[3]/int[@name='[docid]'][.='\"+docid3+\"']\"\n    );\n\n    // adding new field which is not present in any docs but matches dynamic field rule\n    // and satisfies inplace condition should be treated as inplace update\n    version1 = addAndAssertVersion(version1, \"id\", \"1\", \"inplace_updatable_i_dvo\", map(\"set\", 200));\n    assertU(commit(\"softCommit\", \"false\"));\n    assertQ(req(\"q\", \"id:1\", \"sort\", \"id asc\", \"fl\", \"*,[docid]\"),\n        \"//*[@numFound='1']\",\n        \"//result/doc[1]/float[@name='inplace_updatable_float'][.='200.0']\",\n        \"//result/doc[1]/int[@name='inplace_updatable_int'][.='300']\",\n        \"//result/doc[1]/int[@name='[docid]'][.='\"+docid1+\"']\",\n        \"//result/doc[1]/int[@name='inplace_updatable_i_dvo'][.='200']\"\n        );\n\n    // delete everything\n    deleteAllAndCommit();\n\n    // test for document with child documents\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    doc.setField(\"title_s\", \"parent\");\n\n    SolrInputDocument child1 = new SolrInputDocument();\n    child1.setField(\"id\", \"1_1\");\n    child1.setField(\"title_s\", \"child1\");\n    SolrInputDocument child2 = new SolrInputDocument();\n    child2.setField(\"id\", \"1_2\");\n    child2.setField(\"title_s\", \"child2\");\n\n    doc.addChildDocument(child1);\n    doc.addChildDocument(child2);\n    long version = addAndGetVersion(doc, null);\n    assertU(commit(\"softCommit\", \"false\"));\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='3']\");\n\n    int parentDocId = getDocId(\"1\");\n    int childDocid1 = getDocId(\"1_1\");\n    int childDocid2 = getDocId(\"1_2\");\n    version = addAndAssertVersion(version, \"id\", \"1\", \"inplace_updatable_float\", map(\"set\", 200));\n    version = addAndAssertVersion(version, \"id\", \"1\", \"inplace_updatable_int\", map(\"inc\", 300));\n    assertU(commit(\"softCommit\", \"false\"));\n\n    // first child docs would be returned followed by parent doc\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"*,[docid]\"),\n        \"//*[@numFound='3']\",\n        \"//result/doc[3]/float[@name='inplace_updatable_float'][.='200.0']\",\n        \"//result/doc[3]/int[@name='inplace_updatable_int'][.='300']\",\n        \"//result/doc[3]/int[@name='[docid]'][.='\"+parentDocId+\"']\",\n        \"//result/doc[1]/int[@name='[docid]'][.='\"+childDocid1+\"']\",\n        \"//result/doc[2]/int[@name='[docid]'][.='\"+childDocid2+\"']\"\n    );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c14208216474e190dcec6327766fd749b8aa965":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9c14208216474e190dcec6327766fd749b8aa965"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9c14208216474e190dcec6327766fd749b8aa965"],"9c14208216474e190dcec6327766fd749b8aa965":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}