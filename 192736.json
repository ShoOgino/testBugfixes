{"path":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","commits":[{"id":"81d505b8f51b856e1b7e9dd377f5050c337b797a","date":1549455307,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    System.out.println(\"MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    System.out.println(\"SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n\n    Function<String, Long> originalDiskSpaceprovider = IndexFetcher.usableDiskSpaceProvider;\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n    QueryResponse response;\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicBoolean searchDisabledFound = new AtomicBoolean(false);\n    try {\n      IndexFetcher.testWait = new BooleanSupplier() {\n        @Override\n        public boolean getAsBoolean() {\n          try {\n            latch.await(5, TimeUnit.SECONDS);\n          } catch (InterruptedException e) {\n\n          }\n          return true;\n        }\n      };\n\n\n      new Thread(() -> {\n        for (int i = 0; i < 20; i++) {\n          try {\n            QueryResponse rsp = slaveClient.query(new SolrQuery()\n                .setQuery(\"*:*\")\n                .setRows(0));\n            Thread.sleep(100);\n          } catch (Exception e) {\n            if (e.getMessage().contains(\"Search is temporarily disabled\")) {\n              searchDisabledFound.set(true);\n            }\n            latch.countDown();\n            break;\n          }\n        }\n      }).start();\n\n      response = slaveClient.query(new SolrQuery()\n          .add(\"qt\", \"/replication\")\n          .add(\"command\", CMD_FETCH_INDEX)\n          .add(\"wait\", \"true\")\n      );\n\n    } finally {\n      IndexFetcher.usableDiskSpaceProvider = originalDiskSpaceprovider;\n    }\n    assertTrue(searchDisabledFound.get());\n    assertEquals(\"OK\", response._getStr(\"status\", null));\n//    System.out.println(\"MASTER INDEX: \" + szMaster);\n//    System.out.println(\"SLAVE INDEX: \" + szSlave);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    System.out.println(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70b3bea444e51dc899f419dca7510a1cf3c6d419","date":1557866119,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              // TODO: SOLR-13469: why is this FORBIDDEN(403) and not SERVICE_UNAVAILABLE(503)\n              if (e.code() == SolrException.ErrorCode.FORBIDDEN.code\n                  // TODO: // && e.getMessage().contains(expectedErr) // why is this not always set?\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    log.info(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    System.out.println(\"MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    System.out.println(\"SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n\n    Function<String, Long> originalDiskSpaceprovider = IndexFetcher.usableDiskSpaceProvider;\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n    QueryResponse response;\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicBoolean searchDisabledFound = new AtomicBoolean(false);\n    try {\n      IndexFetcher.testWait = new BooleanSupplier() {\n        @Override\n        public boolean getAsBoolean() {\n          try {\n            latch.await(5, TimeUnit.SECONDS);\n          } catch (InterruptedException e) {\n\n          }\n          return true;\n        }\n      };\n\n\n      new Thread(() -> {\n        for (int i = 0; i < 20; i++) {\n          try {\n            QueryResponse rsp = slaveClient.query(new SolrQuery()\n                .setQuery(\"*:*\")\n                .setRows(0));\n            Thread.sleep(100);\n          } catch (Exception e) {\n            if (e.getMessage().contains(\"Search is temporarily disabled\")) {\n              searchDisabledFound.set(true);\n            }\n            latch.countDown();\n            break;\n          }\n        }\n      }).start();\n\n      response = slaveClient.query(new SolrQuery()\n          .add(\"qt\", \"/replication\")\n          .add(\"command\", CMD_FETCH_INDEX)\n          .add(\"wait\", \"true\")\n      );\n\n    } finally {\n      IndexFetcher.usableDiskSpaceProvider = originalDiskSpaceprovider;\n    }\n    assertTrue(searchDisabledFound.get());\n    assertEquals(\"OK\", response._getStr(\"status\", null));\n//    System.out.println(\"MASTER INDEX: \" + szMaster);\n//    System.out.println(\"SLAVE INDEX: \" + szSlave);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    System.out.println(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","bugFix":null,"bugIntro":["3fc55735df93d56525bef197403d867c1fe93fe7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3fc55735df93d56525bef197403d867c1fe93fe7","date":1558373042,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    log.info(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              // TODO: SOLR-13469: why is this FORBIDDEN(403) and not SERVICE_UNAVAILABLE(503)\n              if (e.code() == SolrException.ErrorCode.FORBIDDEN.code\n                  // TODO: // && e.getMessage().contains(expectedErr) // why is this not always set?\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    log.info(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","bugFix":["70b3bea444e51dc899f419dca7510a1cf3c6d419"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    if (log.isInfoEnabled()) {\n      log.info(\"DETAILS {}\", Utils.writeJson(response, new StringWriter(), true).toString());\n    }\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    log.info(\"DETAILS\" + Utils.writeJson(response, new StringWriter(), true).toString());\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.emptyList(), threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    if (log.isInfoEnabled()) {\n      log.info(\"DETAILS {}\", Utils.writeJson(response, new StringWriter(), true).toString());\n    }\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.EMPTY_LIST, threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    if (log.isInfoEnabled()) {\n      log.info(\"DETAILS {}\", Utils.writeJson(response, new StringWriter(), true).toString());\n    }\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerDiskOverFlow#testDiskOverFlow().mjava","sourceNew":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(followerJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to LEADER\");\n    int docsInLeader = 1000;\n    long szLeader = indexDocs(leaderClient, docsInLeader, 0);\n    log.info(\"Indexing to FOLLOWER\");\n    long szFollower = indexDocs(followerClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szLeader;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = followerClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = followerClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.emptyList(), threadFailures);\n\n    response = followerClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in follower\", docsInLeader, response.getResults().getNumFound());\n\n    response = followerClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    if (log.isInfoEnabled()) {\n      log.info(\"DETAILS {}\", Utils.writeJson(response, new StringWriter(), true).toString());\n    }\n    assertEquals(\"follower's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/follower/clearedLocalIndexFirst\", null));\n  }\n\n","sourceOld":"  @Test\n  public void testDiskOverFlow() throws Exception {\n    invokeReplicationCommand(slaveJetty.getLocalPort(), \"disablepoll\");\n    //index docs\n    log.info(\"Indexing to MASTER\");\n    int docsInMaster = 1000;\n    long szMaster = indexDocs(masterClient, docsInMaster, 0);\n    log.info(\"Indexing to SLAVE\");\n    long szSlave = indexDocs(slaveClient, 1200, 1000);\n\n    IndexFetcher.usableDiskSpaceProvider = new Function<String, Long>() {\n      @Override\n      public Long apply(String s) {\n        return szMaster;\n      }\n    };\n\n    // we don't need/want the barrier to be cyclic, so we use a ref that our barrier action will null\n    // out to prevent it from being triggered multiple times (which shouldn't happen anyway)\n    final AtomicReference<CyclicBarrier> commonBarrier = new AtomicReference<>();\n    commonBarrier.set(new CyclicBarrier(2, () -> { commonBarrier.set(null); }));\n    \n    final List<Throwable> threadFailures = new ArrayList<>(7);\n    \n    IndexFetcher.testWait = new BooleanSupplier() {\n      @Override\n      public boolean getAsBoolean() {\n        try {\n          final CyclicBarrier barrier = commonBarrier.get();\n          if (null != barrier) {\n            barrier.await(60, TimeUnit.SECONDS);\n          }\n        } catch (Exception e) {\n          log.error(\"IndexFetcher Thread Failure\", e);\n          threadFailures.add(e);\n        }\n        return true;\n      }\n    };\n    \n    new Thread(() -> {\n        try {\n          for (int i = 0; i < 100; i++) {\n            final CyclicBarrier barrier = commonBarrier.get();\n            assertNotNull(\"why is query thread still looping if barrier has already been cleared?\",\n                          barrier);\n            try {\n              QueryResponse rsp = slaveClient.query(new SolrQuery()\n                                                    .setQuery(\"*:*\")\n                                                    .setRows(0));\n              Thread.sleep(200);\n            } catch (SolrException e) {\n              if (e.code() == SolrException.ErrorCode.SERVICE_UNAVAILABLE.code\n                  && e.getMessage().contains(expectedErr)\n                  ) { \n                log.info(\"Got expected exception\", e);\n                // now let the barrier complete & clear itself, and we're done\n                barrier.await(60, TimeUnit.SECONDS);\n                return; // break out\n              }\n              // else...\n              // not our expected exception, re-throw to fail fast...\n              throw e;\n            }\n          }\n          // if we made it this far, something is wrong...\n          throw new RuntimeException(\"Query thread gave up waiting for expected error: \" + expectedErr);\n        } catch (Exception e) {\n          log.error(\"Query Thread Failure\", e);\n          threadFailures.add(e);\n        }\n      }).start();\n\n    QueryResponse response = slaveClient.query(new SolrQuery()\n                                               .add(\"qt\", \"/replication\")\n                                               .add(\"command\", CMD_FETCH_INDEX)\n                                               .add(\"wait\", \"true\")\n                                               );\n    assertEquals(\"Replication command status\",\n                 \"OK\", response._getStr(\"status\", null));\n    \n    assertEquals(\"threads encountered failures (see logs for when)\",\n                 Collections.emptyList(), threadFailures);\n\n    response = slaveClient.query(new SolrQuery().setQuery(\"*:*\").setRows(0));\n    assertEquals(\"docs in slave\", docsInMaster, response.getResults().getNumFound());\n\n    response = slaveClient.query(new SolrQuery()\n        .add(\"qt\", \"/replication\")\n        .add(\"command\", ReplicationHandler.CMD_DETAILS)\n    );\n    if (log.isInfoEnabled()) {\n      log.info(\"DETAILS {}\", Utils.writeJson(response, new StringWriter(), true).toString());\n    }\n    assertEquals(\"slave's clearedLocalIndexFirst (from rep details)\",\n                 \"true\", response._getStr(\"details/slave/clearedLocalIndexFirst\", null));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["3adc4d119a7deba35b2721853853464857d9d0a9"],"3adc4d119a7deba35b2721853853464857d9d0a9":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"70b3bea444e51dc899f419dca7510a1cf3c6d419":["81d505b8f51b856e1b7e9dd377f5050c337b797a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3fc55735df93d56525bef197403d867c1fe93fe7":["70b3bea444e51dc899f419dca7510a1cf3c6d419"],"81d505b8f51b856e1b7e9dd377f5050c337b797a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3fc55735df93d56525bef197403d867c1fe93fe7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3adc4d119a7deba35b2721853853464857d9d0a9":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"70b3bea444e51dc899f419dca7510a1cf3c6d419":["3fc55735df93d56525bef197403d867c1fe93fe7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["81d505b8f51b856e1b7e9dd377f5050c337b797a"],"3fc55735df93d56525bef197403d867c1fe93fe7":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"81d505b8f51b856e1b7e9dd377f5050c337b797a":["70b3bea444e51dc899f419dca7510a1cf3c6d419"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3adc4d119a7deba35b2721853853464857d9d0a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}