{"path":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","commits":[{"id":"22859cb40e09867e7da8de84a31956c07259f82f","date":1441822065,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"/dev/null","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    SolrDispatchFilter filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    ZkController zkController = filter.getCores().getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n    filter = (SolrDispatchFilter) notLeader.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3e0300d1df37d7e9662d491269e91b6f66dca8bd","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e0300d1df37d7e9662d491269e91b6f66dca8bd","date":1443011762,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    SolrDispatchFilter filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    ZkController zkController = filter.getCores().getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n    \n    filter = (SolrDispatchFilter) notLeader.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, filter.getCores().getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, filter.getCores().getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    SolrDispatchFilter filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    ZkController zkController = filter.getCores().getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n    filter = (SolrDispatchFilter) notLeader.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, leaderCoreNodeName);\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":["22859cb40e09867e7da8de84a31956c07259f82f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1088b72b3b4cc45316b7595bd09023c859cd2327","date":1447150009,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    SolrDispatchFilter filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    ZkController zkController = filter.getCores().getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n    \n    filter = (SolrDispatchFilter) notLeader.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, filter.getCores().getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    filter = (SolrDispatchFilter) leaderRunner.jetty.getDispatchFilter().getFilter();\n    zkController = filter.getCores().getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, filter.getCores(),\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, filter.getCores().getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      cloudClient.getZkStateReader().updateClusterState();\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":["22859cb40e09867e7da8de84a31956c07259f82f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getReplica(DEFAULT_COLLECTION, replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c9595c75582a7ea7efb585014102ed83f2d9c8b","date":1523581112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b87d1f8719d7f05be003f3477450b74af13706a","date":1523590376,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    CoreContainer coreContainer = leaderRunner.jetty.getCoreContainer();\n    ZkController zkController = coreContainer.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n    try {\n      \n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n      fail(\"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\");\n    } catch (SolrException e) {\n      assertTrue(e.code() == SolrException.ErrorCode.INVALID_STATE.code);\n    }\n\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    coreContainer = notLeader.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        try {\n          super.updateLIRState(replicaCoreNodeName);\n        } catch (Exception e) {\n          assertTrue(e instanceof ZkController.NotLeaderException);\n          throw e;\n        }\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    coreContainer = leaderRunner.jetty.getCoreContainer();\n    zkController = coreContainer.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController, coreContainer,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdc53359111a5e3782f56300070ab2878ec82cb9","date":1534542016,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  @Test\n  //17-Aug-2018 commented @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cba13865da71de3b9b0937fcbc66d726089356d","date":1537507909,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":"  @Test\n  //17-Aug-2018 commented @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Sep-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","sourceOld":"  @Test\n  //17-Aug-2018 commented @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderInitiatedRecoveryThread#testPublishDownState().mjava","sourceNew":null,"sourceOld":"  @Test\n  //17-Aug-2018 commented @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Sep-2018\n  public void testPublishDownState() throws Exception {\n    waitForRecoveriesToFinish(true);\n\n    final String leaderCoreNodeName = shardToLeaderJetty.get(SHARD1).coreNodeName;\n    final CloudJettyRunner leaderRunner = shardToLeaderJetty.get(SHARD1);\n    final CoreContainer coreContainer1 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController1 = coreContainer1.getZkController();\n\n    CloudJettyRunner notLeader = null;\n    for (CloudJettyRunner cloudJettyRunner : shardToJetty.get(SHARD1)) {\n      if (cloudJettyRunner != leaderRunner) {\n        notLeader = cloudJettyRunner;\n        break;\n      }\n    }\n    assertNotNull(notLeader);\n    Replica replica = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(notLeader.coreNodeName);\n    ZkCoreNodeProps replicaCoreNodeProps = new ZkCoreNodeProps(replica);\n    \n    MockCoreDescriptor cd = new MockCoreDescriptor() {\n      public CloudDescriptor getCloudDescriptor() {\n        return new CloudDescriptor(shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NAME_PROP), new Properties(), this) {\n          @Override\n          public String getCoreNodeName() {\n            return shardToLeaderJetty.get(SHARD1).info.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n          }\n          @Override\n          public boolean isLeader() {\n            return true;\n          }\n        };\n      }\n    };\n\n    /*\n     1. Test that publishDownState throws exception when zkController.isReplicaInRecoveryHandling == false\n      */\n\n    SolrException e = expectThrows(SolrException.class,\n        \"publishDownState should not have succeeded because replica url is not marked in leader initiated recovery in ZkController\",\n        () -> {\n      LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n          DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n      assertFalse(zkController1.isReplicaInRecoveryHandling(replicaCoreNodeProps.getCoreUrl()));\n      thread.run();\n    });\n    assertEquals(e.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n    /*\n     2. Test that a non-live replica cannot be put into LIR or down state\n      */\n    LeaderInitiatedRecoveryThread thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd);\n    // kill the replica\n    int children = cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size();\n    ChaosMonkey.stop(notLeader.jetty);\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      if (children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size()) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertTrue(children > cloudClient.getZkStateReader().getZkClient().getChildren(\"/live_nodes\", null, true).size());\n\n    int cversion = getOverseerCversion();\n    // Thread should not publish LIR and down state for node which is not live, regardless of whether forcePublish is true or false\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // lets assert that we did not publish anything to overseer queue\n    assertEquals(cversion, getOverseerCversion());\n\n\n    /*\n    3. Test that if ZK connection loss then thread should not attempt to publish down state even if forcePublish=true\n     */\n    ChaosMonkey.start(notLeader.jetty);\n    waitForRecoveriesToFinish(true);\n\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.ConnectionLossException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     4. Test that if ZK connection loss or session expired then thread should not attempt to publish down state even if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"\", new KeeperException.SessionExpiredException());\n      }\n    };\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n\n    /*\n     5. Test that any exception other then ZK connection loss or session expired should publish down state only if forcePublish=true\n      */\n    thread = new LeaderInitiatedRecoveryThread(zkController1, coreContainer1,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, cd) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"bogus exception\");\n      }\n    };\n    // the following should return true because regardless of the bogus exception in setting LIR state, we still want recovery commands to be sent,\n    // however the following will not publish a down state\n    cversion = getOverseerCversion();\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n\n    // lets assert that we did not publish anything to overseer queue, simplest way is to assert that cversion of overseer queue zk node is still the same\n    assertEquals(cversion, getOverseerCversion());\n\n    assertTrue(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), true));\n    // this should have published a down state so assert that cversion has incremented\n    assertTrue(getOverseerCversion() > cversion);\n\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica r = cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName());\n      if (r.getState() == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n\n    assertNull(zkController1.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getReplica(replica.getName()).getState());\n\n    /*\n    6. Test that non-leader cannot set LIR nodes\n     */\n\n    final CoreContainer coreContainer2 = notLeader.jetty.getCoreContainer();\n    final ZkController zkController2 = coreContainer2.getZkController();\n\n    thread = new LeaderInitiatedRecoveryThread(zkController2, coreContainer2,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer2.getCores().iterator().next().getCoreDescriptor()) {\n      @Override\n      protected void updateLIRState(String replicaCoreNodeName) {\n        throw expectThrows(ZkController.NotLeaderException.class, () -> super.updateLIRState(replicaCoreNodeName));\n      }\n    };\n    cversion = getOverseerCversion();\n    assertFalse(thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false));\n    assertEquals(cversion, getOverseerCversion());\n\n    /*\n     7. assert that we can write a LIR state if everything else is fine\n      */\n    // reset the zkcontroller to the one from the leader\n    final CoreContainer coreContainer3 = leaderRunner.jetty.getCoreContainer();\n    final ZkController zkController3 = coreContainer3.getZkController();\n    thread = new LeaderInitiatedRecoveryThread(zkController3, coreContainer3,\n        DEFAULT_COLLECTION, SHARD1, replicaCoreNodeProps, 1, coreContainer3.getCores().iterator().next().getCoreDescriptor());\n    thread.publishDownState(replicaCoreNodeProps.getCoreName(), replica.getName(), replica.getNodeName(), replicaCoreNodeProps.getCoreUrl(), false);\n    timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica.State state = zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName());\n      if (state == Replica.State.DOWN) {\n        break;\n      }\n      Thread.sleep(500);\n    }\n    assertNotNull(zkController3.getLeaderInitiatedRecoveryStateObject(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n    assertEquals(Replica.State.DOWN, zkController3.getLeaderInitiatedRecoveryState(DEFAULT_COLLECTION, SHARD1, replica.getName()));\n\n    /*\n    7. Test that\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["22859cb40e09867e7da8de84a31956c07259f82f"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"344b0840364d990b29b97467bfcc766ff8325d11":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"cdc53359111a5e3782f56300070ab2878ec82cb9":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["4cba13865da71de3b9b0937fcbc66d726089356d"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"22859cb40e09867e7da8de84a31956c07259f82f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","344b0840364d990b29b97467bfcc766ff8325d11"],"1088b72b3b4cc45316b7595bd09023c859cd2327":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b87d1f8719d7f05be003f3477450b74af13706a":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","3c9595c75582a7ea7efb585014102ed83f2d9c8b"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["6b87d1f8719d7f05be003f3477450b74af13706a"],"4cba13865da71de3b9b0937fcbc66d726089356d":["cdc53359111a5e3782f56300070ab2878ec82cb9"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["344b0840364d990b29b97467bfcc766ff8325d11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"]},"commit2Childs":{"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["6b87d1f8719d7f05be003f3477450b74af13706a"],"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cdc53359111a5e3782f56300070ab2878ec82cb9":["4cba13865da71de3b9b0937fcbc66d726089356d"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["344b0840364d990b29b97467bfcc766ff8325d11","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"22859cb40e09867e7da8de84a31956c07259f82f":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"1088b72b3b4cc45316b7595bd09023c859cd2327":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22859cb40e09867e7da8de84a31956c07259f82f"],"6b87d1f8719d7f05be003f3477450b74af13706a":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["cdc53359111a5e3782f56300070ab2878ec82cb9"],"4cba13865da71de3b9b0937fcbc66d726089356d":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["3c9595c75582a7ea7efb585014102ed83f2d9c8b","6b87d1f8719d7f05be003f3477450b74af13706a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}