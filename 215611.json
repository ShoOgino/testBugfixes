{"path":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","commits":[{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":0,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09bee0b4882762434fd0b5095fc34ee6058442e1","date":1569398789,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":5,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold, int maxDocs) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd320327ef03681a94238b48abfe570f0fdd7387","date":1571660290,"type":1,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold, int maxDocs) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60a97329527e682292497dd2f6fae1c519840bae","date":1587668642,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#createSharedManager(int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(Math.max(totalHitsThreshold, numHits));\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments\n   */\n  public static CollectorManager<TopScoreDocCollector, TopDocs> createSharedManager(int numHits, FieldDoc after,\n                                                                                      int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, numHits, topDocs);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"807314aa41c10866aec273a0e54fd0d24d8971de":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["09bee0b4882762434fd0b5095fc34ee6058442e1","cd320327ef03681a94238b48abfe570f0fdd7387"],"60a97329527e682292497dd2f6fae1c519840bae":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd320327ef03681a94238b48abfe570f0fdd7387":["807314aa41c10866aec273a0e54fd0d24d8971de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60a97329527e682292497dd2f6fae1c519840bae"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["e19eef45a852c3316ae52fdf941731448ece967a"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"807314aa41c10866aec273a0e54fd0d24d8971de":["cd320327ef03681a94238b48abfe570f0fdd7387"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["60a97329527e682292497dd2f6fae1c519840bae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e19eef45a852c3316ae52fdf941731448ece967a"],"60a97329527e682292497dd2f6fae1c519840bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd320327ef03681a94238b48abfe570f0fdd7387":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["807314aa41c10866aec273a0e54fd0d24d8971de","3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}