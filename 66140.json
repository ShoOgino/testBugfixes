{"path":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0f5e4b06eda9c2996435d90659faa1a8601d196","date":1329255071,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n        assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":["ff266254aa2c0b84006f8f3088ee25337661554d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18","date":1339188570,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n        assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"e0f5e4b06eda9c2996435d90659faa1a8601d196":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["e0f5e4b06eda9c2996435d90659faa1a8601d196"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18"]},"commit2Childs":{"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e0f5e4b06eda9c2996435d90659faa1a8601d196":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e0f5e4b06eda9c2996435d90659faa1a8601d196"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}