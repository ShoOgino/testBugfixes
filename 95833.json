{"path":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","sourceNew":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    int i = b & 0x7F;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7F) << 28);\n  }\n\n","sourceOld":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    int i = b & 0x7F;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7F) << 28);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d91b7936af3081e704512ac1234340133e59904","date":1332109642,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","sourceNew":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    int i = b & 0x7F;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","sourceOld":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    int i = b & 0x7F;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7F) << 28);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"231a0ded093edb0044905980e2607acfc3f6a954","date":1333229599,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","sourceNew":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    int i = b & 0x7F;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","sourceOld":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    int i = b & 0x7F;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa","date":1335382601,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","sourceNew":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    int i = b & 0x7F;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","sourceOld":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    int i = b & 0x7F;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30f3e890c75f06861fff2fc783ffb7f340c2622f","date":1539858976,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVInt().mjava","sourceNew":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are\n   * supported, but should be avoided.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    int i = b & 0x7F;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","sourceOld":"  /** Reads an int stored in variable-length format.  Reads between one and\n   * five bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVInt(int)\n   */\n  public int readVInt() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    int i = b & 0x7F;\n    b = readByte();\n    i |= (b & 0x7F) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7F) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    // Warning: the next ands use 0x0F / 0xF0 - beware copy/paste errors:\n    i |= (b & 0x0F) << 28;\n    if ((b & 0xF0) == 0) return i;\n    throw new IOException(\"Invalid vInt detected (too many bits)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30f3e890c75f06861fff2fc783ffb7f340c2622f":["2e624b56e48bba276e76b66c9eb1bbb9994b0ffa"],"231a0ded093edb0044905980e2607acfc3f6a954":["7d91b7936af3081e704512ac1234340133e59904"],"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa":["231a0ded093edb0044905980e2607acfc3f6a954"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7d91b7936af3081e704512ac1234340133e59904":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30f3e890c75f06861fff2fc783ffb7f340c2622f"]},"commit2Childs":{"30f3e890c75f06861fff2fc783ffb7f340c2622f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"231a0ded093edb0044905980e2607acfc3f6a954":["2e624b56e48bba276e76b66c9eb1bbb9994b0ffa"],"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa":["30f3e890c75f06861fff2fc783ffb7f340c2622f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["7d91b7936af3081e704512ac1234340133e59904"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7d91b7936af3081e704512ac1234340133e59904":["231a0ded093edb0044905980e2607acfc3f6a954"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}