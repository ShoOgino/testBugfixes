{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","commits":[{"id":"fb32b2f58e1f02551c5abe6c272b58a970e0bf29","date":1476220416,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e8220da23feaeb400771f18161c4965dea5ab4cd","84a99d9041ffa5585158e5a283ea1736b6b8b473"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cb287e8b4595ddf413c318d5631789c8c8e8719","date":1490402624,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing missing _m, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_m:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":["e8220da23feaeb400771f18161c4965dea5ab4cd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52dc05802ffecefaecf5879a40a61539b5c985f0","date":1490594650,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing missing _m, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_m:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d473096f870b9bf3e231200a07e8eefa30eef8","date":1490745171,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing missing _m, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_m:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5","date":1490873946,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing missing _m, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_m:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd","date":1490979270,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":["e8220da23feaeb400771f18161c4965dea5ab4cd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14abccfea62dff435ac0457e128ca6bc703087d6","date":1491045405,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n        );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8220da23feaeb400771f18161c4965dea5ab4cd","date":1530366342,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":["4cb287e8b4595ddf413c318d5631789c8c8e8719","fb32b2f58e1f02551c5abe6c272b58a970e0bf29","09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"bugIntro":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84a99d9041ffa5585158e5a283ea1736b6b8b473","date":1532019928,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    \n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n    // same but with processEmpty:true we should check for refinement even if there isn't \"more\"\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true, facet: { processEmpty:true } } }\",\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}] } }\",  // shard1 response -- NO \"more\"\n        null,  // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on (even though shards say they have more)\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n    \n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        null               // shard1 expected refinement info\n    );\n\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":["e8220da23feaeb400771f18161c4965dea5ab4cd","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","date":1569046571,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    \n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n    // same but with processEmpty:true we should check for refinement even if there isn't \"more\"\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true, facet: { processEmpty:true } } }\",\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}] } }\",  // shard1 response -- NO \"more\"\n        null,  // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on (even though shards say they have more)\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n\n    // same test, but nested in range facet with ranges\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:0, to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[0,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:\\\"*\\\", to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[*,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // a range facet w/o any sub facets shouldn't require any refinement\n    // other and include ignored for ranges\n    doTestRefine(\"{top:{type:range, other:all, field:R, ranges:[{from:0, to:2},{from:2, to:3}] } }\" +\n            // phase #1\n            \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:2}],\" +\n            \"       } }\",\n        \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:19}],\" +\n            \"       } }\",\n        // refinement...\n        null,\n        null);\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    \n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n    // same but with processEmpty:true we should check for refinement even if there isn't \"more\"\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true, facet: { processEmpty:true } } }\",\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}] } }\",  // shard1 response -- NO \"more\"\n        null,  // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on (even though shards say they have more)\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n    \n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n    \n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99","date":1571689506,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testMerge().mjava","sourceNew":"  @Test\n  public void testMerge() throws Exception {\n    \n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n    // same but with processEmpty:true we should check for refinement even if there isn't \"more\"\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true, facet: { processEmpty:true } } }\",\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}] } }\",  // shard1 response -- NO \"more\"\n        null,  // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on (even though shards say they have more)\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" ,\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n\n    // same test, but nested in range facet with ranges\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:0, to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[0,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:\\\"*\\\", to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[*,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // a range facet w/o any sub facets shouldn't require any refinement\n    // other and include ignored for ranges\n    doTestRefine(\"{top:{type:range, other:all, field:R, ranges:[{from:0, to:2},{from:2, to:3}] } }\",\n            // phase #1\n            \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:2}],\" +\n            \"       } }\",\n        \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:19}],\" +\n            \"       } }\",\n        // refinement...\n        null,\n        null);\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testMerge() throws Exception {\n    \n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }\",  // shard1 response\n        null,  // shard0 expected refinement info\n        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket\n    );\n    // same but with processEmpty:true we should check for refinement even if there isn't \"more\"\n    doTestRefine(\"{x : {type:terms, field:X, limit:2, refine:true, facet: { processEmpty:true } } }\",\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}] } }\",  // shard1 response -- NO \"more\"\n        null,  // shard0 expected refinement info\n        \"=={x:{_l:[x1]}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on (even though shards say they have more)\n    doTestRefine(\"{x : {type:terms, field:X, limit:2} }\",  // the facet request\n        \"{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }\",  // shard0 response\n        \"{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }\",  // shard1 response\n        null, // shard0 expected refinement info\n        null  // shard1 expected refinement info\n    );\n\n    // same test, but nested in query facet\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",  // the facet request\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }\",  // shard1 response\n        null,              // shard0 expected refinement info\n        \"=={top:{x:{_l:[x1]}}}\"  // shard1 expected refinement info\n    );\n\n    // same test w/o refinement turned on\n    doTestRefine(\"{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:false} } } }\",\n        \"{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }\",  // shard0 response\n        \"{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }\",  // shard1 response\n        null,\n        null\n    );\n\n    // same test, but nested in a terms facet\n    doTestRefine(\"{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }\",\n        \"{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but nested in range facet\n    doTestRefine(\"{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [0 , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // same test, but now the range facet includes \"other\" buckets\n    // (so we also verify that the \"_actual_end\" is echoed back)\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       '_actual_end':'does_not_matter_must_be_echoed_back' } }\",\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} },\" +\n                 \"    '_actual_end':'does_not_matter_must_be_echoed_back'\" +\n                 \"} } \");\n    // imagine that all the nodes we query in phase#1 are running \"old\" versions of solr that\n    // don't know they are suppose to compute _actual_end ... our merger should not fail or freak out\n    // trust that in the phase#2 refinement request either:\n    //  - the processor will re-compute it (if refine request goes to \"new\" version of solr)\n    //  - the processor wouldn't know what to do with an _actual_end sent by the merger anyway\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:1, gap:1, \" +\n                 \"      facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2, x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:2,x:{more:true,buckets:[{val:x1, count:5},{val:x2, count:3}]} },\" +\n                 \"       } }\", // no actual_end\n                 \"{top: {buckets:[{val:0, count:1, x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} } ],\" +\n                 \"       before:{count:0},after:{count:0},\" +\n                 \"       between:{count:1,x:{more:true,buckets:[{val:x2, count:4},{val:x3, count:2}]} },\" +\n                 \"       } }\", // no actual_end\n                 // refinement...\n                 null,\n                 \"=={top: {\" +\n                 \"    _s:[  [0 , {x:{_l:[x1]}} ]  ],\" +\n                 \"    between:{ x:{_l : [x1]} }\" + \n                 \"} } \");\n    // a range face w/o any sub facets shouldn't require any refinement\n    doTestRefine(\"{top:{type:range, other:all, field:R, start:0, end:3, gap:2 } }\" +\n                 // phase #1\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:2}],\" +\n                 \"       before:{count:3},after:{count:47},\" +\n                 \"       between:{count:5},\" +\n                 \"       } }\",\n                 \"{top: {buckets:[{val:0, count:2}, {val:2, count:19}],\" +\n                 \"       before:{count:22},after:{count:0},\" +\n                 \"       between:{count:21},\" +\n                 \"       } }\",\n                 // refinement...\n                 null,\n                 null);\n\n    // same test, but nested in range facet with ranges\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:0, to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[0,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[0,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    doTestRefine(\"{top:{type:range, field:R, ranges:[{from:\\\"*\\\", to:1}], facet:{x : {type:terms, field:X, limit:2, refine:true} } } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }\",\n        \"{top: {buckets:[{val:\\\"[*,1)\\\", count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }\",\n        null,\n        \"=={top: {\" +\n            \"_s:[  [\\\"[*,1)\\\" , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // a range facet w/o any sub facets shouldn't require any refinement\n    // other and include ignored for ranges\n    doTestRefine(\"{top:{type:range, other:all, field:R, ranges:[{from:0, to:2},{from:2, to:3}] } }\" +\n            // phase #1\n            \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:2}],\" +\n            \"       } }\",\n        \"{top: {buckets:[{val:\\\"[0,2)\\\", count:2}, {val:\\\"[2,3)\\\", count:19}],\" +\n            \"       } }\",\n        // refinement...\n        null,\n        null);\n\n    // for testing partial _p, we need a partial facet within a partial facet\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }\",\n        \"{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }\",\n        null,\n        \"=={top: {\" +\n            \"_p:[  ['A' , {x:{_l:[x1]}} ]  ]\" +\n            \"    }  \" +\n            \"}\"\n    );\n\n    // test partial _p under a missing bucket\n    doTestRefine(\"{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }\",\n        \"{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }\",\n        \"{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }\",\n        \"=={top: {\" +\n            \"missing:{x:{_l:[x1]}}\" +\n            \"    }  \" +\n            \"}\"\n        , null\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["28288370235ed02234a64753cdbf0c6ec096304a"],"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"14abccfea62dff435ac0457e128ca6bc703087d6":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["14abccfea62dff435ac0457e128ca6bc703087d6","39fdbc59d893f5a211736e861fe145798a40b9ff"],"c05b634713ca09b2267477408773904d4c69dd9d":["e8220da23feaeb400771f18161c4965dea5ab4cd"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["4cb287e8b4595ddf413c318d5631789c8c8e8719"],"28288370235ed02234a64753cdbf0c6ec096304a":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd","39fdbc59d893f5a211736e861fe145798a40b9ff"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"fb32b2f58e1f02551c5abe6c272b58a970e0bf29":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["52dc05802ffecefaecf5879a40a61539b5c985f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["c05b634713ca09b2267477408773904d4c69dd9d"],"52dc05802ffecefaecf5879a40a61539b5c985f0":["fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["c05b634713ca09b2267477408773904d4c69dd9d"],"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"14abccfea62dff435ac0457e128ca6bc703087d6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["39fdbc59d893f5a211736e861fe145798a40b9ff","28288370235ed02234a64753cdbf0c6ec096304a"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["e8220da23feaeb400771f18161c4965dea5ab4cd","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"c05b634713ca09b2267477408773904d4c69dd9d":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","84a99d9041ffa5585158e5a283ea1736b6b8b473","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"fb32b2f58e1f02551c5abe6c272b58a970e0bf29":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4cb287e8b4595ddf413c318d5631789c8c8e8719","52dc05802ffecefaecf5879a40a61539b5c985f0"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["14abccfea62dff435ac0457e128ca6bc703087d6"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"52dc05802ffecefaecf5879a40a61539b5c985f0":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}