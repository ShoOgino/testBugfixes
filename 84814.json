{"path":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromPositions#convertPositionsToOffsets(ArrayList[OffsetRange],Analyzer,String,List[CharSequence]).mjava","commits":[{"id":"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c","date":1597407672,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromPositions#convertPositionsToOffsets(ArrayList[OffsetRange],Analyzer,String,List[CharSequence]).mjava","pathOld":"/dev/null","sourceNew":"  private static ArrayList<OffsetRange> convertPositionsToOffsets(\n      ArrayList<OffsetRange> ranges,\n      Analyzer analyzer,\n      String fieldName,\n      List<CharSequence> values)\n      throws IOException {\n\n    if (ranges.isEmpty()) {\n      return ranges;\n    }\n\n    class LeftRight {\n      int left = Integer.MAX_VALUE;\n      int right = Integer.MIN_VALUE;\n\n      @Override\n      public String toString() {\n        return \"[\" + \"L: \" + left + \", R: \" + right + ']';\n      }\n    }\n\n    Map<Integer, LeftRight> requiredPositionSpans = new HashMap<>();\n    int minPosition = Integer.MAX_VALUE;\n    int maxPosition = Integer.MIN_VALUE;\n    for (OffsetRange range : ranges) {\n      requiredPositionSpans.computeIfAbsent(range.from, (key) -> new LeftRight());\n      requiredPositionSpans.computeIfAbsent(range.to, (key) -> new LeftRight());\n      minPosition = Math.min(minPosition, range.from);\n      maxPosition = Math.max(maxPosition, range.to);\n    }\n\n    int position = -1;\n    int valueOffset = 0;\n    for (int valueIndex = 0, max = values.size(); valueIndex < max; valueIndex++) {\n      final String value = values.get(valueIndex).toString();\n      final boolean lastValue = valueIndex + 1 == max;\n\n      TokenStream ts = analyzer.tokenStream(fieldName, value);\n      OffsetAttribute offsetAttr = ts.getAttribute(OffsetAttribute.class);\n      PositionIncrementAttribute posAttr = ts.getAttribute(PositionIncrementAttribute.class);\n      ts.reset();\n      while (ts.incrementToken()) {\n        position += posAttr.getPositionIncrement();\n\n        if (position >= minPosition) {\n          LeftRight leftRight = requiredPositionSpans.get(position);\n          if (leftRight != null) {\n            int startOffset = valueOffset + offsetAttr.startOffset();\n            int endOffset = valueOffset + offsetAttr.endOffset();\n\n            leftRight.left = Math.min(leftRight.left, startOffset);\n            leftRight.right = Math.max(leftRight.right, endOffset);\n          }\n\n          // Only short-circuit if we're on the last value (which should be the common\n          // case since most fields would only have a single value anyway). We need\n          // to make sure of this because otherwise offsetAttr would have incorrect value.\n          if (position > maxPosition && lastValue) {\n            break;\n          }\n        }\n      }\n      ts.end();\n      position += posAttr.getPositionIncrement() + analyzer.getPositionIncrementGap(fieldName);\n      valueOffset += offsetAttr.endOffset() + analyzer.getOffsetGap(fieldName);\n      ts.close();\n    }\n\n    ArrayList<OffsetRange> converted = new ArrayList<>();\n    for (OffsetRange range : ranges) {\n      LeftRight left = requiredPositionSpans.get(range.from);\n      LeftRight right = requiredPositionSpans.get(range.to);\n      if (left == null\n          || right == null\n          || left.left == Integer.MAX_VALUE\n          || right.right == Integer.MIN_VALUE) {\n        throw new RuntimeException(\"Position not properly initialized for range: \" + range);\n      }\n      converted.add(new OffsetRange(left.left, right.right));\n    }\n\n    return converted;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"]},"commit2Childs":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}