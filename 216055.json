{"path":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","commits":[{"id":"6212677fdd165340d4284ad2530970c664042d6e","date":1180380790,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Indicates whether hit docs may be collected out of docid\n   * order. In other words, with this setting, \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * If docs out of order are allowed scoring might be faster\n   * for certain queries (disjunction queries with less than\n   * 32 prohibited terms). This setting has no effect for \n   * other queries.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8257e528d703ddbff1a8986dd3becee5d152e4b7","date":1184265700,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Indicates whether hit docs may be collected out of docid\n   * order. In other words, with this setting, \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * If collecting docs out of order is allowed, scoring might be faster\n   * for certain queries, for example disjunction queries with\n   * less than 32 prohibited clauses.\n   * This setting has no effect for other queries.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","sourceOld":"  /**\n   * Indicates whether hit docs may be collected out of docid\n   * order. In other words, with this setting, \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * If docs out of order are allowed scoring might be faster\n   * for certain queries (disjunction queries with less than\n   * 32 prohibited terms). This setting has no effect for \n   * other queries.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c23a482199ebae4a83336c1ad4c77542a83ce3e1","date":1191549209,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: llthough the contract of the Scorer class requires that\n   * documents be iterated in order of doc id this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to this true, calls to \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","sourceOld":"  /**\n   * Indicates whether hit docs may be collected out of docid\n   * order. In other words, with this setting, \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * If collecting docs out of order is allowed, scoring might be faster\n   * for certain queries, for example disjunction queries with\n   * less than 32 prohibited clauses.\n   * This setting has no effect for other queries.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14aa62e5144e288eb34275738ff873204949a8a3","date":1191612392,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to true, calls to \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","sourceOld":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: llthough the contract of the Scorer class requires that\n   * documents be iterated in order of doc id this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to this true, calls to \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba2ba537834023b8337e369c08afa3a2167c424c","date":1235054693,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored\n   * for a single segment before docid N-1. Across multiple segments,\n   * docs may be scored out of order regardless of this setting - it only\n   * applies to scoring a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","sourceOld":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to true, calls to \n   * {@link HitCollector#collect(int,float)} might be\n   * invoked first for docid N and only later for docid N-1.\n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid order.\n   * \n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene. Many pieces of functionality in the current Lucene code\n   * base have undefined behavior if this contract is not upheld, but in some\n   * specific simple cases may be faster. (For example: disjunction queries with\n   * less than 32 prohibited clauses; This setting has no effect for other\n   * queries.)\n   * </p>\n   * \n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored for a\n   * single segment before docid N-1. Across multiple segments, docs may be\n   * scored out of order regardless of this setting - it only applies to scoring\n   * a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   * \n   * @deprecated this is not needed anymore, as\n   *             {@link QueryWeight#scoresDocsOutOfOrder()} is used.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }\n\n","sourceOld":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid\n   * order.\n   *\n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene.  Many pieces of functionality in the current\n   * Lucene code base have undefined behavior if this contract is not\n   * upheld, but in some specific simple cases may be faster.  (For\n   * example: disjunction queries with less than 32 prohibited clauses;\n   * This setting has no effect for other queries.)\n   * </p>\n   *\n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored\n   * for a single segment before docid N-1. Across multiple segments,\n   * docs may be scored out of order regardless of this setting - it only\n   * applies to scoring a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid order.\n   * \n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene. Many pieces of functionality in the current Lucene code\n   * base have undefined behavior if this contract is not upheld, but in some\n   * specific simple cases may be faster. (For example: disjunction queries with\n   * less than 32 prohibited clauses; This setting has no effect for other\n   * queries.)\n   * </p>\n   * \n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored for a\n   * single segment before docid N-1. Across multiple segments, docs may be\n   * scored out of order regardless of this setting - it only applies to scoring\n   * a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   * \n   * @deprecated this is not needed anymore, as\n   *             {@link Weight#scoresDocsOutOfOrder()} is used.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }\n\n","sourceOld":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid order.\n   * \n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene. Many pieces of functionality in the current Lucene code\n   * base have undefined behavior if this contract is not upheld, but in some\n   * specific simple cases may be faster. (For example: disjunction queries with\n   * less than 32 prohibited clauses; This setting has no effect for other\n   * queries.)\n   * </p>\n   * \n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored for a\n   * single segment before docid N-1. Across multiple segments, docs may be\n   * scored out of order regardless of this setting - it only applies to scoring\n   * a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   * \n   * @deprecated this is not needed anymore, as\n   *             {@link QueryWeight#scoresDocsOutOfOrder()} is used.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"131a9e895609b4da33662dc087e0bc6303e1e29c","date":1255458397,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/BooleanQuery#setAllowDocsOutOfOrder(boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Expert: Indicates whether hit docs may be collected out of docid order.\n   * \n   * <p>\n   * Background: although the contract of the Scorer class requires that\n   * documents be iterated in order of doc id, this was not true in early\n   * versions of Lucene. Many pieces of functionality in the current Lucene code\n   * base have undefined behavior if this contract is not upheld, but in some\n   * specific simple cases may be faster. (For example: disjunction queries with\n   * less than 32 prohibited clauses; This setting has no effect for other\n   * queries.)\n   * </p>\n   * \n   * <p>\n   * Specifics: By setting this option to true, docid N might be scored for a\n   * single segment before docid N-1. Across multiple segments, docs may be\n   * scored out of order regardless of this setting - it only applies to scoring\n   * a single segment.\n   * \n   * Being static, this setting is system wide.\n   * </p>\n   * \n   * @deprecated this is not needed anymore, as\n   *             {@link Weight#scoresDocsOutOfOrder()} is used.\n   */\n  public static void setAllowDocsOutOfOrder(boolean allow) {\n    allowDocsOutOfOrder = allow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba2ba537834023b8337e369c08afa3a2167c424c":["14aa62e5144e288eb34275738ff873204949a8a3"],"8257e528d703ddbff1a8986dd3becee5d152e4b7":["6212677fdd165340d4284ad2530970c664042d6e"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["fe941135bdfc28c81e20b4d21422f8726af34925"],"fe941135bdfc28c81e20b4d21422f8726af34925":["052fac7830290bd38a04cddee1a121ee07656b56"],"c23a482199ebae4a83336c1ad4c77542a83ce3e1":["8257e528d703ddbff1a8986dd3becee5d152e4b7"],"6212677fdd165340d4284ad2530970c664042d6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"052fac7830290bd38a04cddee1a121ee07656b56":["ba2ba537834023b8337e369c08afa3a2167c424c"],"14aa62e5144e288eb34275738ff873204949a8a3":["c23a482199ebae4a83336c1ad4c77542a83ce3e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["131a9e895609b4da33662dc087e0bc6303e1e29c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6212677fdd165340d4284ad2530970c664042d6e"],"ba2ba537834023b8337e369c08afa3a2167c424c":["052fac7830290bd38a04cddee1a121ee07656b56"],"8257e528d703ddbff1a8986dd3becee5d152e4b7":["c23a482199ebae4a83336c1ad4c77542a83ce3e1"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe941135bdfc28c81e20b4d21422f8726af34925":["131a9e895609b4da33662dc087e0bc6303e1e29c"],"c23a482199ebae4a83336c1ad4c77542a83ce3e1":["14aa62e5144e288eb34275738ff873204949a8a3"],"6212677fdd165340d4284ad2530970c664042d6e":["8257e528d703ddbff1a8986dd3becee5d152e4b7"],"14aa62e5144e288eb34275738ff873204949a8a3":["ba2ba537834023b8337e369c08afa3a2167c424c"],"052fac7830290bd38a04cddee1a121ee07656b56":["fe941135bdfc28c81e20b4d21422f8726af34925"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}