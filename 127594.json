{"path":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":["01f60198ece724a6e96cd0b45f289cf42ff83d4f","3bb13258feba31ab676502787ab2e1779f129b7a","93c59ad5034eecd863f267bd75e1df7b8a51e427","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","a465ec8e22527bb8add54f75551ee9557a56de25","874088165d9cc50370b30219daa24a1946758ee6"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fa0f44f887719e97183771e977cfc4bfb485b766"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fa0f44f887719e97183771e977cfc4bfb485b766":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"fa0f44f887719e97183771e977cfc4bfb485b766":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["fa0f44f887719e97183771e977cfc4bfb485b766"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}