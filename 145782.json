{"path":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (VERBOSE) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (VERBOSE)\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      if (VERBOSE)\n        message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        if (VERBOSE)\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreads.size() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            if (VERBOSE)\n              message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else if (VERBOSE)\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73","d5f48f93ebe46929b99824596327a9dc6d6130d9","7ed80954d0e91206342729d058da7955cb93aa64","290c401c31db375e771805c3ba7ac5f64c7370dc","0ebc2085cdebd1e698f670bed4679ec7306f8a57","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"290c401c31db375e771805c3ba7ac5f64c7370dc","date":1192034795,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (VERBOSE) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (VERBOSE)\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      if (VERBOSE)\n        message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        if (VERBOSE)\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            if (VERBOSE)\n              message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else if (VERBOSE)\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (VERBOSE) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (VERBOSE)\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      if (VERBOSE)\n        message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        if (VERBOSE)\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreads.size() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            if (VERBOSE)\n              message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else if (VERBOSE)\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":["0ebc2085cdebd1e698f670bed4679ec7306f8a57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ed80954d0e91206342729d058da7955cb93aa64","date":1193061871,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (VERBOSE) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (VERBOSE)\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      if (VERBOSE)\n        message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        if (VERBOSE)\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            if (VERBOSE)\n              message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else if (VERBOSE)\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":["0ebc2085cdebd1e698f670bed4679ec7306f8a57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5f48f93ebe46929b99824596327a9dc6d6130d9","date":1193648456,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.setThreadPriority(mergeThreadPriority);\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            try {\n              merger.setPriority(mergeThreadPriority);\n            } catch (NullPointerException npe) {\n              // Strangely, Sun's JDK 1.5 on Linux sometimes\n              // throws NPE out of here...\n            }\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5ab5fd2fdb4c26bf87c8c8f8c4747da5589e106","date":1195731155,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.setThreadPriority(mergeThreadPriority);\n            merger.setDaemon(true);\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.setThreadPriority(mergeThreadPriority);\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0feb10cdc38728e18bd11f49da14b22e9141bcdc","date":1201897345,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            final MergeThread merger = getMergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      doMerge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            MergeThread merger = new MergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.setThreadPriority(mergeThreadPriority);\n            merger.setDaemon(true);\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      writer.merge(merge);\n    }\n  }\n\n","bugFix":null,"bugIntro":["0ebc2085cdebd1e698f670bed4679ec7306f8a57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ebc2085cdebd1e698f670bed4679ec7306f8a57","date":1202479308,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        if (merge.isExternal) {\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n        } else {\n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n          merger.start();\n          continue;\n        }\n      }\n\n      // This merge involves segments outside our index\n      // Directory so we must merge in foreground\n      doMerge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until its empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      message(\"  consider merge \" + merge.segString(dir));\n      \n      if (merge.isExternal) {\n        message(\"    merge involves segments from an external directory; now run in foreground\");\n      } else {\n        synchronized(this) {\n          if (mergeThreadCount() < maxThreadCount) {\n            // OK to spawn a new merge thread to handle this\n            // merge:\n            final MergeThread merger = getMergeThread(writer, merge);\n            mergeThreads.add(merger);\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n            merger.start();\n            continue;\n          } else\n            message(\"    too many merge threads running; run merge in foreground\");\n        }\n      }\n\n      // Too many merge threads already running, so we do\n      // this in the foreground of the calling thread\n      doMerge(merge);\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","290c401c31db375e771805c3ba7ac5f64c7370dc","0feb10cdc38728e18bd11f49da14b22e9141bcdc","7ed80954d0e91206342729d058da7955cb93aa64"],"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        if (merge.isExternal) {\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n        } else {\n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n          merger.start();\n          continue;\n        }\n      }\n\n      // This merge involves segments outside our index\n      // Directory so we must merge in foreground\n      doMerge(merge);\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        if (merge.isExternal) {\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n        } else {\n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n          merger.start();\n          continue;\n        }\n      }\n\n      // This merge involves segments outside our index\n      // Directory so we must merge in foreground\n      doMerge(merge);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        assert mergeThreadCount() < maxThreadCount;\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        message(\"    launch new thread [\" + merger.getName() + \"]\");\n        merger.start();\n      }\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        if (merge.isExternal) {\n          message(\"    merge involves segments from an external directory; now run in foreground\");\n        } else {\n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n          merger.start();\n          continue;\n        }\n      }\n\n      // This merge involves segments outside our index\n      // Directory so we must merge in foreground\n      doMerge(merge);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2993c85d947e3191bba14229ea72fd5675d048e2","date":1228593940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          if (verbose())\n            message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        if (verbose())\n          message(\"  consider merge \" + merge.segString(dir));\n      \n        assert mergeThreadCount() < maxThreadCount;\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose())\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        merger.start();\n      }\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    message(\"now merge\");\n    message(\"  index: \" + writer.segString());\n\n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        message(\"  consider merge \" + merge.segString(dir));\n      \n        assert mergeThreadCount() < maxThreadCount;\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        message(\"    launch new thread [\" + merger.getName() + \"]\");\n        merger.start();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      synchronized(this) {\n        while (mergeThreadCount() >= maxThreadCount) {\n          if (verbose())\n            message(\"    too many merge threads running; stalling...\");\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        }\n\n        if (verbose())\n          message(\"  consider merge \" + merge.segString(dir));\n      \n        assert mergeThreadCount() < maxThreadCount;\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose())\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        merger.start();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"feaf086f278a8afe69ae5147d0ef315af741d297","date":1256688442,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    // TODO: enable this once we are on JRE 1.5\n    // assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa4b66eb16ead894fa7130904af6ecf34331f050","date":1258198413,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["660be90ac3e6be139532015fd7a2bfd2d4037f18"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa","date":1261431504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          while (mergeThreadCount() >= maxThreadCount) {\n            if (verbose())\n              message(\"    too many merge threads running; stalling...\");\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose())\n            message(\"  consider merge \" + merge.segString(dir));\n      \n          assert mergeThreadCount() < maxThreadCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["660be90ac3e6be139532015fd7a2bfd2d4037f18"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d5f48f93ebe46929b99824596327a9dc6d6130d9":["7ed80954d0e91206342729d058da7955cb93aa64"],"455aeff4fef915340c5b19d71d5e147034e83093":["0ebc2085cdebd1e698f670bed4679ec7306f8a57"],"7ed80954d0e91206342729d058da7955cb93aa64":["290c401c31db375e771805c3ba7ac5f64c7370dc"],"8a9e385641d717e641408d8fbbc62be8fc766357":["feaf086f278a8afe69ae5147d0ef315af741d297"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["8a9e385641d717e641408d8fbbc62be8fc766357"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["2993c85d947e3191bba14229ea72fd5675d048e2"],"feaf086f278a8afe69ae5147d0ef315af741d297":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"2993c85d947e3191bba14229ea72fd5675d048e2":["2586f96f60332eb97ecd2934b0763791462568b2"],"0feb10cdc38728e18bd11f49da14b22e9141bcdc":["a5ab5fd2fdb4c26bf87c8c8f8c4747da5589e106"],"a5ab5fd2fdb4c26bf87c8c8f8c4747da5589e106":["d5f48f93ebe46929b99824596327a9dc6d6130d9"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"290c401c31db375e771805c3ba7ac5f64c7370dc":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"0ebc2085cdebd1e698f670bed4679ec7306f8a57":["0feb10cdc38728e18bd11f49da14b22e9141bcdc"],"2586f96f60332eb97ecd2934b0763791462568b2":["455aeff4fef915340c5b19d71d5e147034e83093"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"]},"commit2Childs":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["290c401c31db375e771805c3ba7ac5f64c7370dc"],"d5f48f93ebe46929b99824596327a9dc6d6130d9":["a5ab5fd2fdb4c26bf87c8c8f8c4747da5589e106"],"7ed80954d0e91206342729d058da7955cb93aa64":["d5f48f93ebe46929b99824596327a9dc6d6130d9"],"455aeff4fef915340c5b19d71d5e147034e83093":["2586f96f60332eb97ecd2934b0763791462568b2"],"8a9e385641d717e641408d8fbbc62be8fc766357":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["feaf086f278a8afe69ae5147d0ef315af741d297"],"feaf086f278a8afe69ae5147d0ef315af741d297":["8a9e385641d717e641408d8fbbc62be8fc766357"],"2993c85d947e3191bba14229ea72fd5675d048e2":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"0feb10cdc38728e18bd11f49da14b22e9141bcdc":["0ebc2085cdebd1e698f670bed4679ec7306f8a57"],"a5ab5fd2fdb4c26bf87c8c8f8c4747da5589e106":["0feb10cdc38728e18bd11f49da14b22e9141bcdc"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"290c401c31db375e771805c3ba7ac5f64c7370dc":["7ed80954d0e91206342729d058da7955cb93aa64"],"0ebc2085cdebd1e698f670bed4679ec7306f8a57":["455aeff4fef915340c5b19d71d5e147034e83093"],"2586f96f60332eb97ecd2934b0763791462568b2":["2993c85d947e3191bba14229ea72fd5675d048e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}