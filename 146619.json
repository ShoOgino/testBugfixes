{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#stem(char[],int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#stem(char[],int).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Stems the text in the token. Returns true if changed.\n   */\n  boolean stem(char[] term, int len) {\n    \n    result = null;\n    \n    k = len - 1;\n    if ((k <= 1) || (k >= MaxWordLen - 1)) {\n      return false; // don't stem\n    }\n    \n    // first check the stemmer dictionaries, and avoid using the\n    // cache if it's in there.\n    DictEntry entry = dict_ht.get(term, 0, len);\n    if (entry != null) {\n      if (entry.root != null) {\n        result = entry.root;\n        return true;\n      }\n      return false;\n    }\n    \n    /***\n     * caching off is normally faster if (cache == null) initializeStemHash();\n     * \n     * // now check the cache, before we copy chars to \"word\" if (cache != null)\n     * { String val = cache.get(term, 0, len); if (val != null) { if (val !=\n     * SAME) { result = val; return true; } return false; } }\n     ***/\n    \n    word.reset();\n    // allocate enough space so that an expansion is never needed\n    word.reserve(len + 10);\n    for (int i = 0; i < len; i++) {\n      char ch = term[i];\n      if (!isAlpha(ch)) return false; // don't stem\n      // don't lowercase... it's a requirement that lowercase filter be\n      // used before this stemmer.\n      word.unsafeWrite(ch);\n    }\n    \n    matchedEntry = null;\n    /***\n     * lookups.clear(); lookups.add(word.toString());\n     ***/\n    \n    /*\n     * This while loop will never be executed more than one time; it is here\n     * only to allow the break statement to be used to escape as soon as a word\n     * is recognized\n     */\n    while (true) {\n      // YCS: extra lookup()s were inserted so we don't need to\n      // do an extra wordInDict() here.\n      plural();\n      if (matched()) break;\n      pastTense();\n      if (matched()) break;\n      aspect();\n      if (matched()) break;\n      ityEndings();\n      if (matched()) break;\n      nessEndings();\n      if (matched()) break;\n      ionEndings();\n      if (matched()) break;\n      erAndOrEndings();\n      if (matched()) break;\n      lyEndings();\n      if (matched()) break;\n      alEndings();\n      if (matched()) break;\n      entry = wordInDict();\n      iveEndings();\n      if (matched()) break;\n      izeEndings();\n      if (matched()) break;\n      mentEndings();\n      if (matched()) break;\n      bleEndings();\n      if (matched()) break;\n      ismEndings();\n      if (matched()) break;\n      icEndings();\n      if (matched()) break;\n      ncyEndings();\n      if (matched()) break;\n      nceEndings();\n      matched();\n      break;\n    }\n    \n    /*\n     * try for a direct mapping (allows for cases like `Italian'->`Italy' and\n     * `Italians'->`Italy')\n     */\n    entry = matchedEntry;\n    if (entry != null) {\n      result = entry.root; // may be null, which means that \"word\" is the stem\n    }\n    \n    /***\n     * caching off is normally faster if (cache != null && cache.size() <\n     * maxCacheSize) { char[] key = new char[len]; System.arraycopy(term, 0,\n     * key, 0, len); if (result != null) { cache.put(key, result); } else {\n     * cache.put(key, word.toString()); } }\n     ***/\n    \n    /***\n     * if (entry == null) { if (!word.toString().equals(new String(term,0,len)))\n     * { System.out.println(\"CASE:\" + word.toString() + \",\" + new\n     * String(term,0,len));\n     * \n     * } }\n     ***/\n    \n    // no entry matched means result is \"word\"\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Stems the text in the token. Returns true if changed.\n   */\n  boolean stem(char[] term, int len) {\n    \n    result = null;\n    \n    k = len - 1;\n    if ((k <= 1) || (k >= MaxWordLen - 1)) {\n      return false; // don't stem\n    }\n    \n    // first check the stemmer dictionaries, and avoid using the\n    // cache if it's in there.\n    DictEntry entry = dict_ht.get(term, 0, len);\n    if (entry != null) {\n      if (entry.root != null) {\n        result = entry.root;\n        return true;\n      }\n      return false;\n    }\n    \n    /***\n     * caching off is normally faster if (cache == null) initializeStemHash();\n     * \n     * // now check the cache, before we copy chars to \"word\" if (cache != null)\n     * { String val = cache.get(term, 0, len); if (val != null) { if (val !=\n     * SAME) { result = val; return true; } return false; } }\n     ***/\n    \n    word.reset();\n    // allocate enough space so that an expansion is never needed\n    word.reserve(len + 10);\n    for (int i = 0; i < len; i++) {\n      char ch = term[i];\n      if (!isAlpha(ch)) return false; // don't stem\n      // don't lowercase... it's a requirement that lowercase filter be\n      // used before this stemmer.\n      word.unsafeWrite(ch);\n    }\n    \n    matchedEntry = null;\n    /***\n     * lookups.clear(); lookups.add(word.toString());\n     ***/\n    \n    /*\n     * This while loop will never be executed more than one time; it is here\n     * only to allow the break statement to be used to escape as soon as a word\n     * is recognized\n     */\n    while (true) {\n      // YCS: extra lookup()s were inserted so we don't need to\n      // do an extra wordInDict() here.\n      plural();\n      if (matched()) break;\n      pastTense();\n      if (matched()) break;\n      aspect();\n      if (matched()) break;\n      ityEndings();\n      if (matched()) break;\n      nessEndings();\n      if (matched()) break;\n      ionEndings();\n      if (matched()) break;\n      erAndOrEndings();\n      if (matched()) break;\n      lyEndings();\n      if (matched()) break;\n      alEndings();\n      if (matched()) break;\n      entry = wordInDict();\n      iveEndings();\n      if (matched()) break;\n      izeEndings();\n      if (matched()) break;\n      mentEndings();\n      if (matched()) break;\n      bleEndings();\n      if (matched()) break;\n      ismEndings();\n      if (matched()) break;\n      icEndings();\n      if (matched()) break;\n      ncyEndings();\n      if (matched()) break;\n      nceEndings();\n      matched();\n      break;\n    }\n    \n    /*\n     * try for a direct mapping (allows for cases like `Italian'->`Italy' and\n     * `Italians'->`Italy')\n     */\n    entry = matchedEntry;\n    if (entry != null) {\n      result = entry.root; // may be null, which means that \"word\" is the stem\n    }\n    \n    /***\n     * caching off is normally faster if (cache != null && cache.size() <\n     * maxCacheSize) { char[] key = new char[len]; System.arraycopy(term, 0,\n     * key, 0, len); if (result != null) { cache.put(key, result); } else {\n     * cache.put(key, word.toString()); } }\n     ***/\n    \n    /***\n     * if (entry == null) { if (!word.toString().equals(new String(term,0,len)))\n     * { System.out.println(\"CASE:\" + word.toString() + \",\" + new\n     * String(term,0,len));\n     * \n     * } }\n     ***/\n    \n    // no entry matched means result is \"word\"\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}