{"path":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","commits":[{"id":"44549822b9113925bd45e53c1e0028ab2e1d1d7f","date":1330898600,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Statement apply(final Statement s, Description d) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        TreeMap<String,String> before = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n        ArrayList<Throwable> errors = new ArrayList<Throwable>();\n        try {\n          s.evaluate();\n        } catch (Throwable t) {\n          errors.add(t);\n        } finally {\n          TreeMap<String,String> after = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n          if (!after.equals(before)) {\n            errors.add(\n                new AssertionError(\"System properties invariant violated.\\n\" + \n                    collectErrorMessage(before, after)));\n          }\n\n          // Restore original properties.\n          SystemPropertiesRestoreRule.restore(before, after);\n        }\n\n        MultipleFailureException.assertEmpty(errors);\n      }\n\n      private StringBuilder collectErrorMessage(\n          TreeMap<String,String> before, TreeMap<String,String> after) {\n        TreeSet<String> newKeys = new TreeSet<String>(after.keySet());\n        newKeys.removeAll(before.keySet());\n        \n        TreeSet<String> missingKeys = new TreeSet<String>(before.keySet());\n        missingKeys.removeAll(after.keySet());\n        \n        TreeSet<String> differentKeyValues = new TreeSet<String>(before.keySet());\n        differentKeyValues.retainAll(after.keySet());\n        for (Iterator<String> i = differentKeyValues.iterator(); i.hasNext();) {\n          String key = i.next();\n          String valueBefore = before.get(key);\n          String valueAfter = after.get(key);\n          if ((valueBefore == null && valueAfter == null) ||\n              (valueBefore.equals(valueAfter))) {\n            i.remove();\n          }\n        }\n\n        final StringBuilder b = new StringBuilder();\n        if (!missingKeys.isEmpty()) {\n          b.append(\"Missing keys:\\n\");\n          for (String key : missingKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(before.get(key))            \n              .append(\"\\n\");\n          }\n        }\n        if (!newKeys.isEmpty()) {\n          b.append(\"New keys:\\n\");\n          for (String key : newKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(after.get(key))\n              .append(\"\\n\");\n          }\n        }\n        if (!differentKeyValues.isEmpty()) {\n          b.append(\"Different values:\\n\");\n          for (String key : differentKeyValues) {\n            b.append(\"  [old]\").append(key)\n              .append(\"=\")\n              .append(before.get(key)).append(\"\\n\");\n            b.append(\"  [new]\").append(key)\n              .append(\"=\")\n              .append(after.get(key)).append(\"\\n\");\n          }\n        }\n        return b;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Statement apply(final Statement s, Description d) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        TreeMap<String,String> before = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n        ArrayList<Throwable> errors = new ArrayList<Throwable>();\n        try {\n          s.evaluate();\n        } catch (Throwable t) {\n          errors.add(t);\n        } finally {\n          TreeMap<String,String> after = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n          if (!after.equals(before)) {\n            errors.add(\n                new AssertionError(\"System properties invariant violated.\\n\" + \n                    collectErrorMessage(before, after)));\n          }\n\n          // Restore original properties.\n          SystemPropertiesRestoreRule.restore(before, after);\n        }\n\n        MultipleFailureException.assertEmpty(errors);\n      }\n\n      private StringBuilder collectErrorMessage(\n          TreeMap<String,String> before, TreeMap<String,String> after) {\n        TreeSet<String> newKeys = new TreeSet<String>(after.keySet());\n        newKeys.removeAll(before.keySet());\n        \n        TreeSet<String> missingKeys = new TreeSet<String>(before.keySet());\n        missingKeys.removeAll(after.keySet());\n        \n        TreeSet<String> differentKeyValues = new TreeSet<String>(before.keySet());\n        differentKeyValues.retainAll(after.keySet());\n        for (Iterator<String> i = differentKeyValues.iterator(); i.hasNext();) {\n          String key = i.next();\n          String valueBefore = before.get(key);\n          String valueAfter = after.get(key);\n          if ((valueBefore == null && valueAfter == null) ||\n              (valueBefore.equals(valueAfter))) {\n            i.remove();\n          }\n        }\n\n        final StringBuilder b = new StringBuilder();\n        if (!missingKeys.isEmpty()) {\n          b.append(\"Missing keys:\\n\");\n          for (String key : missingKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(before.get(key))            \n              .append(\"\\n\");\n          }\n        }\n        if (!newKeys.isEmpty()) {\n          b.append(\"New keys:\\n\");\n          for (String key : newKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(after.get(key))\n              .append(\"\\n\");\n          }\n        }\n        if (!differentKeyValues.isEmpty()) {\n          b.append(\"Different values:\\n\");\n          for (String key : differentKeyValues) {\n            b.append(\"  [old]\").append(key)\n              .append(\"=\")\n              .append(before.get(key)).append(\"\\n\");\n            b.append(\"  [new]\").append(key)\n              .append(\"=\")\n              .append(after.get(key)).append(\"\\n\");\n          }\n        }\n        return b;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8145d062469bbacf8e366bd238d956e8c2ca0ec","date":1332446435,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","sourceNew":"  @Override\n  public Statement apply(final Statement s, Description d) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        TreeMap<String,String> before = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n        ArrayList<Throwable> errors = new ArrayList<Throwable>();\n        try {\n          s.evaluate();\n        } catch (Throwable t) {\n          errors.add(t);\n        } finally {\n          final TreeMap<String,String> after = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n\n          // Remove ignored if they exist.\n          before.keySet().removeAll(ignoredProperties);\n          after.keySet().removeAll(ignoredProperties);\n\n          if (!after.equals(before)) {\n            errors.add(\n                new AssertionError(\"System properties invariant violated.\\n\" + \n                    collectErrorMessage(before, after)));\n          }\n\n          // Restore original properties.\n          SystemPropertiesRestoreRule.restore(before, after, ignoredProperties);\n        }\n\n        MultipleFailureException.assertEmpty(errors);\n      }\n\n      private StringBuilder collectErrorMessage(\n          TreeMap<String,String> before, TreeMap<String,String> after) {\n        TreeSet<String> newKeys = new TreeSet<String>(after.keySet());\n        newKeys.removeAll(before.keySet());\n        \n        TreeSet<String> missingKeys = new TreeSet<String>(before.keySet());\n        missingKeys.removeAll(after.keySet());\n        \n        TreeSet<String> differentKeyValues = new TreeSet<String>(before.keySet());\n        differentKeyValues.retainAll(after.keySet());\n        for (Iterator<String> i = differentKeyValues.iterator(); i.hasNext();) {\n          String key = i.next();\n          String valueBefore = before.get(key);\n          String valueAfter = after.get(key);\n          if ((valueBefore == null && valueAfter == null) ||\n              (valueBefore.equals(valueAfter))) {\n            i.remove();\n          }\n        }\n\n        final StringBuilder b = new StringBuilder();\n        if (!missingKeys.isEmpty()) {\n          b.append(\"Missing keys:\\n\");\n          for (String key : missingKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(before.get(key))            \n              .append(\"\\n\");\n          }\n        }\n        if (!newKeys.isEmpty()) {\n          b.append(\"New keys:\\n\");\n          for (String key : newKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(after.get(key))\n              .append(\"\\n\");\n          }\n        }\n        if (!differentKeyValues.isEmpty()) {\n          b.append(\"Different values:\\n\");\n          for (String key : differentKeyValues) {\n            b.append(\"  [old]\").append(key)\n              .append(\"=\")\n              .append(before.get(key)).append(\"\\n\");\n            b.append(\"  [new]\").append(key)\n              .append(\"=\")\n              .append(after.get(key)).append(\"\\n\");\n          }\n        }\n        return b;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Statement apply(final Statement s, Description d) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        TreeMap<String,String> before = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n        ArrayList<Throwable> errors = new ArrayList<Throwable>();\n        try {\n          s.evaluate();\n        } catch (Throwable t) {\n          errors.add(t);\n        } finally {\n          TreeMap<String,String> after = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n          if (!after.equals(before)) {\n            errors.add(\n                new AssertionError(\"System properties invariant violated.\\n\" + \n                    collectErrorMessage(before, after)));\n          }\n\n          // Restore original properties.\n          SystemPropertiesRestoreRule.restore(before, after);\n        }\n\n        MultipleFailureException.assertEmpty(errors);\n      }\n\n      private StringBuilder collectErrorMessage(\n          TreeMap<String,String> before, TreeMap<String,String> after) {\n        TreeSet<String> newKeys = new TreeSet<String>(after.keySet());\n        newKeys.removeAll(before.keySet());\n        \n        TreeSet<String> missingKeys = new TreeSet<String>(before.keySet());\n        missingKeys.removeAll(after.keySet());\n        \n        TreeSet<String> differentKeyValues = new TreeSet<String>(before.keySet());\n        differentKeyValues.retainAll(after.keySet());\n        for (Iterator<String> i = differentKeyValues.iterator(); i.hasNext();) {\n          String key = i.next();\n          String valueBefore = before.get(key);\n          String valueAfter = after.get(key);\n          if ((valueBefore == null && valueAfter == null) ||\n              (valueBefore.equals(valueAfter))) {\n            i.remove();\n          }\n        }\n\n        final StringBuilder b = new StringBuilder();\n        if (!missingKeys.isEmpty()) {\n          b.append(\"Missing keys:\\n\");\n          for (String key : missingKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(before.get(key))            \n              .append(\"\\n\");\n          }\n        }\n        if (!newKeys.isEmpty()) {\n          b.append(\"New keys:\\n\");\n          for (String key : newKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(after.get(key))\n              .append(\"\\n\");\n          }\n        }\n        if (!differentKeyValues.isEmpty()) {\n          b.append(\"Different values:\\n\");\n          for (String key : differentKeyValues) {\n            b.append(\"  [old]\").append(key)\n              .append(\"=\")\n              .append(before.get(key)).append(\"\\n\");\n            b.append(\"  [new]\").append(key)\n              .append(\"=\")\n              .append(after.get(key)).append(\"\\n\");\n          }\n        }\n        return b;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/SystemPropertiesInvariantRule#apply(Statement,Description).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Statement apply(final Statement s, Description d) {\n    return new Statement() {\n      @Override\n      public void evaluate() throws Throwable {\n        TreeMap<String,String> before = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n        ArrayList<Throwable> errors = new ArrayList<Throwable>();\n        try {\n          s.evaluate();\n        } catch (Throwable t) {\n          errors.add(t);\n        } finally {\n          final TreeMap<String,String> after = SystemPropertiesRestoreRule.cloneAsMap(System.getProperties());\n\n          // Remove ignored if they exist.\n          before.keySet().removeAll(ignoredProperties);\n          after.keySet().removeAll(ignoredProperties);\n\n          if (!after.equals(before)) {\n            errors.add(\n                new AssertionError(\"System properties invariant violated.\\n\" + \n                    collectErrorMessage(before, after)));\n          }\n\n          // Restore original properties.\n          SystemPropertiesRestoreRule.restore(before, after, ignoredProperties);\n        }\n\n        MultipleFailureException.assertEmpty(errors);\n      }\n\n      private StringBuilder collectErrorMessage(\n          TreeMap<String,String> before, TreeMap<String,String> after) {\n        TreeSet<String> newKeys = new TreeSet<String>(after.keySet());\n        newKeys.removeAll(before.keySet());\n        \n        TreeSet<String> missingKeys = new TreeSet<String>(before.keySet());\n        missingKeys.removeAll(after.keySet());\n        \n        TreeSet<String> differentKeyValues = new TreeSet<String>(before.keySet());\n        differentKeyValues.retainAll(after.keySet());\n        for (Iterator<String> i = differentKeyValues.iterator(); i.hasNext();) {\n          String key = i.next();\n          String valueBefore = before.get(key);\n          String valueAfter = after.get(key);\n          if ((valueBefore == null && valueAfter == null) ||\n              (valueBefore.equals(valueAfter))) {\n            i.remove();\n          }\n        }\n\n        final StringBuilder b = new StringBuilder();\n        if (!missingKeys.isEmpty()) {\n          b.append(\"Missing keys:\\n\");\n          for (String key : missingKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(before.get(key))            \n              .append(\"\\n\");\n          }\n        }\n        if (!newKeys.isEmpty()) {\n          b.append(\"New keys:\\n\");\n          for (String key : newKeys) {\n            b.append(\"  \").append(key)\n              .append(\"=\")\n              .append(after.get(key))\n              .append(\"\\n\");\n          }\n        }\n        if (!differentKeyValues.isEmpty()) {\n          b.append(\"Different values:\\n\");\n          for (String key : differentKeyValues) {\n            b.append(\"  [old]\").append(key)\n              .append(\"=\")\n              .append(before.get(key)).append(\"\\n\");\n            b.append(\"  [new]\").append(key)\n              .append(\"=\")\n              .append(after.get(key)).append(\"\\n\");\n          }\n        }\n        return b;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8145d062469bbacf8e366bd238d956e8c2ca0ec":["44549822b9113925bd45e53c1e0028ab2e1d1d7f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","44549822b9113925bd45e53c1e0028ab2e1d1d7f"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["b8145d062469bbacf8e366bd238d956e8c2ca0ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"44549822b9113925bd45e53c1e0028ab2e1d1d7f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5da0b42730b6b99b31389ef94cb97384e83b9ede"]},"commit2Childs":{"b8145d062469bbacf8e366bd238d956e8c2ca0ec":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","44549822b9113925bd45e53c1e0028ab2e1d1d7f"],"44549822b9113925bd45e53c1e0028ab2e1d1d7f":["b8145d062469bbacf8e366bd238d956e8c2ca0ec","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}