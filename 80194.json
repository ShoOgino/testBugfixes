{"path":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","commits":[{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.trace(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.trace(\"-- wrong number of active slices, expected={}, found={}\", expectedShards, collectionState.getSlices().size());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.trace(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.trace(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.trace(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.trace(\"-- wrong number of slices, expected={}, found={}: {}\", expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.trace(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.trace(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.trace(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.trace(\"-- wrong number of active slices, expected={}, found={}\", expectedShards, collectionState.getSlices().size());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.trace(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.trace(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices, expected={}, found={}: {}\", expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.trace(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.trace(\"-- wrong number of slices, expected={}, found={}: {}\", expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.trace(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.trace(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e","042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a10d5fb09886ac2ee006921a03d00871827c3768","date":1544808079,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices, expected={}, found={}: {}\", expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a10d5fb09886ac2ee006921a03d00871827c3768":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a10d5fb09886ac2ee006921a03d00871827c3768"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"a10d5fb09886ac2ee006921a03d00871827c3768":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a10d5fb09886ac2ee006921a03d00871827c3768"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}