{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","commits":[{"id":"c5fd294da67452cd8d116692194908de00eb5209","date":1499704155,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners.\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners.\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners.\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15ba547dfc0dd0b670e678cb3db8e5d27c694420","date":1511865512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions);\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners.\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions);\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners.\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions);\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown and actionThrottle\n    cooldownStart.set(System.nanoTime() - cooldownPeriod.get());\n    actionThrottle.get().reset();\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions);\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt(),\n                  cloudManager.getTimeSource());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions, cloudManager.getTimeSource());\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown and actionThrottle\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n    actionThrottle.get().reset();\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions);\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown and actionThrottle\n    cooldownStart.set(System.nanoTime() - cooldownPeriod.get());\n    actionThrottle.get().reset();\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0054ae381912e45884d3005a00486ed92a0f4925","date":1514900316,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt(),\n                  cloudManager.getTimeSource());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions, cloudManager.getTimeSource());\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown and actionThrottle\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n    actionThrottle.get().reset();\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n          case ACTION_THROTTLE_PERIOD_SECONDS:\n            long minMsBetweenActions = TimeUnit.SECONDS.toMillis(((Number) newProps.get(key)).longValue());\n            ActionThrottle oldThrottle = this.actionThrottle.get();\n            ActionThrottle newThrottle = null;\n            if (oldThrottle.getLastActionStartedAt() != null) {\n              newThrottle = new ActionThrottle(\"action\",\n                  minMsBetweenActions,\n                  oldThrottle.getLastActionStartedAt(),\n                  cloudManager.getTimeSource());\n            } else  {\n              newThrottle = new ActionThrottle(\"action\", minMsBetweenActions, cloudManager.getTimeSource());\n            }\n            this.actionThrottle.set(newThrottle);\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown and actionThrottle\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n    actionThrottle.get().reset();\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8af24f206736d88373229e8c83ddb84a433e57f3","date":1520362563,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggers.forEach((s, scheduledTrigger) -> {\n                if (scheduledTrigger.scheduledFuture.cancel(false)) {\n                  scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      scheduledTrigger, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n    this.autoScalingConfig = autoScalingConfig;\n\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n\n    listeners.setAutoScalingConfig(autoScalingConfig);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTimeNs() - cooldownPeriod.get());\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTime() - cooldownPeriod.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        }\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTimeNs() - cooldownPeriod.get());\n  }\n\n","sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTimeNs() - cooldownPeriod.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#setAutoScalingConfig(AutoScalingConfig).mjava","sourceNew":null,"sourceOld":"  /**\n   * Set the current autoscaling config. This is invoked by {@link OverseerTriggerThread} when autoscaling.json is updated,\n   * and it re-initializes trigger listeners and other properties used by the framework\n   * @param autoScalingConfig current autoscaling.json\n   */\n  public void setAutoScalingConfig(AutoScalingConfig autoScalingConfig) {\n    Map<String, Object> currentProps = new HashMap<>(DEFAULT_PROPERTIES);\n    if (this.autoScalingConfig != null) {\n      currentProps.putAll(this.autoScalingConfig.getProperties());\n    }\n\n    // reset listeners early in order to capture first execution of newly scheduled triggers\n    listeners.setAutoScalingConfig(autoScalingConfig);\n\n    for (Map.Entry<String, Object> entry : currentProps.entrySet()) {\n      Map<String, Object> newProps = autoScalingConfig.getProperties();\n      String key = entry.getKey();\n      if (newProps.containsKey(key) && !entry.getValue().equals(newProps.get(key))) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Changing value of autoscaling property: {} from: {} to: {}\", key, entry.getValue(), newProps.get(key));\n        }\n        switch (key) {\n          case TRIGGER_SCHEDULE_DELAY_SECONDS:\n            triggerDelay.set(((Number) newProps.get(key)).intValue());\n            synchronized (this) {\n              scheduledTriggerWrappers.forEach((s, triggerWrapper) -> {\n                if (triggerWrapper.scheduledFuture.cancel(false)) {\n                  triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(\n                      triggerWrapper, 0,\n                      cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n                      TimeUnit.MILLISECONDS);\n                } else  {\n                  log.debug(\"Failed to cancel scheduled task: {}\", s);\n                }\n              });\n            }\n            break;\n          case TRIGGER_COOLDOWN_PERIOD_SECONDS:\n            cooldownPeriod.set(TimeUnit.SECONDS.toNanos(((Number) newProps.get(key)).longValue()));\n            break;\n          case TRIGGER_CORE_POOL_SIZE:\n            this.scheduledThreadPoolExecutor.setCorePoolSize(((Number) newProps.get(key)).intValue());\n            break;\n        }\n      }\n    }\n\n    this.autoScalingConfig = autoScalingConfig;\n    // reset cooldown\n    cooldownStart.set(cloudManager.getTimeSource().getTimeNs() - cooldownPeriod.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","0054ae381912e45884d3005a00486ed92a0f4925"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5fd294da67452cd8d116692194908de00eb5209"],"3f504512a03d978990cbff30db0522b354e846db":["e35f2dde06b35aa9904949a3a93fabd090371077"],"8af24f206736d88373229e8c83ddb84a433e57f3":["b94236357aaa22b76c10629851fe4e376e0cea82"],"9c6c0dad4932399aec99b4818086cb1772773916":["8af24f206736d88373229e8c83ddb84a433e57f3"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["560c18d71dad43d675158783c3840f8c80d6d39c","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["560c18d71dad43d675158783c3840f8c80d6d39c"],"c5fd294da67452cd8d116692194908de00eb5209":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["9c6c0dad4932399aec99b4818086cb1772773916"],"0054ae381912e45884d3005a00486ed92a0f4925":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"e35f2dde06b35aa9904949a3a93fabd090371077":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["8af24f206736d88373229e8c83ddb84a433e57f3"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8af24f206736d88373229e8c83ddb84a433e57f3":["9c6c0dad4932399aec99b4818086cb1772773916"],"9c6c0dad4932399aec99b4818086cb1772773916":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"c5fd294da67452cd8d116692194908de00eb5209":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","c5fd294da67452cd8d116692194908de00eb5209","560c18d71dad43d675158783c3840f8c80d6d39c"],"0054ae381912e45884d3005a00486ed92a0f4925":["b94236357aaa22b76c10629851fe4e376e0cea82"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["e35f2dde06b35aa9904949a3a93fabd090371077"],"e35f2dde06b35aa9904949a3a93fabd090371077":["3f504512a03d978990cbff30db0522b354e846db"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","0054ae381912e45884d3005a00486ed92a0f4925"],"560c18d71dad43d675158783c3840f8c80d6d39c":["1aad05eeff7818b0833c02ac6b743aa72054963b","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}