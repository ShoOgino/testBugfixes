{"path":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2782fe88d18fedf3ef67402c9cb5a41978a8c7","date":1328901155,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.shutdown();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.shutdown();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92b4a131f1796dd57cc6698aae3d589d32a29deb","date":1457087316,"type":3,"author":"Luc Vanlerberghe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits.value);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits.value;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new ByteBuffersDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits.value);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits.value;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new TextField(\"field\", new CannedTokenStream(tokens)));\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = newSearcher(r);\n    MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpqb.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpqb.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpqb.build(), 2);\n    assertEquals(2, hits.totalHits.value);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits.value;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92b4a131f1796dd57cc6698aae3d589d32a29deb":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d77dafd89756a5161d244985903e3487ca109182":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6c2782fe88d18fedf3ef67402c9cb5a41978a8c7"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["d0ef034a4f10871667ae75181537775ddcf8ade4","92b4a131f1796dd57cc6698aae3d589d32a29deb"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"6c2782fe88d18fedf3ef67402c9cb5a41978a8c7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d77dafd89756a5161d244985903e3487ca109182"]},"commit2Childs":{"92b4a131f1796dd57cc6698aae3d589d32a29deb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["6c2782fe88d18fedf3ef67402c9cb5a41978a8c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["92b4a131f1796dd57cc6698aae3d589d32a29deb","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d77dafd89756a5161d244985903e3487ca109182":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["d77dafd89756a5161d244985903e3487ca109182"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6c2782fe88d18fedf3ef67402c9cb5a41978a8c7":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}