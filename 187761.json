{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","commits":[{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      BytesRef scratch = new BytesRef();\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      BytesRef scratch = new BytesRef();\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      BytesRef scratch = new BytesRef();\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0732a1e488deedeceef7f601e066085e7ac655a","date":1391629546,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      \n      BytesRef scratch = new BytesRef();\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      BytesRef scratch = new BytesRef();\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        final BytesRef bytesRef = dv.get(doc);\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n      \n      BytesRef scratch = new BytesRef();\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        dv.get(doc, scratch);\n        byte[] bytes = scratch.bytes;\n        int end = scratch.offset + scratch.length;\n        int ord = 0;\n        int offset = scratch.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (dv.docID() < doc) {\n          dv.advance(doc);\n        }\n        if (dv.docID() == doc) {\n          final BytesRef bytesRef = dv.binaryValue();\n          byte[] bytes = bytesRef.bytes;\n          int end = bytesRef.offset + bytesRef.length;\n          int ord = 0;\n          int offset = bytesRef.offset;\n          int prev = 0;\n          while (offset < end) {\n            byte b = bytes[offset++];\n            if (b >= 0) {\n              prev = ord = ((ord << 7) | b) + prev;\n              ++values[ord];\n              ord = 0;\n            } else {\n              ord = (ord << 7) | (b & 0x7F);\n            }\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        final BytesRef bytesRef = dv.get(doc);\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (dv.docID() < doc) {\n          dv.advance(doc);\n        }\n        if (dv.docID() == doc) {\n          final BytesRef bytesRef = dv.binaryValue();\n          byte[] bytes = bytesRef.bytes;\n          int end = bytesRef.offset + bytesRef.length;\n          int ord = 0;\n          int offset = bytesRef.offset;\n          int prev = 0;\n          while (offset < end) {\n            byte b = bytes[offset++];\n            if (b >= 0) {\n              prev = ord = ((ord << 7) | b) + prev;\n              ++values[ord];\n              ord = 0;\n            } else {\n              ord = (ord << 7) | (b & 0x7F);\n            }\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        final BytesRef bytesRef = dv.get(doc);\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bc585d9bb7467578d92b12118ec4a8daa352379","date":1476885879,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator it = ConjunctionDISI.intersectIterators(Arrays.asList(\n          hits.bits.iterator(), dv));\n      \n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        final BytesRef bytesRef = dv.binaryValue();\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (dv.docID() < doc) {\n          dv.advance(doc);\n        }\n        if (dv.docID() == doc) {\n          final BytesRef bytesRef = dv.binaryValue();\n          byte[] bytes = bytesRef.bytes;\n          int end = bytesRef.offset + bytesRef.length;\n          int ord = 0;\n          int offset = bytesRef.offset;\n          int prev = 0;\n          while (offset < end) {\n            byte b = bytes[offset++];\n            if (b >= 0) {\n              prev = ord = ((ord << 7) | b) + prev;\n              ++values[ord];\n              ord = 0;\n            } else {\n              ord = (ord << 7) | (b & 0x7F);\n            }\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2305f39a86a068f1cee6fc5fbdfb760b153ac138","date":1476906991,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator it = ConjunctionDISI.intersectIterators(Arrays.asList(\n          hits.bits.iterator(), dv));\n      \n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        final BytesRef bytesRef = dv.binaryValue();\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (dv.docID() < doc) {\n          dv.advance(doc);\n        }\n        if (dv.docID() == doc) {\n          final BytesRef bytesRef = dv.binaryValue();\n          byte[] bytes = bytesRef.bytes;\n          int end = bytesRef.offset + bytesRef.length;\n          int ord = 0;\n          int offset = bytesRef.offset;\n          int prev = 0;\n          while (offset < end) {\n            byte b = bytes[offset++];\n            if (b >= 0) {\n              prev = ord = ((ord << 7) | b) + prev;\n              ++values[ord];\n              ord = 0;\n            } else {\n              ord = (ord << 7) | (b & 0x7F);\n            }\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator it = ConjunctionDISI.intersectIterators(Arrays.asList(\n          hits.bits.iterator(), dv));\n      \n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        final BytesRef bytesRef = dv.binaryValue();\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        final BytesRef bytesRef = dv.get(doc);\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","date":1509555533,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FastTaxonomyFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator it = ConjunctionDISI.intersectIterators(Arrays.asList(\n          hits.bits.iterator(), dv));\n      \n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        final BytesRef bytesRef = dv.binaryValue();\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            increment(ord);\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void count(List<MatchingDocs> matchingDocs) throws IOException {\n    for(MatchingDocs hits : matchingDocs) {\n      BinaryDocValues dv = hits.context.reader().getBinaryDocValues(indexFieldName);\n      if (dv == null) { // this reader does not have DocValues for the requested category list\n        continue;\n      }\n\n      DocIdSetIterator it = ConjunctionDISI.intersectIterators(Arrays.asList(\n          hits.bits.iterator(), dv));\n      \n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        final BytesRef bytesRef = dv.binaryValue();\n        byte[] bytes = bytesRef.bytes;\n        int end = bytesRef.offset + bytesRef.length;\n        int ord = 0;\n        int offset = bytesRef.offset;\n        int prev = 0;\n        while (offset < end) {\n          byte b = bytes[offset++];\n          if (b >= 0) {\n            prev = ord = ((ord << 7) | b) + prev;\n            ++values[ord];\n            ord = 0;\n          } else {\n            ord = (ord << 7) | (b & 0x7F);\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["a0732a1e488deedeceef7f601e066085e7ac655a"],"a0732a1e488deedeceef7f601e066085e7ac655a":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"2bc585d9bb7467578d92b12118ec4a8daa352379":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","2bc585d9bb7467578d92b12118ec4a8daa352379"]},"commit2Childs":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0732a1e488deedeceef7f601e066085e7ac655a":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4edc984f0f4ac77c37e48ace2932f780f888453c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["2bc585d9bb7467578d92b12118ec4a8daa352379","2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0732a1e488deedeceef7f601e066085e7ac655a"],"2bc585d9bb7467578d92b12118ec4a8daa352379":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}