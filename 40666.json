{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","commits":[{"id":"d14ffaac9c4a4a2c750bf0cd956506802561e062","date":1402602036,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fa087bc3b5a2da0de8a912f76ae4ba02cff39ed","date":1405942258,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n\n    if (!anyReal) {\n      return null;\n    } else {\n      return new SortedNumericDocValues() {\n        SortedNumericDocValues current;\n\n        @Override\n        public void setDocument(int doc) {\n          int subIndex = ReaderUtil.subIndex(doc, starts);\n          current = values[subIndex];\n          current.setDocument(doc - starts[subIndex]);\n        }\n\n        @Override\n        public long valueAt(int index) {\n          return current.valueAt(index);\n        }\n\n        @Override\n        public int count() {\n          return current.count();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11134e449dabe11d6d0ff6a564d84b82cbe93722","date":1477299083,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2714c85633b642b29871cf5ff8d17d3ba7bfd76","date":1477307753,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14b133bc4d7193efff507eb88f86fcc07c4e8b50","date":1477907694,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":["11134e449dabe11d6d0ff6a564d84b82cbe93722"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"320888923ec13b91f53082558f01f4c9960dd226","date":1477926871,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69e7e4423e7d831cd160f8300224431f499947de","date":1588858081,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedNumericValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a SortedNumericDocValues for a reader's docvalues (potentially merging on-the-fly) \n   * <p>\n   * This is a slow way to access sorted numeric values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedNumericDocValues(String)}\n   * </p> \n   * */\n  public static SortedNumericDocValues getSortedNumericValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedNumericDocValues(field);\n    }\n\n    boolean anyReal = false;\n    final SortedNumericDocValues[] values = new SortedNumericDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedNumericDocValues v = context.reader().getSortedNumericDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedNumeric(context.reader().maxDoc());\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n      totalCost += v.cost();\n    }\n    starts[size] = r.maxDoc();\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    final long finalTotalCost = totalCost;\n    \n    return new SortedNumericDocValues() {\n      private int nextLeaf;\n      private SortedNumericDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          if (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = values[nextLeaf];\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n        \n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = values[readerIndex];\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public long cost() {\n        return finalTotalCost;\n      }\n      \n      @Override\n      public int docValueCount() {\n        return currentValues.docValueCount();\n      }\n\n      @Override\n      public long nextValue() throws IOException {\n        return currentValues.nextValue();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"320888923ec13b91f53082558f01f4c9960dd226":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"69e7e4423e7d831cd160f8300224431f499947de":["14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8fa087bc3b5a2da0de8a912f76ae4ba02cff39ed"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c9fb5f46e264daf5ba3860defe623a89d202dd87","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"8fa087bc3b5a2da0de8a912f76ae4ba02cff39ed":["d14ffaac9c4a4a2c750bf0cd956506802561e062"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"14b133bc4d7193efff507eb88f86fcc07c4e8b50":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","11134e449dabe11d6d0ff6a564d84b82cbe93722"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["69e7e4423e7d831cd160f8300224431f499947de"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"320888923ec13b91f53082558f01f4c9960dd226":[],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"69e7e4423e7d831cd160f8300224431f499947de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","22aab7a3b640b0dba26cc5e9416bc7af93614b46","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"8fa087bc3b5a2da0de8a912f76ae4ba02cff39ed":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["320888923ec13b91f53082558f01f4c9960dd226"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","11134e449dabe11d6d0ff6a564d84b82cbe93722","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"14b133bc4d7193efff507eb88f86fcc07c4e8b50":["320888923ec13b91f53082558f01f4c9960dd226","69e7e4423e7d831cd160f8300224431f499947de"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","8fa087bc3b5a2da0de8a912f76ae4ba02cff39ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["320888923ec13b91f53082558f01f4c9960dd226","c6f080a2ab37c464dd98db173f6cbf10dc74f211","815972da4a13279b8e975d2e32ca450649d6c295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}