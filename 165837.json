{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeFacets#compute(NumberRangePrefixTreeStrategy,LeafReaderContext,Bits,Shape,Facets).mjava","commits":[{"id":"b2c05e4efde014c90e420f5f7c2966499682635c","date":1419397169,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeFacets#compute(NumberRangePrefixTreeStrategy,LeafReaderContext,Bits,Shape,Facets).mjava","pathOld":"/dev/null","sourceNew":"  public static Facets compute(final NumberRangePrefixTreeStrategy strategy,\n                               LeafReaderContext context, Bits acceptDocs, Shape queryShape, final Facets facets)\n      throws IOException {\n    final NumberRangePrefixTree tree = strategy.getGrid();\n    final int scanLevel = tree.getMaxLevels();\n\n    //TODO extract AbstractVisitingPrefixTreeFilter / VisitorTemplate to be generic, not necessarily a Filter/DocIdSet.\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facets.detailLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        return new VisitorTemplate(context, acceptDocs, !strategy.pointsOnly) {\n\n          Facets.FacetParentVal parentFacet;\n\n          @Override\n          protected void start() throws IOException {\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facets.detailLevel) {\n              //note: parentFacet shouldn't be null if we get here\n\n              // Count docs\n              int count = countDocsAtThisTermInSet(acceptDocs);\n              if (count > 0) {\n                //lazy init childCounts\n                if (parentFacet.childCounts == null) {\n                  parentFacet.childCounts = new int[parentFacet.childCountsLen];\n                }\n                UnitNRShape unitShape = (UnitNRShape) cell.getShape();\n                parentFacet.childCounts[unitShape.getValAtLevel(cell.getLevel())] += count;\n              }\n              return false;//don't descend further; this is enough detail\n            }\n\n            parentFacet = null;//reset\n\n            // At parent\n            if (cell.getLevel() == facets.detailLevel - 1) {\n              if (!hasDocsAtThisTermInSet(acceptDocs)) {\n                return false;\n              }\n              //Look for existing parentFacet (from previous segment)\n              UnitNRShape unitShape = (UnitNRShape) cell.getShape();\n              UnitNRShape key = unitShape.clone();\n              parentFacet = facets.parents.get(key);\n              if (parentFacet == null) {//didn't find one; make a new one\n                parentFacet = new Facets.FacetParentVal();\n                parentFacet.childCountsLen = tree.getNumSubCells(unitShape);\n                facets.parents.put(key, parentFacet);\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int levelsToGo = facets.detailLevel - cell.getLevel();\n            if (levelsToGo <= 0) {\n              return;//do nothing; we already collected in visit()\n              //note: once we index ranges without direct prefix's of leaves,\n              //  we'll need to collect here at levelsToGo==0 too.\n            }\n            int count = countDocsAtThisTermInSet(acceptDocs);\n            if (count == 0) {\n              return;\n            }\n            if (levelsToGo == 1) {\n              // Because all leaves also have an indexed non-leaf, we can be sure we have parentCell set via visit().\n              parentFacet.parentLeaves += count;\n            } else {\n              facets.topLeaves += count;\n            }\n\n          }\n\n          @Override\n          protected void visitScanned(Cell cell) throws IOException {\n            //TODO does this belong in superclass?  It ignores boolean result from visit(), but that's ok.\n            if (queryShape.relate(cell.getShape()).intersects()) {\n              if (cell.isLeaf()) {\n                visitLeaf(cell);\n              } else {\n                visit(cell);\n              }\n            }\n          }\n\n          //TODO These utility methods could move to superclass\n\n          private int countDocsAtThisTermInSet(Bits actualBaseDocs) throws IOException {\n            if (actualBaseDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(actualBaseDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTermInSet(Bits actualBaseDocs) throws IOException {\n            if (actualBaseDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(actualBaseDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n\n    return facets;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"478e85d406c2ea05f4e5028248b9a8e43f300885","date":1421346780,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeFacets#compute(NumberRangePrefixTreeStrategy,LeafReaderContext,Bits,Shape,Facets).mjava","sourceNew":null,"sourceOld":"  public static Facets compute(final NumberRangePrefixTreeStrategy strategy,\n                               LeafReaderContext context, Bits acceptDocs, Shape queryShape, final Facets facets)\n      throws IOException {\n    final NumberRangePrefixTree tree = strategy.getGrid();\n    final int scanLevel = tree.getMaxLevels();\n\n    //TODO extract AbstractVisitingPrefixTreeFilter / VisitorTemplate to be generic, not necessarily a Filter/DocIdSet.\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facets.detailLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        return new VisitorTemplate(context, acceptDocs, !strategy.pointsOnly) {\n\n          Facets.FacetParentVal parentFacet;\n\n          @Override\n          protected void start() throws IOException {\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facets.detailLevel) {\n              //note: parentFacet shouldn't be null if we get here\n\n              // Count docs\n              int count = countDocsAtThisTermInSet(acceptDocs);\n              if (count > 0) {\n                //lazy init childCounts\n                if (parentFacet.childCounts == null) {\n                  parentFacet.childCounts = new int[parentFacet.childCountsLen];\n                }\n                UnitNRShape unitShape = (UnitNRShape) cell.getShape();\n                parentFacet.childCounts[unitShape.getValAtLevel(cell.getLevel())] += count;\n              }\n              return false;//don't descend further; this is enough detail\n            }\n\n            parentFacet = null;//reset\n\n            // At parent\n            if (cell.getLevel() == facets.detailLevel - 1) {\n              if (!hasDocsAtThisTermInSet(acceptDocs)) {\n                return false;\n              }\n              //Look for existing parentFacet (from previous segment)\n              UnitNRShape unitShape = (UnitNRShape) cell.getShape();\n              UnitNRShape key = unitShape.clone();\n              parentFacet = facets.parents.get(key);\n              if (parentFacet == null) {//didn't find one; make a new one\n                parentFacet = new Facets.FacetParentVal();\n                parentFacet.childCountsLen = tree.getNumSubCells(unitShape);\n                facets.parents.put(key, parentFacet);\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int levelsToGo = facets.detailLevel - cell.getLevel();\n            if (levelsToGo <= 0) {\n              return;//do nothing; we already collected in visit()\n              //note: once we index ranges without direct prefix's of leaves,\n              //  we'll need to collect here at levelsToGo==0 too.\n            }\n            int count = countDocsAtThisTermInSet(acceptDocs);\n            if (count == 0) {\n              return;\n            }\n            if (levelsToGo == 1) {\n              // Because all leaves also have an indexed non-leaf, we can be sure we have parentCell set via visit().\n              parentFacet.parentLeaves += count;\n            } else {\n              facets.topLeaves += count;\n            }\n\n          }\n\n          @Override\n          protected void visitScanned(Cell cell) throws IOException {\n            //TODO does this belong in superclass?  It ignores boolean result from visit(), but that's ok.\n            if (queryShape.relate(cell.getShape()).intersects()) {\n              if (cell.isLeaf()) {\n                visitLeaf(cell);\n              } else {\n                visit(cell);\n              }\n            }\n          }\n\n          //TODO These utility methods could move to superclass\n\n          private int countDocsAtThisTermInSet(Bits actualBaseDocs) throws IOException {\n            if (actualBaseDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(actualBaseDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTermInSet(Bits actualBaseDocs) throws IOException {\n            if (actualBaseDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(actualBaseDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n\n    return facets;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"478e85d406c2ea05f4e5028248b9a8e43f300885":["b2c05e4efde014c90e420f5f7c2966499682635c"],"b2c05e4efde014c90e420f5f7c2966499682635c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["478e85d406c2ea05f4e5028248b9a8e43f300885"]},"commit2Childs":{"478e85d406c2ea05f4e5028248b9a8e43f300885":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b2c05e4efde014c90e420f5f7c2966499682635c":["478e85d406c2ea05f4e5028248b9a8e43f300885"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2c05e4efde014c90e420f5f7c2966499682635c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}