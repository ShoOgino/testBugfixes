{"path":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","commits":[{"id":"5f900d5ce814fc22ea498d3303d1f833f5bf320c","date":1278720761,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            DistanceUtils.EARTH_MEAN_RADIUS_MI) * DistanceUtils.RADIANS_TO_DEGREES;\n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            DistanceUtils.EARTH_MEAN_RADIUS_MI) * DistanceUtils.RADIANS_TO_DEGREES;\n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d427e79baeec73d1168c2f66f5393cab7a66d3d4","date":1285031437,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            options.radius) * DistanceUtils.RADIANS_TO_DEGREES;\n    \n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            DistanceUtils.EARTH_MEAN_RADIUS_MI) * DistanceUtils.RADIANS_TO_DEGREES;\n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6baa337076125dc01fc8cda597f52f2a9d0edcef","date":1285244980,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n    double[] ur = new double[2];\n    double[] ll = new double[2];\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    ur[LAT] = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    ur[LONG] = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    ll[LAT] = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    ll[LONG] = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    SchemaField subSF;\n    Query range;\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    //for the poles, do something slightly different\n    //Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            options.radius) * DistanceUtils.RADIANS_TO_DEGREES;\n    \n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b785b1f61f30f94f0708b16d7f2eee3ee23194ef","date":1285384789,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n    double[] ur = new double[2];\n    double[] ll = new double[2];\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    ur[LAT] = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    ur[LONG] = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    ll[LAT] = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    ll[LONG] = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    SchemaField subSF;\n    Query range;\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    //for the poles, do something slightly different\n    //Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    BooleanQuery result = new BooleanQuery();\n    double[] point = new double[0];\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    //Get the distance\n    double[] ur;\n    double[] ll;\n    if (options.measStr == null || options.measStr.equals(\"hsin\")) {\n      ur = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, true, options.radius);\n      ll = DistanceUtils.latLonCornerDegs(point[LAT], point[LONG], options.distance, null, false, options.radius);\n    } else {\n      ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);\n      ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);\n    }\n\n    SchemaField subSF;\n    Query range;\n\n    double angDistDegs = DistanceUtils.angularDistance(options.distance,\n            DistanceUtils.EARTH_MEAN_RADIUS_MI) * DistanceUtils.RADIANS_TO_DEGREES;\n    //for the poles, do something slightly different\n    if (point[LAT] + angDistDegs > 90.0) { //we cross the north pole\n      //we don't need a longitude boundary at all\n\n      double minLat = Math.min(ll[LAT], ur[LAT]);\n      subSF = subField(options.field, LAT);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              String.valueOf(minLat),\n              \"90\", true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else if (point[LAT] - angDistDegs < -90.0) {//we cross the south pole\n      subSF = subField(options.field, LAT);\n      double maxLat = Math.max(ll[LAT], ur[LAT]);\n      range = subSF.getType().getRangeQuery(parser, subSF,\n              \"-90\", String.valueOf(maxLat), true, true);\n      result.add(range, BooleanClause.Occur.MUST);\n    } else{\n        //Latitude\n        //we may need to generate multiple queries depending on the range\n        //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {\n          //TODO: refactor into common code, etc.\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } //check poles\n          else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"180.0\", \"-180.0\");\n\n        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {\n            subSF = subField(options.field, LAT);\n            //not crossing the equator\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n          }\n          //Longitude\n          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], \"0.0\", \".0\");\n\n        } else {// we are all in the Eastern or Western hemi\n          //Now check other side of the Equator\n          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {\n            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);\n          } else {//we are all in either the Northern or the Southern Hemi.\n            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since\n            //this is actually the most likely case\n            subSF = subField(options.field, LAT);\n            range = subSF.getType().getRangeQuery(parser, subSF,\n                    String.valueOf(ll[LAT]),\n                    String.valueOf(ur[LAT]), true, true);\n            result.add(range, BooleanClause.Occur.MUST);\n\n          }\n          //Longitude, all in the same hemi\n          subSF = subField(options.field, LONG);\n          range = subSF.getType().getRangeQuery(parser, subSF,\n                  String.valueOf(ll[LONG]),\n                  String.valueOf(ur[LONG]), true, true);\n          result.add(range, BooleanClause.Occur.MUST);\n        }\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5f900d5ce814fc22ea498d3303d1f833f5bf320c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["b785b1f61f30f94f0708b16d7f2eee3ee23194ef"],"c26f00b574427b55127e869b935845554afde1fa":["b785b1f61f30f94f0708b16d7f2eee3ee23194ef","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d427e79baeec73d1168c2f66f5393cab7a66d3d4":["5f900d5ce814fc22ea498d3303d1f833f5bf320c"],"6baa337076125dc01fc8cda597f52f2a9d0edcef":["d427e79baeec73d1168c2f66f5393cab7a66d3d4"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["b785b1f61f30f94f0708b16d7f2eee3ee23194ef"],"5f4e87790277826a2aea119328600dfb07761f32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5f900d5ce814fc22ea498d3303d1f833f5bf320c"],"b785b1f61f30f94f0708b16d7f2eee3ee23194ef":["6baa337076125dc01fc8cda597f52f2a9d0edcef"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","b785b1f61f30f94f0708b16d7f2eee3ee23194ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"5f900d5ce814fc22ea498d3303d1f833f5bf320c":["d427e79baeec73d1168c2f66f5393cab7a66d3d4","5f4e87790277826a2aea119328600dfb07761f32"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5f900d5ce814fc22ea498d3303d1f833f5bf320c","5f4e87790277826a2aea119328600dfb07761f32"],"d427e79baeec73d1168c2f66f5393cab7a66d3d4":["6baa337076125dc01fc8cda597f52f2a9d0edcef"],"6baa337076125dc01fc8cda597f52f2a9d0edcef":["b785b1f61f30f94f0708b16d7f2eee3ee23194ef"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"b785b1f61f30f94f0708b16d7f2eee3ee23194ef":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}