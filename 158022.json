{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/pattern/PatternReplaceCharFilter#processPattern(CharSequence).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/pattern/PatternReplaceCharFilter#processPattern(CharSequence).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/pattern/PatternReplaceCharFilter#processPattern(CharSequence).mjava","sourceNew":"  /**\n   * Replace pattern in input and mark correction offsets. \n   */\n  CharSequence processPattern(CharSequence input) {\n    final Matcher m = pattern.matcher(input);\n\n    final StringBuffer cumulativeOutput = new StringBuffer();\n    int cumulative = 0;\n    int lastMatchEnd = 0;\n    while (m.find()) {\n      final int groupSize = m.end() - m.start();\n      final int skippedSize = m.start() - lastMatchEnd;\n      lastMatchEnd = m.end();\n\n      final int lengthBeforeReplacement = cumulativeOutput.length() + skippedSize;\n      m.appendReplacement(cumulativeOutput, replacement);\n      // Matcher doesn't tell us how many characters have been appended before the replacement.\n      // So we need to calculate it. Skipped characters have been added as part of appendReplacement.\n      final int replacementSize = cumulativeOutput.length() - lengthBeforeReplacement;\n\n      if (groupSize != replacementSize) {\n        if (replacementSize < groupSize) {\n          // The replacement is smaller. \n          // Add the 'backskip' to the next index after the replacement (this is possibly \n          // after the end of string, but it's fine -- it just means the last character \n          // of the replaced block doesn't reach the end of the original string.\n          cumulative += groupSize - replacementSize;\n          int atIndex = lengthBeforeReplacement + replacementSize;\n          // System.err.println(atIndex + \"!\" + cumulative);\n          addOffCorrectMap(atIndex, cumulative);\n        } else {\n          // The replacement is larger. Every new index needs to point to the last\n          // element of the original group (if any).\n          for (int i = groupSize; i < replacementSize; i++) {\n            addOffCorrectMap(lengthBeforeReplacement + i, --cumulative);\n            // System.err.println((lengthBeforeReplacement + i) + \" \" + cumulative);\n          }\n        }\n      }\n    }\n\n    // Append the remaining output, no further changes to indices.\n    m.appendTail(cumulativeOutput);\n    return cumulativeOutput;    \n  }\n\n","sourceOld":"  /**\n   * Replace pattern in input and mark correction offsets. \n   */\n  CharSequence processPattern(CharSequence input) {\n    final Matcher m = pattern.matcher(input);\n\n    final StringBuffer cumulativeOutput = new StringBuffer();\n    int cumulative = 0;\n    int lastMatchEnd = 0;\n    while (m.find()) {\n      final int groupSize = m.end() - m.start();\n      final int skippedSize = m.start() - lastMatchEnd;\n      lastMatchEnd = m.end();\n\n      final int lengthBeforeReplacement = cumulativeOutput.length() + skippedSize;\n      m.appendReplacement(cumulativeOutput, replacement);\n      // Matcher doesn't tell us how many characters have been appended before the replacement.\n      // So we need to calculate it. Skipped characters have been added as part of appendReplacement.\n      final int replacementSize = cumulativeOutput.length() - lengthBeforeReplacement;\n\n      if (groupSize != replacementSize) {\n        if (replacementSize < groupSize) {\n          // The replacement is smaller. \n          // Add the 'backskip' to the next index after the replacement (this is possibly \n          // after the end of string, but it's fine -- it just means the last character \n          // of the replaced block doesn't reach the end of the original string.\n          cumulative += groupSize - replacementSize;\n          int atIndex = lengthBeforeReplacement + replacementSize;\n          // System.err.println(atIndex + \"!\" + cumulative);\n          addOffCorrectMap(atIndex, cumulative);\n        } else {\n          // The replacement is larger. Every new index needs to point to the last\n          // element of the original group (if any).\n          for (int i = groupSize; i < replacementSize; i++) {\n            addOffCorrectMap(lengthBeforeReplacement + i, --cumulative);\n            // System.err.println((lengthBeforeReplacement + i) + \" \" + cumulative);\n          }\n        }\n      }\n    }\n\n    // Append the remaining output, no further changes to indices.\n    m.appendTail(cumulativeOutput);\n    return cumulativeOutput;    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}