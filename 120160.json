{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","commits":[{"id":"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c","date":1378490020,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30b6ad849a21206db510322a3f583ca70ae20a2f","date":1399996150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepects the appropriate mincount\n   *\n   * @see FacetParams#FACET_MINCOUNT\n   */\n  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    return getTermCounts(field, mincount, base);\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,DocSet).mjava","sourceNew":null,"sourceOld":"  /**\n   * Term counts for use in field faceting that resepects the appropriate mincount\n   *\n   * @see FacetParams#FACET_MINCOUNT\n   */\n  public NamedList<Integer> getTermCounts(String field, DocSet base) throws IOException {\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    return getTermCounts(field, mincount, base);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","30b6ad849a21206db510322a3f583ca70ae20a2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30b6ad849a21206db510322a3f583ca70ae20a2f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"56572ec06f1407c066d6b7399413178b33176cd8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","93dd449115a9247533e44bab47e8429e5dccbc6d"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["93dd449115a9247533e44bab47e8429e5dccbc6d","30b6ad849a21206db510322a3f583ca70ae20a2f","56572ec06f1407c066d6b7399413178b33176cd8"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["92751ba9273251eab6a2e379ec42a1697a32ff96","56572ec06f1407c066d6b7399413178b33176cd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"30b6ad849a21206db510322a3f583ca70ae20a2f":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}