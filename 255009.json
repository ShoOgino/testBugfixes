{"path":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","commits":[{"id":"ca70fffb953aae4d27efbfc28758033a317f39b1","date":1396371342,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    String leaderInCharge = slices.get(0).getLeader().getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0f22bca3804ce0d023464b5c35085a5f177b147","date":1396459211,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    String leaderInCharge = slices.get(0).getLeader().getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responseible of doing periodica deletes.\n   * </p>\n   * <p>\n   * In simple standalone instalations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexigraphically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreDescriptor().getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getCollection(col).getActiveSlices());\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getCollection(col).getActiveSlices());\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getActiveSlices(col));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c84df91ca6a2e8d6f26f185663112546a27f6b45","date":1536077760,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    DocCollection docCollection = zk.getClusterState().getCollection(col);\n    if (docCollection.getActiveSlicesArr().length == 0) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    List<Slice> slices = new ArrayList<>(Arrays.asList(docCollection.getActiveSlicesArr()));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    List<Slice> slices = new ArrayList<Slice>(zk.getClusterState().getCollection(col).getActiveSlices());\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    if (slices.isEmpty()) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#iAmInChargeOfPeriodicDeletes().mjava","sourceNew":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    DocCollection docCollection = zk.getClusterState().getCollection(col);\n    if (docCollection.getActiveSlicesArr().length == 0) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    List<Slice> slices = new ArrayList<>(Arrays.asList(docCollection.getActiveSlicesArr()));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, {}\",\n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Helper method that returns true if the Runnable managed by this factory \n   * should be responsible of doing periodical deletes.\n   * </p>\n   * <p>\n   * In simple standalone installations this method always returns true, \n   * but in cloud mode it will be true if and only if we are currently the leader \n   * of the (active) slice with the first name (lexicographically).\n   * </p>\n   * <p>\n   * If this method returns false, it may have also logged a message letting the user \n   * know why we aren't attempting period deletion (but it will attempt to not log \n   * this excessively)\n   * </p>\n   */\n  private boolean iAmInChargeOfPeriodicDeletes() {\n    ZkController zk = core.getCoreContainer().getZkController();\n\n    if (null == zk) return true;\n    \n    // This is a lot simpler then doing our own \"leader\" election across all replicas \n    // of all shards since:\n    //   a) we already have a per shard leader\n    //   b) shard names must be unique\n    //   c) ClusterState is already being \"watched\" by ZkController, no additional zk hits\n    //   d) there might be multiple instances of this factory (in multiple chains) per \n    //      collection, so picking an ephemeral node name for our election would be tricky\n\n    CloudDescriptor desc = core.getCoreDescriptor().getCloudDescriptor();\n    String col = desc.getCollectionName();\n\n    DocCollection docCollection = zk.getClusterState().getCollection(col);\n    if (docCollection.getActiveSlicesArr().length == 0) {\n      log.error(\"Collection {} has no active Slices?\", col);\n      return false;\n    }\n    List<Slice> slices = new ArrayList<>(Arrays.asList(docCollection.getActiveSlicesArr()));\n    Collections.sort(slices, COMPARE_SLICES_BY_NAME);\n    Replica firstSliceLeader = slices.get(0).getLeader();\n    if (null == firstSliceLeader) {\n      log.warn(\"Slice in charge of periodic deletes for {} does not currently have a leader\",\n               col);\n      return false;\n    }\n    String leaderInCharge = firstSliceLeader.getName();\n    String myCoreNodeName = desc.getCoreNodeName();\n    \n    boolean inChargeOfDeletesRightNow = leaderInCharge.equals(myCoreNodeName);\n\n    if (previouslyInChargeOfDeletes && ! inChargeOfDeletesRightNow) {\n      // don't spam the logs constantly, just log when we know that we're not the guy\n      // (the first time -- or anytime we were, but no longer are)\n      log.info(\"Not currently in charge of periodic deletes for this collection, \" + \n               \"will not trigger delete or log again until this changes\");\n    }\n\n    previouslyInChargeOfDeletes = inChargeOfDeletesRightNow;\n    return inChargeOfDeletesRightNow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0f22bca3804ce0d023464b5c35085a5f177b147"],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["344b0840364d990b29b97467bfcc766ff8325d11"],"740d649f013f07efbeb73ca854f106c60166e7c0":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"f0f22bca3804ce0d023464b5c35085a5f177b147":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"344b0840364d990b29b97467bfcc766ff8325d11":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f0f22bca3804ce0d023464b5c35085a5f177b147","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["f0f22bca3804ce0d023464b5c35085a5f177b147","0158ced21948b6626f733c1c42c1e18d94449789"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","344b0840364d990b29b97467bfcc766ff8325d11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca70fffb953aae4d27efbfc28758033a317f39b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"],"0158ced21948b6626f733c1c42c1e18d94449789":["f0f22bca3804ce0d023464b5c35085a5f177b147"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0f22bca3804ce0d023464b5c35085a5f177b147":["5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"344b0840364d990b29b97467bfcc766ff8325d11":["c84df91ca6a2e8d6f26f185663112546a27f6b45","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["344b0840364d990b29b97467bfcc766ff8325d11"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["f0f22bca3804ce0d023464b5c35085a5f177b147"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}