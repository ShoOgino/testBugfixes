{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],ParsedParams,List[StatsField],List[FacetComponent.FacetBase],List[RangeFacetRequest]).mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],ParsedParams,List[StatsField],List[FacetComponent.FacetBase],List[RangeFacetRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],ParsedParams,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField,\n                                             Deque<String> fnames, Deque<String> vnames,\n                                             ParsedParams parsed, List<StatsField> statsFields,\n                                             List<FacetComponent.FacetBase> facetQueries, List<RangeFacetRequest> facetRanges)\n      throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        final DocSet subset = getSubset(parsed.docs, sfield, fieldValue);\n        \n        addPivotQueriesAndRanges(pivot, params, subset, facetQueries, facetRanges);\n\n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, parsed.withDocs(subset));\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, parsed.withDocs(subset), statsFields, facetQueries, facetRanges) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             ParsedParams parsed, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        final DocSet subset = getSubset(parsed.docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, parsed.withDocs(subset));\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, parsed.withDocs(subset), statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}