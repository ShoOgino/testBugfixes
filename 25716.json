{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","commits":[{"id":"1419d3974886c9518c259c786492b4d3660b0b8e","date":1459180094,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","sourceNew":"  /** Returns {polyLats, polyLons} double[] array */\n  private static double[][] surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","sourceOld":"  /** Returns {polyLats, polyLons} double[] array */\n  private double[][] surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = randomLat(false);\n      double centerLon = randomLon(false);\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95ddcac9ac08381985af6eac8f8b77ba881d4ad8","date":1459477726,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  /** Returns {polyLats, polyLons} double[] array */\n  private static double[][] surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"95ddcac9ac08381985af6eac8f8b77ba881d4ad8":["1419d3974886c9518c259c786492b4d3660b0b8e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8"],"1419d3974886c9518c259c786492b4d3660b0b8e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"]},"commit2Childs":{"95ddcac9ac08381985af6eac8f8b77ba881d4ad8":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1419d3974886c9518c259c786492b4d3660b0b8e"],"1419d3974886c9518c259c786492b4d3660b0b8e":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}