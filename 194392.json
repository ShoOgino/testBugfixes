{"path":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createAllRequiredCollections(Instant,String,Map.Entry[Instant,String]).mjava","commits":[{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createAllRequiredCollections(Instant,String,Map.Entry[Instant,String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp\n   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate\n   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most\n   * recent collection. This assumption is checked when the command is executed in the overseer. When this method\n   * finds that all collections required have been created it returns the (possibly new) most recent collection.\n   * The return value is ignored by the calling code in the async preemptive case.\n   *\n   * @param docTimestamp the timestamp from the document that determines routing\n   * @param printableId an identifier for the add command used in error messages\n   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be\n   *                             the most recent collection in all cases where this method is invoked.\n   * @return The latest collection, including collections created during maintenance\n   */\n  private String createAllRequiredCollections( Instant docTimestamp, String printableId,\n                                               Map.Entry<Instant, String> targetCollectionDesc) {\n    do {\n      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {\n        case NONE:\n          return targetCollectionDesc.getValue(); // we don't need another collection\n        case ASYNC_PREEMPTIVE:\n          // can happen when preemptive interval is longer than one time slice\n          String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n          preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          return targetCollectionDesc.getValue();\n        case SYNCHRONOUS:\n          createNextCollection(targetCollectionDesc.getValue()); // *should* throw if fails for some reason but...\n          if (!updateParsedCollectionAliases()) { // thus we didn't make progress...\n            // this is not expected, even in known failure cases, but we check just in case\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n          }\n          // then retry the loop ... have to do find again in case other requests also added collections\n          // that were made visible when we called updateParsedCollectionAliases()\n          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, printableId);\n          break;\n        default:\n          throw unknownCreateType();\n\n      }\n    } while (true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createAllRequiredCollections(Instant,String,Map.Entry[Instant,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createAllRequiredCollections(Instant,String,Map.Entry[Instant,String]).mjava","sourceNew":"  /**\n   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp\n   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate\n   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most\n   * recent collection. This assumption is checked when the command is executed in the overseer. When this method\n   * finds that all collections required have been created it returns the (possibly new) most recent collection.\n   * The return value is ignored by the calling code in the async preemptive case.\n   *\n   * @param docTimestamp the timestamp from the document that determines routing\n   * @param printableId an identifier for the add command used in error messages\n   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be\n   *                             the most recent collection in all cases where this method is invoked.\n   * @return The latest collection, including collections created during maintenance\n   */\n  private String createAllRequiredCollections( Instant docTimestamp, String printableId,\n                                               Map.Entry<Instant, String> targetCollectionDesc) {\n    do {\n      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {\n        case NONE:\n          return targetCollectionDesc.getValue(); // we don't need another collection\n        case ASYNC_PREEMPTIVE:\n          // can happen when preemptive interval is longer than one time slice\n          if (!preemptiveCreateOnceAlready) {\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n            return targetCollectionDesc.getValue();\n          }\n        case SYNCHRONOUS:\n          createNextCollection(targetCollectionDesc.getValue()); // *should* throw if fails for some reason but...\n          if (!updateParsedCollectionAliases()) { // thus we didn't make progress...\n            // this is not expected, even in known failure cases, but we check just in case\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n          }\n          // then retry the loop ... have to do find again in case other requests also added collections\n          // that were made visible when we called updateParsedCollectionAliases()\n          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, printableId);\n          break;\n        default:\n          throw unknownCreateType();\n      }\n    } while (true);\n  }\n\n","sourceOld":"  /**\n   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp\n   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate\n   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most\n   * recent collection. This assumption is checked when the command is executed in the overseer. When this method\n   * finds that all collections required have been created it returns the (possibly new) most recent collection.\n   * The return value is ignored by the calling code in the async preemptive case.\n   *\n   * @param docTimestamp the timestamp from the document that determines routing\n   * @param printableId an identifier for the add command used in error messages\n   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be\n   *                             the most recent collection in all cases where this method is invoked.\n   * @return The latest collection, including collections created during maintenance\n   */\n  private String createAllRequiredCollections( Instant docTimestamp, String printableId,\n                                               Map.Entry<Instant, String> targetCollectionDesc) {\n    do {\n      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {\n        case NONE:\n          return targetCollectionDesc.getValue(); // we don't need another collection\n        case ASYNC_PREEMPTIVE:\n          // can happen when preemptive interval is longer than one time slice\n          String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n          preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          return targetCollectionDesc.getValue();\n        case SYNCHRONOUS:\n          createNextCollection(targetCollectionDesc.getValue()); // *should* throw if fails for some reason but...\n          if (!updateParsedCollectionAliases()) { // thus we didn't make progress...\n            // this is not expected, even in known failure cases, but we check just in case\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n          }\n          // then retry the loop ... have to do find again in case other requests also added collections\n          // that were made visible when we called updateParsedCollectionAliases()\n          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, printableId);\n          break;\n        default:\n          throw unknownCreateType();\n\n      }\n    } while (true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":5,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createAllRequiredCollections(Instant,AddUpdateCommand,Map.Entry[Instant,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createAllRequiredCollections(Instant,String,Map.Entry[Instant,String]).mjava","sourceNew":"  /**\n   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp\n   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate\n   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most\n   * recent collection. This assumption is checked when the command is executed in the overseer. When this method\n   * finds that all collections required have been created it returns the (possibly new) most recent collection.\n   * The return value is ignored by the calling code in the async preemptive case.\n   *\n   * @param docTimestamp the timestamp from the document that determines routing\n   * @param cmd the update command being processed\n   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be\n   *                             the most recent collection in all cases where this method is invoked.\n   * @return The latest collection, including collections created during maintenance\n   */\n  private String createAllRequiredCollections( Instant docTimestamp, AddUpdateCommand cmd,\n                                               Map.Entry<Instant, String> targetCollectionDesc) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    do {\n      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {\n        case NONE:\n          return targetCollectionDesc.getValue(); // we don't need another collection\n        case ASYNC_PREEMPTIVE:\n          // can happen when preemptive interval is longer than one time slice\n          String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n          preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          return targetCollectionDesc.getValue();\n        case SYNCHRONOUS:\n          createNextCollection(targetCollectionDesc.getValue(), collectionsHandler); // *should* throw if fails for some reason but...\n          ZkController zkController = coreContainer.getZkController();\n          if (!updateParsedCollectionAliases(zkController)) { // thus we didn't make progress...\n            // this is not expected, even in known failure cases, but we check just in case\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n          }\n          // then retry the loop ... have to do find again in case other requests also added collections\n          // that were made visible when we called updateParsedCollectionAliases()\n          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n          break;\n        default:\n          throw unknownCreateType();\n\n      }\n    } while (true);\n  }\n\n","sourceOld":"  /**\n   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp\n   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate\n   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most\n   * recent collection. This assumption is checked when the command is executed in the overseer. When this method\n   * finds that all collections required have been created it returns the (possibly new) most recent collection.\n   * The return value is ignored by the calling code in the async preemptive case.\n   *\n   * @param docTimestamp the timestamp from the document that determines routing\n   * @param printableId an identifier for the add command used in error messages\n   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be\n   *                             the most recent collection in all cases where this method is invoked.\n   * @return The latest collection, including collections created during maintenance\n   */\n  private String createAllRequiredCollections( Instant docTimestamp, String printableId,\n                                               Map.Entry<Instant, String> targetCollectionDesc) {\n    do {\n      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {\n        case NONE:\n          return targetCollectionDesc.getValue(); // we don't need another collection\n        case ASYNC_PREEMPTIVE:\n          // can happen when preemptive interval is longer than one time slice\n          if (!preemptiveCreateOnceAlready) {\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n            return targetCollectionDesc.getValue();\n          }\n        case SYNCHRONOUS:\n          createNextCollection(targetCollectionDesc.getValue()); // *should* throw if fails for some reason but...\n          if (!updateParsedCollectionAliases()) { // thus we didn't make progress...\n            // this is not expected, even in known failure cases, but we check just in case\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n          }\n          // then retry the loop ... have to do find again in case other requests also added collections\n          // that were made visible when we called updateParsedCollectionAliases()\n          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, printableId);\n          break;\n        default:\n          throw unknownCreateType();\n      }\n    } while (true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b627755385655c7cd3fb296f17593658805cf4d5"]},"commit2Childs":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"b627755385655c7cd3fb296f17593658805cf4d5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["b627755385655c7cd3fb296f17593658805cf4d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}