{"path":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","commits":[{"id":"e6ed55563ddbb365606dd561360472978ec2115f","date":1335981033,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"/dev/null","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39342cb658ac11dfcbf4459807fb00eb9ada0218","date":1472876688,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n        // TODO: allow method to be passed on local params?\n\n        params.set(\"facet.method\", method);\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      \n      for (String method : methods) {\n        for (boolean exists : new boolean[]{false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            if (exists && sf.getType().isPointField()) {\n              // PointFields don't yet support \"enum\" method or the \"facet.exists\" parameter\n              assertQEx(\"Expecting failure, since \", \n                  \"facet.exists=true is requested, but facet.method=enum can't be used with \" + sf.getName(), \n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      \n      for (String method : methods) {\n        for (boolean exists : new boolean[]{false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            if (exists && sf.getType().isPointField()) {\n              // PointFields don't yet support \"enum\" method or the \"facet.exists\" parameter\n              assertQEx(\"Expecting failure, since \", \n                  \"facet.exists=true is requested, but facet.method=enum can't be used with \" + sf.getName(), \n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        for (boolean exists : new boolean [] {false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          \n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7679cc7d5b465ec8936979698cedf5fdbd71c95c","date":1566227764,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      \n      for (String method : methods) {\n        for (boolean exists : new boolean[]{false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (!(params.getInt(\"facet.limit\", 100) == 0 &&\n              !params.getBool(\"facet.missing\", false))) {\n            // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS\n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\",\n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            if (exists && sf.getType().isPointField()) {\n              // PointFields don't yet support \"enum\" method or the \"facet.exists\" parameter\n              assertQEx(\"Expecting failure, since \",\n                  \"facet.exists=true is requested, but facet.method=enum can't be used with \" + sf.getName(),\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.enum.cache.minDf\",\"\"+ rand.nextInt(indexSize));\n      }\n      \n      // TODO: randomly add other facet params\n      String key = ftype.fname;\n      String facet_field = ftype.fname;\n      if (random().nextBoolean()) {\n        key = \"alternate_key\";\n        facet_field = \"{!key=\"+key+\"}\"+ftype.fname;\n      }\n      params.set(\"facet.field\", facet_field);\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      \n      for (String method : methods) {\n        for (boolean exists : new boolean[]{false, true}) {\n          // params.add(\"facet.field\", \"{!key=\"+method+\"}\" + ftype.fname);\n          // TODO: allow method to be passed on local params?\n          if (method!=null) {\n            params.set(\"facet.method\", method);\n          } else {\n            params.remove(\"facet.method\");\n          }\n          params.set(\"facet.exists\", \"\"+exists);\n          if (!exists && rand.nextBoolean()) {\n            params.remove(\"facet.exists\");\n          }\n          \n          // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n          if (params.getInt(\"facet.limit\", 100)!=0) { // it bypasses all processing, and we can go to empty validation\n            if (exists && params.getInt(\"facet.mincount\", 0)>1) {\n              assertQEx(\"no mincount on facet.exists\",\n                  rand.nextBoolean() ? \"facet.exists\":\"facet.mincount\",\n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            // facet.exists can't be combined with non-enum nor with enum requested for tries, because it will be flipped to FC/FCS \n            final boolean notEnum = method != null && !method.equals(\"enum\");\n            final boolean trieField = trieFields.matcher(ftype.fname).matches();\n            if ((notEnum || trieField) && exists) {\n              assertQEx(\"facet.exists only when enum or ommitted\", \n                  \"facet.exists\", req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n            if (exists && sf.getType().isPointField()) {\n              // PointFields don't yet support \"enum\" method or the \"facet.exists\" parameter\n              assertQEx(\"Expecting failure, since \", \n                  \"facet.exists=true is requested, but facet.method=enum can't be used with \" + sf.getName(), \n                  req(params), ErrorCode.BAD_REQUEST);\n              continue;\n            }\n          }\n          String strResponse = h.query(req(params));\n          responses.add(strResponse);\n          \n          if (responses.size()>1) {\n            validateResponse(responses.get(0), strResponse, params, method, methods);\n          }\n        }\n        \n      }\n      \n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":["39342cb658ac11dfcbf4459807fb00eb9ada0218","46dc9ac8b3e748407baaef82453138ff3974480c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"46dc9ac8b3e748407baaef82453138ff3974480c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["e6ed55563ddbb365606dd561360472978ec2115f"],"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["46dc9ac8b3e748407baaef82453138ff3974480c"],"e6ed55563ddbb365606dd561360472978ec2115f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc8f206328a706450934717bec7ccc22ad166fc0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","39342cb658ac11dfcbf4459807fb00eb9ada0218"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","46dc9ac8b3e748407baaef82453138ff3974480c"],"89424def13674ea17829b41c5883c54ecc31a132":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","bc8f206328a706450934717bec7ccc22ad166fc0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","89424def13674ea17829b41c5883c54ecc31a132"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bc8f206328a706450934717bec7ccc22ad166fc0","39342cb658ac11dfcbf4459807fb00eb9ada0218","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"46dc9ac8b3e748407baaef82453138ff3974480c":["7679cc7d5b465ec8936979698cedf5fdbd71c95c","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"e6ed55563ddbb365606dd561360472978ec2115f":["6613659748fe4411a7dcf85266e55db1f95f7315"],"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc8f206328a706450934717bec7ccc22ad166fc0":["89424def13674ea17829b41c5883c54ecc31a132"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["bc8f206328a706450934717bec7ccc22ad166fc0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["46dc9ac8b3e748407baaef82453138ff3974480c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e6ed55563ddbb365606dd561360472978ec2115f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}