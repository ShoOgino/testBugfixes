{"path":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","commits":[{"id":"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299","date":1460106403,"type":1,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"444d4b906d0e3398f87d6a5c4967c508f11a7f0b","date":1466507434,"type":5,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(IndexReader,Classifier[T],String,String,long).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link IndexReader}, class and text fields.\n   *\n   * @param reader              the {@link IndexReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(IndexReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"444d4b906d0e3398f87d6a5c4967c508f11a7f0b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","444d4b906d0e3398f87d6a5c4967c508f11a7f0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["444d4b906d0e3398f87d6a5c4967c508f11a7f0b"]},"commit2Childs":{"444d4b906d0e3398f87d6a5c4967c508f11a7f0b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["444d4b906d0e3398f87d6a5c4967c508f11a7f0b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}