{"path":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}