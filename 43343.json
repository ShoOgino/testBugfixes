{"path":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","commits":[{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = getMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return 0.0f;\n      }\n      \n      //let's make sure we have enough room in our array to do the distance calculations.\n      if (d[0].length <= m) {\n        growDistanceArray(m);\n      }\n      \n      // init matrix d\n      for (int i = 0; i <= n; i++) d[i][0] = i;\n      for (int j = 0; j <= m; j++) d[0][j] = j;\n      \n      // start computing edit distance\n      for (int i = 1; i <= n; i++) {\n        int bestPossibleEditDistance = m;\n        final int s_i = text[i - 1];\n        for (int j = 1; j <= m; j++) {\n          if (s_i != target[offset+j-1]) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n          }\n          else {\n            d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n        }\n        \n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n        \n        if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return 0.0f;\n        }\n      }\n      \n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)d[n][m] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"971c6449b5391e0af36ec7578133d205a03e2836","date":1281210435,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return 0.0f;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return 0.0f;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = getMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return 0.0f;\n      }\n      \n      //let's make sure we have enough room in our array to do the distance calculations.\n      if (d[0].length <= m) {\n        growDistanceArray(m);\n      }\n      \n      // init matrix d\n      for (int i = 0; i <= n; i++) d[i][0] = i;\n      for (int j = 0; j <= m; j++) d[0][j] = j;\n      \n      // start computing edit distance\n      for (int i = 1; i <= n; i++) {\n        int bestPossibleEditDistance = m;\n        final int s_i = text[i - 1];\n        for (int j = 1; j <= m; j++) {\n          if (s_i != target[offset+j-1]) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n          }\n          else {\n            d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n        }\n        \n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n        \n        if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return 0.0f;\n        }\n      }\n      \n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)d[n][m] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a4d59223802237d352245759cf541e315aab20a","date":1285686672,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return 0.0f;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return 0.0f;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = getMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return 0.0f;\n      }\n      \n      //let's make sure we have enough room in our array to do the distance calculations.\n      if (d[0].length <= m) {\n        growDistanceArray(m);\n      }\n      \n      // init matrix d\n      for (int i = 0; i <= n; i++) d[i][0] = i;\n      for (int j = 0; j <= m; j++) d[0][j] = j;\n      \n      // start computing edit distance\n      for (int i = 1; i <= n; i++) {\n        int bestPossibleEditDistance = m;\n        final int s_i = text[i - 1];\n        for (int j = 1; j <= m; j++) {\n          if (s_i != target[offset+j-1]) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n          }\n          else {\n            d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n        }\n        \n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n        \n        if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return 0.0f;\n        }\n      }\n      \n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)d[n][m] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["3a4d59223802237d352245759cf541e315aab20a"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3a4d59223802237d352245759cf541e315aab20a":["971c6449b5391e0af36ec7578133d205a03e2836"],"971c6449b5391e0af36ec7578133d205a03e2836":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","3a4d59223802237d352245759cf541e315aab20a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["971c6449b5391e0af36ec7578133d205a03e2836","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"3a4d59223802237d352245759cf541e315aab20a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"971c6449b5391e0af36ec7578133d205a03e2836":["3a4d59223802237d352245759cf541e315aab20a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}