{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      List<String> nodeList = new ArrayList<>();\n      List<String> shardNames = new ArrayList<>();\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      ocmh.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n      \n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we don't see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      List<String> nodeList = new ArrayList<>();\n      List<String> shardNames = new ArrayList<>();\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      ocmh.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n      \n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we don't see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      List<String> nodeList = new ArrayList<>();\n      List<String> shardNames = new ArrayList<>();\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      ocmh.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n      \n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we don't see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      List<String> nodeList = new ArrayList<>();\n      List<String> shardNames = new ArrayList<>();\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      ocmh.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n      \n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we don't see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      List<String> nodeList = new ArrayList<>();\n      List<String> shardNames = new ArrayList<>();\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      ocmh.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n      \n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we don't see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"187d1494fb1ccc3d96d5ddc25fcfb0dae22ca1e8","date":1534496190,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bf8a7ced1e96b646081915c332618d854944666e","date":1535687605,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n            nodeList, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n          nodeList, shardNames, sessionWrapper);\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ccfa992b91fcebaecaa804a2bffd48542ef2e939","ccfa992b91fcebaecaa804a2bffd48542ef2e939"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    List<String> nodeList = new ArrayList<>();\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, message,\n            nodeList, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (nodeList.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"216382c52eb6bf24fc72851399bb3750e8ad7a97","date":1538562171,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    boolean usePolicyFramework = CloudUtil.usePolicyFramework(ocmh.cloudManager) || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = ocmh.cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01322d51122b6cbe6b5ba6059fffba67798dae72","date":1539067228,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = message.getStr(Policy.POLICY);\n    boolean usePolicyFramework = CloudUtil.usePolicyFramework(ocmh.cloudManager) || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkMaxShardsPerNode(message, usePolicyFramework);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":["27639bb5e041490ce599065875dd2f6d8beef62a","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","19498030e0adab22f604f935cae3c03dcf0952a6"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab6131420a270c49b653c969cc1dbbaf7d1b36e7","date":1550697886,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":["66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        return;\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      if(results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95cd5a38a855e021b63ce0a52cd6e43d358c8c61","date":1556473589,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        return;\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      // For tracking async calls.\n      Map<String, String> requestMap = new HashMap<>();\n\n\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          requestMap.put(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      ocmh.processResponses(results, shardHandler, false, null, async, requestMap, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","3bbb741690cdafda7f1f7549c26351c912917a69","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6e5eb1137994855cee975febe08850fcb7726d3","date":1558358375,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection\n      ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b366e7dd3172289251a86be96031af4002cd19c","date":1560790783,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName) || aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f97fc3d287be2a8d7f513f0de3249b50dda47299","date":1568378558,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (String propName : collectionProps.keySet()) {\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) collectionProps.get(propName));\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccfa992b91fcebaecaa804a2bffd48542ef2e939","date":1579772993,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":["bf8a7ced1e96b646081915c332618d854944666e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ea07d22cef2406e950de111f8aa7bc2edb91d56","date":1581094599,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n          collectionName, shardNames, message));\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n            , coreName, replicaPosition.shard, collectionName, nodeName));\n\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the \" + COLOCATED_WITH + \" property set on collection: \" + withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n      boolean isLegacyCloud = Overseer.isLegacy(zkStateReader);\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName, isLegacyCloud);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        //in the new mode, create the replica in clusterstate prior to creating the core.\n        // Otherwise the core creation fails\n        if (!isLegacyCloud) {\n          ZkNodeProps props = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n              ZkStateReader.CORE_NAME_PROP, coreName,\n              ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n              ZkStateReader.BASE_URL_PROP, baseUrl,\n              ZkStateReader.NODE_NAME_PROP, nodeName,\n              ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n              CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        }\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        if (isLegacyCloud) {\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        } else {\n          coresToCreate.put(coreName, sreq);\n        }\n      }\n\n      if(!isLegacyCloud) {\n        // wait for all replica entries to be created\n        Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n        for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n          ShardRequest sreq = e.getValue();\n          sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n          shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n        }\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":["840fc95f31a25d020cd825e880018bcfa0bacc71","33d0ed80b7b47e34ad3ff033a77544563aba3085","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","2bcfee499548996a6e5448bbf93b8f276d010270","f291d2d430e8149d24fdd06b0bcdab0941ec9144","8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","3ea07d22cef2406e950de111f8aa7bc2edb91d56","eb4db141b31e99d2285436da1428411ed5501f56","27639bb5e041490ce599065875dd2f6d8beef62a","0d92226151c91fb4bebcca6d18782d1c84aee2cd","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames, sessionWrapper);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, cloudConfig, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, cloudConfig, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(cloudConfig, collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, cloudConfig, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, cloudConfig, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(cloudConfig, collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1852cb03cf4922477072449dd9de2fab588d1adb","date":1600862151,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"c526352db87264a72a7a9ad68c1b769b81e54305":["3f504512a03d978990cbff30db0522b354e846db"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"7b366e7dd3172289251a86be96031af4002cd19c":["b6e5eb1137994855cee975febe08850fcb7726d3"],"1852cb03cf4922477072449dd9de2fab588d1adb":["e7b17e79a71117668ecbf8d3417c876e41396565"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["7b366e7dd3172289251a86be96031af4002cd19c"],"01322d51122b6cbe6b5ba6059fffba67798dae72":["216382c52eb6bf24fc72851399bb3750e8ad7a97"],"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"187d1494fb1ccc3d96d5ddc25fcfb0dae22ca1e8":["27639bb5e041490ce599065875dd2f6d8beef62a"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"3ea07d22cef2406e950de111f8aa7bc2edb91d56":["ccfa992b91fcebaecaa804a2bffd48542ef2e939"],"95cd5a38a855e021b63ce0a52cd6e43d358c8c61":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"3f504512a03d978990cbff30db0522b354e846db":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"bf8a7ced1e96b646081915c332618d854944666e":["187d1494fb1ccc3d96d5ddc25fcfb0dae22ca1e8"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["bf8a7ced1e96b646081915c332618d854944666e"],"216382c52eb6bf24fc72851399bb3750e8ad7a97":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4abf821a41a2fdca2a1dea148999931d22e20529":["3ea07d22cef2406e950de111f8aa7bc2edb91d56"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"69e6520a21709190413a63084ed135271aab1a7c":["95cd5a38a855e021b63ce0a52cd6e43d358c8c61"],"b6e5eb1137994855cee975febe08850fcb7726d3":["69e6520a21709190413a63084ed135271aab1a7c"],"ccfa992b91fcebaecaa804a2bffd48542ef2e939":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"27639bb5e041490ce599065875dd2f6d8beef62a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1852cb03cf4922477072449dd9de2fab588d1adb"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["27639bb5e041490ce599065875dd2f6d8beef62a"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["3f504512a03d978990cbff30db0522b354e846db"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"7b366e7dd3172289251a86be96031af4002cd19c":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"1852cb03cf4922477072449dd9de2fab588d1adb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"01322d51122b6cbe6b5ba6059fffba67798dae72":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"187d1494fb1ccc3d96d5ddc25fcfb0dae22ca1e8":["bf8a7ced1e96b646081915c332618d854944666e"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["ccfa992b91fcebaecaa804a2bffd48542ef2e939"],"3ea07d22cef2406e950de111f8aa7bc2edb91d56":["4abf821a41a2fdca2a1dea148999931d22e20529"],"95cd5a38a855e021b63ce0a52cd6e43d358c8c61":["69e6520a21709190413a63084ed135271aab1a7c"],"e7b17e79a71117668ecbf8d3417c876e41396565":["1852cb03cf4922477072449dd9de2fab588d1adb"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"3f504512a03d978990cbff30db0522b354e846db":["c526352db87264a72a7a9ad68c1b769b81e54305"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["95cd5a38a855e021b63ce0a52cd6e43d358c8c61"],"bf8a7ced1e96b646081915c332618d854944666e":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["216382c52eb6bf24fc72851399bb3750e8ad7a97"],"216382c52eb6bf24fc72851399bb3750e8ad7a97":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"69e6520a21709190413a63084ed135271aab1a7c":["b6e5eb1137994855cee975febe08850fcb7726d3"],"b6e5eb1137994855cee975febe08850fcb7726d3":["7b366e7dd3172289251a86be96031af4002cd19c"],"ccfa992b91fcebaecaa804a2bffd48542ef2e939":["3ea07d22cef2406e950de111f8aa7bc2edb91d56"],"27639bb5e041490ce599065875dd2f6d8beef62a":["187d1494fb1ccc3d96d5ddc25fcfb0dae22ca1e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}