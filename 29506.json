{"path":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2","date":1341667852,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bb889a868ab9d608bde8136f42ed7234a3a927b","date":1359393528,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false;\n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setAlgLineNum(stok.lineno());\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them - allow recursive parenthetical expressions\n            stok.eolIsSignificant(true);  // Allow params tokenizer to keep track of line number\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            if (stok.ttype != ')') {\n              int count = 1;\n              BALANCED_PARENS: while (true) {\n                switch (stok.ttype) {\n                  case StreamTokenizer.TT_NUMBER: {\n                    params.append(stok.nval);\n                    break;\n                  }\n                  case StreamTokenizer.TT_WORD: {\n                    params.append(stok.sval);\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpexted EOF: - \"+stok.toString());\n                  }\n                  case '\"':\n                  case '\\'': {\n                    params.append((char)stok.ttype);\n                    // re-escape delimiters, if any\n                    params.append(stok.sval.replaceAll(\"\" + (char)stok.ttype, \"\\\\\\\\\" + (char)stok.ttype));\n                    params.append((char)stok.ttype);\n                    break;\n                  }\n                  case '(': {\n                    params.append((char)stok.ttype);\n                    ++count;\n                    break;\n                  }\n                  case ')': {\n                    if (--count >= 1) {  // exclude final closing parenthesis\n                      params.append((char)stok.ttype);\n                    } else {\n                      break BALANCED_PARENS;\n                    }\n                    break;\n                  }\n                  default: {\n                    params.append((char)stok.ttype);\n                  }\n                }\n                stok.nextToken();\n              }\n            }\n            stok.eolIsSignificant(false);\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                name = stok.sval;\n                if (stok.ttype!='\"' || name==null || name.length()==0) {\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false;\n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setAlgLineNum(stok.lineno());\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them - allow recursive parenthetical expressions\n            stok.eolIsSignificant(true);  // Allow params tokenizer to keep track of line number\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            if (stok.ttype != ')') {\n              int count = 1;\n              BALANCED_PARENS: while (true) {\n                switch (stok.ttype) {\n                  case StreamTokenizer.TT_NUMBER: {\n                    params.append(stok.nval);\n                    break;\n                  }\n                  case StreamTokenizer.TT_WORD: {\n                    params.append(stok.sval);\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpexted EOF: - \"+stok.toString());\n                  }\n                  case '\"':\n                  case '\\'': {\n                    params.append((char)stok.ttype);\n                    // re-escape delimiters, if any\n                    params.append(stok.sval.replaceAll(\"\" + (char)stok.ttype, \"\\\\\\\\\" + (char)stok.ttype));\n                    params.append((char)stok.ttype);\n                    break;\n                  }\n                  case '(': {\n                    params.append((char)stok.ttype);\n                    ++count;\n                    break;\n                  }\n                  case ')': {\n                    if (--count >= 1) {  // exclude final closing parenthesis\n                      params.append((char)stok.ttype);\n                    } else {\n                      break BALANCED_PARENS;\n                    }\n                    break;\n                  }\n                  default: {\n                    params.append((char)stok.ttype);\n                  }\n                }\n                stok.nextToken();\n              }\n            }\n            stok.eolIsSignificant(false);\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                name = stok.sval;\n                if (stok.ttype!='\"' || name==null || name.length()==0) {\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase(Locale.ROOT);\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["b89678825b68eccaf09e6ab71675fc0b0af1e099","1e2d1edb0d4b63db0ffa514a529fb559609dbcd2"],"de522d9303bd67c8473a269a1319125d1f3700e0":["2acf500f78aa12b92e371fd89c719291986b6b90","7bb889a868ab9d608bde8136f42ed7234a3a927b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7bb889a868ab9d608bde8136f42ed7234a3a927b"],"46d8ada1fff8d18cb197c38c7983225162599948":["b89678825b68eccaf09e6ab71675fc0b0af1e099","2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["1e2d1edb0d4b63db0ffa514a529fb559609dbcd2","fe33227f6805edab2036cbb80645cc4e2d1fa424","2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948"],"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2":["2acf500f78aa12b92e371fd89c719291986b6b90"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2acf500f78aa12b92e371fd89c719291986b6b90":["fe33227f6805edab2036cbb80645cc4e2d1fa424","7bb889a868ab9d608bde8136f42ed7234a3a927b","de522d9303bd67c8473a269a1319125d1f3700e0","46d8ada1fff8d18cb197c38c7983225162599948"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"46d8ada1fff8d18cb197c38c7983225162599948":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817","46d8ada1fff8d18cb197c38c7983225162599948"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}