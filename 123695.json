{"path":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copyBytes(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copyBytes(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copyBytes(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copyBytes(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}