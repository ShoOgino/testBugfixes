{"path":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","commits":[{"id":"4a4e2c829188fb99886a64558664d79c9ac0fdf1","date":1431021538,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test user input errors (split into it's own test to isolate ignored exceptions\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c342e04e879b5c549539944338f5ec0ff3000f3","date":1539630497,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","sourceNew":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","sourceOld":"  /**\n   * Test user input errors (split into it's own test to isolate ignored exceptions\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1a307447328c95a00248512b40d7a5ff12ecd6a","date":1564817449,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","sourceNew":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    // whitebox - function\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n    });\n    assertTrue(\"MSG: \" + ex.getMessage(),\n        ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"number between 0 and 1\"));\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllLog2m\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"hllLog2m must be\"));\n\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n            \"hllRegwidth\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllRegwidth must be\"));\n\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","sourceOld":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","sourceNew":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    // whitebox - function\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n    });\n    assertTrue(\"MSG: \" + ex.getMessage(),\n        ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"number between 0 and 1\"));\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllLog2m\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"hllLog2m must be\"));\n\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n            \"hllRegwidth\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllRegwidth must be\"));\n\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","sourceOld":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan HÃ¸ydahl","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptionsErrors().mjava","sourceNew":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    // whitebox - function\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n    });\n    assertTrue(\"MSG: \" + ex.getMessage(),\n        ex.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"number between 0 and 1\"));\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllLog2m\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(), ex.getMessage().contains(\"hllLog2m must be\"));\n\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      ex = expectThrows(SolrException.class, () -> {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n            \"hllRegwidth\", \"\"+invalid), foo_s);\n      });\n      assertTrue(\"MSG: \" + ex.getMessage(),\n          ex.getMessage().contains(\"hllRegwidth must be\"));\n\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","sourceOld":"  /**\n   * Test user input errors (split into its own test to isolate ignored exceptions)\n   * @see #testCardinality \n   * @see #testHllOptions\n   */\n  public void testHllOptionsErrors() throws Exception {\n    String[] baseParams = new String[] { \"q\",\"*:*\", \"stats\",\"true\", \"indent\",\"true\", \"rows\",\"0\" };\n    SolrCore core = h.getCore();\n    SchemaField foo_s = core.getLatestSchema().getField(\"foo_s\");\n    SchemaField foo_i = core.getLatestSchema().getField(\"foo_i\");\n\n    ignoreException(\"hllPreHashed\");\n    for (SchemaField field : new SchemaField[] { foo_s, foo_i }) {\n      // whitebox - field\n      try {\n        HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), field);\n        fail(\"hllPreHashed should have failed for \" + field.getName());\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n      }\n      // blackbox - field\n      assertQEx(\"hllPreHashed \" + field.getName(), \"hllPreHashed is only supported with Long\",\n                req(params(\"stats.field\",\"{!cardinality=true hllPreHashed=true}\" + field.getName()),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    // whitebox - function\n    try {\n      HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), null);\n      fail(\"hllPreHashed should have failed for function\");\n    } catch (SolrException e) {\n      assertTrue(\"MSG: \" + e.getMessage(),\n                 e.getMessage().contains(\"hllPreHashed is only supported with Long\"));\n    }\n    // blackbox - function\n    assertQEx(\"hllPreHashed function\", \"hllPreHashed is only supported with Long\",\n              req(params(\"stats.field\",\"{!func cardinality=true hllPreHashed=true}sum(foo_i,foo_l)\"),\n                  baseParams),\n              ErrorCode.BAD_REQUEST);\n\n\n    ignoreException(\"accuracy\");\n    for (String invalid : new String[] { \"-1\", \"1.1\", \"100\" }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"number between 0 and 1\"));\n      }\n      // blackbox\n      assertQEx(\"cardinality=\"+invalid, \"number between 0 and 1\",\n                req(params(\"stats.field\",\"{!cardinality=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n    \n    ignoreException(\"hllLog2m must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_LOG2M_PARAM-1, HLL.MAXIMUM_LOG2M_PARAM+11 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllLog2m\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllLog2m must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllLog2m=\"+invalid, \"hllLog2m must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllLog2m=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n\n    ignoreException(\"hllRegwidth must be\");\n    for (int invalid : new int[] { HLL.MINIMUM_REGWIDTH_PARAM-1, HLL.MAXIMUM_REGWIDTH_PARAM+1 }) {\n      // whitebox\n      try {\n        Object trash = HllOptions.parseHllOptions(params(\"cardinality\",\"true\",\n                                                         \"hllRegwidth\", \"\"+invalid), foo_s);\n        fail(\"Should have failed: \" + invalid);\n      } catch (SolrException e) {\n        assertTrue(\"MSG: \" + e.getMessage(),\n                   e.getMessage().contains(\"hllRegwidth must be\"));\n      }\n      // blackbox\n      assertQEx(\"hllRegwidth=\"+invalid, \"hllRegwidth must be\",\n                req(params(\"stats.field\",\"{!cardinality=true hllRegwidth=\"+invalid+\"}foo_s\"),\n                    baseParams),\n                ErrorCode.BAD_REQUEST);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["5c342e04e879b5c549539944338f5ec0ff3000f3","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"f8061ddd97f3352007d927dae445884a6f3d857b":["5c342e04e879b5c549539944338f5ec0ff3000f3","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d1a307447328c95a00248512b40d7a5ff12ecd6a"]},"commit2Childs":{"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["d1a307447328c95a00248512b40d7a5ff12ecd6a","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}