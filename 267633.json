{"path":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        return comp.compare(pool.setBytesRef(scratch1, bytesStart[ord1]),\n          pool.setBytesRef(scratch2, bytesStart[ord2]));\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        return comp.compare(pivot,\n          pool.setBytesRef(scratch2, bytesStart[ord]));\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        return comp.compare(pool.setBytesRef(scratch1, bytesStart[ord1]),\n          pool.setBytesRef(scratch2, bytesStart[ord2]));\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        return comp.compare(pivot,\n          pool.setBytesRef(scratch2, bytesStart[ord]));\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"caa40272511a69bd4ad04b8242ae420932f5799b","date":1359341326,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        pool.setBytesRef(scratch1, bytesStart[ord1]);\n        pool.setBytesRef(scratch2, bytesStart[ord2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(scratch2, bytesStart[ord]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        return comp.compare(pool.setBytesRef(scratch1, bytesStart[ord1]),\n          pool.setBytesRef(scratch2, bytesStart[ord2]));\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        return comp.compare(pivot,\n          pool.setBytesRef(scratch2, bytesStart[ord]));\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        pool.setBytesRef(scratch1, bytesStart[ord1]);\n        pool.setBytesRef(scratch2, bytesStart[ord2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(scratch2, bytesStart[ord]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        return comp.compare(pool.setBytesRef(scratch1, bytesStart[ord1]),\n          pool.setBytesRef(scratch2, bytesStart[ord2]));\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        return comp.compare(pivot,\n          pool.setBytesRef(scratch2, bytesStart[ord]));\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","bugFix":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbccaf0f052c2a25526a56531803c5ebac7c8f41","date":1363510731,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int ord1 = compact[i], ord2 = compact[j];\n        assert bytesStart.length > ord1 && bytesStart.length > ord2;\n        pool.setBytesRef(scratch1, bytesStart[ord1]);\n        pool.setBytesRef(scratch2, bytesStart[ord2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int ord = compact[i];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(pivot, bytesStart[ord]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int ord = compact[j];\n        assert bytesStart.length > ord;\n        pool.setBytesRef(scratch2, bytesStart[ord]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc555744b1a581a4beccd0b75f8d3fe49735a2f","date":1367588265,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.quickSort(0, count - 1);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91","date":1456586780,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final Comparator<BytesRef> comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f","78cf5dd35bc9be11f14b0c5b5806b05d3f529f91"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","caa40272511a69bd4ad04b8242ae420932f5799b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"caa40272511a69bd4ad04b8242ae420932f5799b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91":["af2638813028b254a88b418ebeafb541afb49653"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d4d69c535930b5cce125cff868d40f6373dc27d4","caa40272511a69bd4ad04b8242ae420932f5799b"],"caa40272511a69bd4ad04b8242ae420932f5799b":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["af2638813028b254a88b418ebeafb541afb49653","78cf5dd35bc9be11f14b0c5b5806b05d3f529f91"],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}