{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/AliasCmd#createCollectionAndWait(ClusterState,CloudConfig,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AliasCmd#createCollectionAndWait(ClusterState,CloudConfig,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AliasCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","sourceNew":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.<p>\n   */\n  @SuppressWarnings({\"rawtypes\"})\n  static NamedList createCollectionAndWait(ClusterState clusterState, CloudConfig cloudConfig, String aliasName, Map<String, String> aliasMetadata,\n                                           String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF);\n    }\n    createReqParams.set(NAME, createCollName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, cloudConfig, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    CollectionProperties collectionProperties = new CollectionProperties(ocmh.zkStateReader.getZkClient());\n    collectionProperties.setCollectionProperty(createCollName,ROUTED_ALIAS_NAME_CORE_PROP,aliasName);\n    while (!ocmh.zkStateReader.getCollectionProperties(createCollName,1000).containsKey(ROUTED_ALIAS_NAME_CORE_PROP)) {\n      Thread.sleep(50);\n    }\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.<p>\n   */\n  @SuppressWarnings({\"rawtypes\"})\n  static NamedList createCollectionAndWait(ClusterState clusterState, String aliasName, Map<String, String> aliasMetadata,\n                                    String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF);\n    }\n    createReqParams.set(NAME, createCollName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    CollectionProperties collectionProperties = new CollectionProperties(ocmh.zkStateReader.getZkClient());\n    collectionProperties.setCollectionProperty(createCollName,ROUTED_ALIAS_NAME_CORE_PROP,aliasName);\n    while (!ocmh.zkStateReader.getCollectionProperties(createCollName,1000).containsKey(ROUTED_ALIAS_NAME_CORE_PROP)) {\n      Thread.sleep(50);\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AliasCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AliasCmd#createCollectionAndWait(ClusterState,CloudConfig,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","sourceNew":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.<p>\n   */\n  @SuppressWarnings({\"rawtypes\"})\n  static NamedList createCollectionAndWait(ClusterState clusterState, String aliasName, Map<String, String> aliasMetadata,\n                                    String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF);\n    }\n    createReqParams.set(NAME, createCollName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    CollectionProperties collectionProperties = new CollectionProperties(ocmh.zkStateReader.getZkClient());\n    collectionProperties.setCollectionProperty(createCollName,ROUTED_ALIAS_NAME_CORE_PROP,aliasName);\n    while (!ocmh.zkStateReader.getCollectionProperties(createCollName,1000).containsKey(ROUTED_ALIAS_NAME_CORE_PROP)) {\n      Thread.sleep(50);\n    }\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.<p>\n   */\n  @SuppressWarnings({\"rawtypes\"})\n  static NamedList createCollectionAndWait(ClusterState clusterState, CloudConfig cloudConfig, String aliasName, Map<String, String> aliasMetadata,\n                                           String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF);\n    }\n    createReqParams.set(NAME, createCollName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, cloudConfig, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    CollectionProperties collectionProperties = new CollectionProperties(ocmh.zkStateReader.getZkClient());\n    collectionProperties.setCollectionProperty(createCollName,ROUTED_ALIAS_NAME_CORE_PROP,aliasName);\n    while (!ocmh.zkStateReader.getCollectionProperties(createCollName,1000).containsKey(ROUTED_ALIAS_NAME_CORE_PROP)) {\n      Thread.sleep(50);\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}