{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZFloat(DataOutput,float).mjava","commits":[{"id":"078fa9e94da55eaa1aa1e7393aa84ba7cc986864","date":1418310060,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZFloat(DataOutput,float).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       4 bytes. Otherwise if the first bit is set then the other bits\n   *       in the header encode the value plus one and no other\n   *       bytes are read. Otherwise, the value is a positive float value\n   *       whose first byte is the header, and 3 bytes need to be read to\n   *       complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  static void writeZFloat(DataOutput out, float f) throws IOException {\n    int intVal = (int) f;\n    final int floatBits = Float.floatToIntBits(f);\n\n    if (f == intVal\n        && intVal >= -1\n        && intVal <= 0x7D\n        && floatBits != NEGATIVE_ZERO_FLOAT) {\n      // small integer value [-1..125]: single byte\n      out.writeByte((byte) (0x80 | (1 + intVal)));\n    } else if ((floatBits >>> 31) == 0) {\n      // other positive floats: 4 bytes\n      out.writeInt(floatBits);\n    } else {\n      // other negative float: 5 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeInt(floatBits);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83caedc5d9e910bc771bdecafbe0430361462397"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83caedc5d9e910bc771bdecafbe0430361462397","date":1440445428,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZFloat(DataOutput,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZFloat(DataOutput,float).mjava","sourceNew":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       4 bytes. Otherwise if the first bit is set then the other bits\n   *       in the header encode the value plus one and no other\n   *       bytes are read. Otherwise, the value is a positive float value\n   *       whose first byte is the header, and 3 bytes need to be read to\n   *       complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   */\n  static void writeZFloat(DataOutput out, float f) throws IOException {\n    int intVal = (int) f;\n    final int floatBits = Float.floatToIntBits(f);\n\n    if (f == intVal\n        && intVal >= -1\n        && intVal <= 0x7D\n        && floatBits != NEGATIVE_ZERO_FLOAT) {\n      // small integer value [-1..125]: single byte\n      out.writeByte((byte) (0x80 | (1 + intVal)));\n    } else if ((floatBits >>> 31) == 0) {\n      // other positive floats: 4 bytes\n      out.writeInt(floatBits);\n    } else {\n      // other negative float: 5 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeInt(floatBits);\n    }\n  }\n\n","sourceOld":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       4 bytes. Otherwise if the first bit is set then the other bits\n   *       in the header encode the value plus one and no other\n   *       bytes are read. Otherwise, the value is a positive float value\n   *       whose first byte is the header, and 3 bytes need to be read to\n   *       complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  static void writeZFloat(DataOutput out, float f) throws IOException {\n    int intVal = (int) f;\n    final int floatBits = Float.floatToIntBits(f);\n\n    if (f == intVal\n        && intVal >= -1\n        && intVal <= 0x7D\n        && floatBits != NEGATIVE_ZERO_FLOAT) {\n      // small integer value [-1..125]: single byte\n      out.writeByte((byte) (0x80 | (1 + intVal)));\n    } else if ((floatBits >>> 31) == 0) {\n      // other positive floats: 4 bytes\n      out.writeInt(floatBits);\n    } else {\n      // other negative float: 5 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeInt(floatBits);\n    }\n  }\n\n","bugFix":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83caedc5d9e910bc771bdecafbe0430361462397"],"83caedc5d9e910bc771bdecafbe0430361462397":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"]},"commit2Childs":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["83caedc5d9e910bc771bdecafbe0430361462397"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"83caedc5d9e910bc771bdecafbe0430361462397":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}