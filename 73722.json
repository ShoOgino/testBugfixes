{"path":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseSubQuery(State).mjava","commits":[{"id":"fdc91c6aee685b616507b9e44fcc69315b8a9e6c","date":1384275771,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseSubQuery(State).mjava","pathOld":"/dev/null","sourceNew":"  private void parseSubQuery(State state) {\n    while (state.index < state.length) {\n      if (state.data[state.index] == '(' && (flags & PRECEDENCE_OPERATORS) != 0) {\n        // the beginning of a subquery has been found\n        consumeSubQuery(state);\n      } else if (state.data[state.index] == ')' && (flags & PRECEDENCE_OPERATORS) != 0) {\n        // this is an extraneous character so it is ignored\n        ++state.index;\n      } else if (state.data[state.index] == '\"' && (flags & PHRASE_OPERATOR) != 0) {\n        // the beginning of a phrase has been found\n        consumePhrase(state);\n      } else if (state.data[state.index] == '+' && (flags & AND_OPERATOR) != 0) {\n        // an and operation has been explicitly set\n        // if an operation has already been set this one is ignored\n        // if a term (or phrase or subquery) has not been found yet the\n        // operation is also ignored since there is no previous\n        // term (or phrase or subquery) to and with\n        if (state.currentOperation == null && state.top != null) {\n          state.currentOperation = BooleanClause.Occur.MUST;\n        }\n\n        ++state.index;\n      } else if (state.data[state.index] == '|' && (flags & OR_OPERATOR) != 0) {\n        // an or operation has been explicitly set\n        // if an operation has already been set this one is ignored\n        // if a term (or phrase or subquery) has not been found yet the\n        // operation is also ignored since there is no previous\n        // term (or phrase or subquery) to or with\n        if (state.currentOperation == null && state.top != null) {\n          state.currentOperation = BooleanClause.Occur.SHOULD;\n        }\n\n        ++state.index;\n      } else if (state.data[state.index] == '-' && (flags & NOT_OPERATOR) != 0) {\n        // a not operator has been found, so increase the not count\n        // two not operators in a row negate each other\n        ++state.not;\n        ++state.index;\n\n        // continue so the not operator is not reset\n        // before the next character is determined\n        continue;\n      } else if ((state.data[state.index] == ' '\n          || state.data[state.index] == '\\t'\n          || state.data[state.index] == '\\n'\n          || state.data[state.index] == '\\r') && (flags & WHITESPACE_OPERATOR) != 0) {\n        // ignore any whitespace found as it may have already been\n        // used a delimiter across a term (or phrase or subquery)\n        // or is simply extraneous\n        ++state.index;\n      } else {\n        // the beginning of a token has been found\n        consumeToken(state);\n      }\n\n      // reset the not operator as even whitespace is not allowed when\n      // specifying the not operation for a term (or phrase or subquery)\n      state.not = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fdc91c6aee685b616507b9e44fcc69315b8a9e6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fdc91c6aee685b616507b9e44fcc69315b8a9e6c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fdc91c6aee685b616507b9e44fcc69315b8a9e6c"],"fdc91c6aee685b616507b9e44fcc69315b8a9e6c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}