{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","pathOld":"/dev/null","sourceNew":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    //if (DEBUG2) {\n    //  BytesRef br = new BytesRef(lastTerm.bytes());\n    //  br.length = prefixLength;\n    //  System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    //}\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n    int pendingCount = 0;\n    PrefixTerm lastPTEntry = null;\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      Object o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n      pendingCount++;\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)));\n\n      int suffixLeadLabel;\n\n      if (termBytes.length == prefixLength) {\n        // Suffix is 0, i.e. prefix 'foo' and term is\n        // 'foo' so the term has empty string suffix\n        // in this block\n        assert lastSuffixLeadLabel == -2;\n        suffixLeadLabel = -2;\n      } else {\n        suffixLeadLabel = termBytes[prefixLength] & 0xff;\n      }\n\n      // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        // NOTE: must check nextFloorLeadLabel in case minItemsInPrefix is 2 and prefix is 'a' and we've seen 'a' and then 'aa'\n        if (pendingCount >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix && nextFloorLeadLabel != -1) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n          pendingCount = 0;\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n    int sizeToClear = count;\n    if (prefixCount > 1) {\n      Object o = pending.get(pending.size()-count);\n      if (o instanceof byte[] && ((byte[]) o).length == prefixLength) {\n        // If we were just asked to write all f* terms, but there were too many and so we made floor blocks, the exact term 'f' will remain\n        // as its own item, followed by floor block terms like f[a-m]*, f[n-z]*, so in this case we leave 3 (not 2) items on the pending stack:\n        sizeToClear--;\n      }\n    }\n    pending.subList(pending.size()-sizeToClear, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","pathOld":"/dev/null","sourceNew":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    //if (DEBUG2) {\n    //  BytesRef br = new BytesRef(lastTerm.bytes());\n    //  br.length = prefixLength;\n    //  System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    //}\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n    int pendingCount = 0;\n    PrefixTerm lastPTEntry = null;\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      Object o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n      pendingCount++;\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)));\n\n      int suffixLeadLabel;\n\n      if (termBytes.length == prefixLength) {\n        // Suffix is 0, i.e. prefix 'foo' and term is\n        // 'foo' so the term has empty string suffix\n        // in this block\n        assert lastSuffixLeadLabel == -2;\n        suffixLeadLabel = -2;\n      } else {\n        suffixLeadLabel = termBytes[prefixLength] & 0xff;\n      }\n\n      // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        // NOTE: must check nextFloorLeadLabel in case minItemsInPrefix is 2 and prefix is 'a' and we've seen 'a' and then 'aa'\n        if (pendingCount >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix && nextFloorLeadLabel != -1) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n          pendingCount = 0;\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n    int sizeToClear = count;\n    if (prefixCount > 1) {\n      Object o = pending.get(pending.size()-count);\n      if (o instanceof byte[] && ((byte[]) o).length == prefixLength) {\n        // If we were just asked to write all f* terms, but there were too many and so we made floor blocks, the exact term 'f' will remain\n        // as its own item, followed by floor block terms like f[a-m]*, f[n-z]*, so in this case we leave 3 (not 2) items on the pending stack:\n        sizeToClear--;\n      }\n    }\n    pending.subList(pending.size()-sizeToClear, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86c653526aa49b33e8d542315fb4de5846893e98","date":1428878595,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","sourceNew":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    /*\n    if (DEBUG2) {\n      BytesRef br = new BytesRef(lastTerm.bytes());\n      br.length = prefixLength;\n      //System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n      System.out.println(\"  savePrefixes: \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    }\n    */\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    // Special case empty-string suffix case: we are being asked to build prefix terms for all aaa* terms, but \n    // the exact term aaa is here, and we must skip it (it is handled \"higher\", under the aa* terms):\n    Object o = pending.get(start);\n    boolean skippedEmptyStringSuffix = false;\n    if (o instanceof byte[]) {\n      if (((byte[]) o).length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string term suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    } else {\n      PrefixTerm prefix = (PrefixTerm) o;\n      if (prefix.term.bytes.length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string PT suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    }\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n\n    PrefixTerm lastPTEntry = null;\n\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)) + \" o=\" + o);\n\n      // We handled the empty-string suffix case up front:\n      assert termBytes.length > prefixLength;\n\n      int suffixLeadLabel = termBytes[prefixLength] & 0xff;\n\n      //if (DEBUG) System.out.println(\"  i=\" + i + \" o=\" + o + \" suffixLeadLabel=\" + Integer.toHexString(suffixLeadLabel) + \" pendingCount=\" + (i - nextBlockStart) + \" min=\" + minItemsInPrefix);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        int itemsInBlock = i - nextBlockStart;\n\n        if (itemsInBlock >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            //if (DEBUG) System.out.println(\"  use last\");\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n          \n          // If we skipped empty string suffix, e.g. term aaa for prefix aaa*, since we\n          // are now writing the full aaa* prefix term, we include it here:\n          if (skippedEmptyStringSuffix) {\n            count++;\n          }\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n\n    pending.subList(pending.size()-count, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","sourceOld":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    //if (DEBUG2) {\n    //  BytesRef br = new BytesRef(lastTerm.bytes());\n    //  br.length = prefixLength;\n    //  System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    //}\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n    int pendingCount = 0;\n    PrefixTerm lastPTEntry = null;\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      Object o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n      pendingCount++;\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)));\n\n      int suffixLeadLabel;\n\n      if (termBytes.length == prefixLength) {\n        // Suffix is 0, i.e. prefix 'foo' and term is\n        // 'foo' so the term has empty string suffix\n        // in this block\n        assert lastSuffixLeadLabel == -2;\n        suffixLeadLabel = -2;\n      } else {\n        suffixLeadLabel = termBytes[prefixLength] & 0xff;\n      }\n\n      // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        // NOTE: must check nextFloorLeadLabel in case minItemsInPrefix is 2 and prefix is 'a' and we've seen 'a' and then 'aa'\n        if (pendingCount >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix && nextFloorLeadLabel != -1) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n          pendingCount = 0;\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n    int sizeToClear = count;\n    if (prefixCount > 1) {\n      Object o = pending.get(pending.size()-count);\n      if (o instanceof byte[] && ((byte[]) o).length == prefixLength) {\n        // If we were just asked to write all f* terms, but there were too many and so we made floor blocks, the exact term 'f' will remain\n        // as its own item, followed by floor block terms like f[a-m]*, f[n-z]*, so in this case we leave 3 (not 2) items on the pending stack:\n        sizeToClear--;\n      }\n    }\n    pending.subList(pending.size()-sizeToClear, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","sourceNew":null,"sourceOld":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    /*\n    if (DEBUG2) {\n      BytesRef br = new BytesRef(lastTerm.bytes());\n      br.length = prefixLength;\n      //System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n      System.out.println(\"  savePrefixes: \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    }\n    */\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    // Special case empty-string suffix case: we are being asked to build prefix terms for all aaa* terms, but \n    // the exact term aaa is here, and we must skip it (it is handled \"higher\", under the aa* terms):\n    Object o = pending.get(start);\n    boolean skippedEmptyStringSuffix = false;\n    if (o instanceof byte[]) {\n      if (((byte[]) o).length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string term suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    } else {\n      PrefixTerm prefix = (PrefixTerm) o;\n      if (prefix.term.bytes.length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string PT suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    }\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n\n    PrefixTerm lastPTEntry = null;\n\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)) + \" o=\" + o);\n\n      // We handled the empty-string suffix case up front:\n      assert termBytes.length > prefixLength;\n\n      int suffixLeadLabel = termBytes[prefixLength] & 0xff;\n\n      //if (DEBUG) System.out.println(\"  i=\" + i + \" o=\" + o + \" suffixLeadLabel=\" + Integer.toHexString(suffixLeadLabel) + \" pendingCount=\" + (i - nextBlockStart) + \" min=\" + minItemsInPrefix);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        int itemsInBlock = i - nextBlockStart;\n\n        if (itemsInBlock >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            //if (DEBUG) System.out.println(\"  use last\");\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n          \n          // If we skipped empty string suffix, e.g. term aaa for prefix aaa*, since we\n          // are now writing the full aaa* prefix term, we include it here:\n          if (skippedEmptyStringSuffix) {\n            count++;\n          }\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n\n    pending.subList(pending.size()-count, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","sourceNew":null,"sourceOld":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    /*\n    if (DEBUG2) {\n      BytesRef br = new BytesRef(lastTerm.bytes());\n      br.length = prefixLength;\n      //System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n      System.out.println(\"  savePrefixes: \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    }\n    */\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    // Special case empty-string suffix case: we are being asked to build prefix terms for all aaa* terms, but \n    // the exact term aaa is here, and we must skip it (it is handled \"higher\", under the aa* terms):\n    Object o = pending.get(start);\n    boolean skippedEmptyStringSuffix = false;\n    if (o instanceof byte[]) {\n      if (((byte[]) o).length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string term suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    } else {\n      PrefixTerm prefix = (PrefixTerm) o;\n      if (prefix.term.bytes.length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string PT suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    }\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n\n    PrefixTerm lastPTEntry = null;\n\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)) + \" o=\" + o);\n\n      // We handled the empty-string suffix case up front:\n      assert termBytes.length > prefixLength;\n\n      int suffixLeadLabel = termBytes[prefixLength] & 0xff;\n\n      //if (DEBUG) System.out.println(\"  i=\" + i + \" o=\" + o + \" suffixLeadLabel=\" + Integer.toHexString(suffixLeadLabel) + \" pendingCount=\" + (i - nextBlockStart) + \" min=\" + minItemsInPrefix);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        int itemsInBlock = i - nextBlockStart;\n\n        if (itemsInBlock >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            //if (DEBUG) System.out.println(\"  use last\");\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n          \n          // If we skipped empty string suffix, e.g. term aaa for prefix aaa*, since we\n          // are now writing the full aaa* prefix term, we include it here:\n          if (skippedEmptyStringSuffix) {\n            count++;\n          }\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n\n    pending.subList(pending.size()-count, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/AutoPrefixTermsWriter#savePrefixes(int,int).mjava","sourceNew":null,"sourceOld":"  void savePrefixes(int prefixLength, int count) throws IOException {\n\n    assert count > 0;\n\n    /*\n    if (DEBUG2) {\n      BytesRef br = new BytesRef(lastTerm.bytes());\n      br.length = prefixLength;\n      //System.out.println(\"  savePrefixes: seg=\" + segment + \" \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n      System.out.println(\"  savePrefixes: \" + brToString(br) + \" count=\" + count + \" pending.size()=\" + pending.size());\n    }\n    */\n\n    int lastSuffixLeadLabel = -2;\n\n    int start = pending.size()-count;\n    assert start >=0;\n\n    // Special case empty-string suffix case: we are being asked to build prefix terms for all aaa* terms, but \n    // the exact term aaa is here, and we must skip it (it is handled \"higher\", under the aa* terms):\n    Object o = pending.get(start);\n    boolean skippedEmptyStringSuffix = false;\n    if (o instanceof byte[]) {\n      if (((byte[]) o).length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string term suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    } else {\n      PrefixTerm prefix = (PrefixTerm) o;\n      if (prefix.term.bytes.length == prefixLength) {\n        start++;\n        count--;\n        //if (DEBUG) System.out.println(\"  skip empty-string PT suffix\");\n        skippedEmptyStringSuffix = true;\n      }\n    }\n\n    int end = pending.size();\n    int nextBlockStart = start;\n    int nextFloorLeadLabel = -1;\n    int prefixCount = 0;\n\n    PrefixTerm lastPTEntry = null;\n\n    for (int i=start; i<end; i++) {\n\n      byte[] termBytes;\n      o = pending.get(i);\n      PrefixTerm ptEntry;\n      if (o instanceof byte[]) {\n        ptEntry = null;\n        termBytes = (byte[]) o;\n      } else {\n        ptEntry = (PrefixTerm) o;\n        termBytes = ptEntry.term.bytes;\n        if (ptEntry.prefix.length != prefixLength) {\n          assert ptEntry.prefix.length > prefixLength;\n          ptEntry = null;\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    check term=\" + brToString(new BytesRef(termBytes)) + \" o=\" + o);\n\n      // We handled the empty-string suffix case up front:\n      assert termBytes.length > prefixLength;\n\n      int suffixLeadLabel = termBytes[prefixLength] & 0xff;\n\n      //if (DEBUG) System.out.println(\"  i=\" + i + \" o=\" + o + \" suffixLeadLabel=\" + Integer.toHexString(suffixLeadLabel) + \" pendingCount=\" + (i - nextBlockStart) + \" min=\" + minItemsInPrefix);\n\n      if (suffixLeadLabel != lastSuffixLeadLabel) {\n        // This is a boundary, a chance to make an auto-prefix term if we want:\n\n        // When we are \"recursing\" (generating auto-prefix terms on a block of\n        // floor'd auto-prefix terms), this assert is non-trivial because it\n        // ensures the floorLeadEnd of the previous terms is in fact less\n        // than the lead start of the current entry:\n        assert suffixLeadLabel > lastSuffixLeadLabel: \"suffixLeadLabel=\" + suffixLeadLabel + \" vs lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n\n        int itemsInBlock = i - nextBlockStart;\n\n        if (itemsInBlock >= minItemsInPrefix && end-nextBlockStart > maxItemsInPrefix) {\n          // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n          // the leading label of the suffix of the first term in each floor block, so at search time we can\n          // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n          // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n          // a too-small block as the final block:\n\n          // If the last entry was another prefix term of the same length, then it represents a range of terms, so we must use its ending\n          // prefix label as our ending label:\n          if (lastPTEntry != null) {\n            //if (DEBUG) System.out.println(\"  use last\");\n            lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n          }\n          savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n\n          prefixCount++;\n          nextFloorLeadLabel = suffixLeadLabel;\n          nextBlockStart = i;\n        }\n\n        if (nextFloorLeadLabel == -1) {\n          nextFloorLeadLabel = suffixLeadLabel;\n          //if (DEBUG) System.out.println(\"set first lead label=\" + nextFloorLeadLabel);\n        }\n\n        lastSuffixLeadLabel = suffixLeadLabel;\n      }\n\n      lastPTEntry = ptEntry;\n    }\n\n    // Write last block, if any:\n    if (nextBlockStart < end) {\n      //System.out.println(\"  lastPTEntry=\" + lastPTEntry + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel);\n      if (lastPTEntry != null) {\n        lastSuffixLeadLabel = lastPTEntry.floorLeadEnd;\n      }\n      assert lastSuffixLeadLabel >= nextFloorLeadLabel: \"lastSuffixLeadLabel=\" + lastSuffixLeadLabel + \" nextFloorLeadLabel=\" + nextFloorLeadLabel;\n      if (prefixCount == 0) {\n        if (prefixLength > 0) {\n          savePrefix(prefixLength, -2, 0xff);\n          prefixCount++;\n          \n          // If we skipped empty string suffix, e.g. term aaa for prefix aaa*, since we\n          // are now writing the full aaa* prefix term, we include it here:\n          if (skippedEmptyStringSuffix) {\n            count++;\n          }\n        } else {\n          // Don't add a prefix term for all terms in the index!\n        }\n      } else {\n        if (lastSuffixLeadLabel == -2) {\n          // Special case when closing the empty string root block:\n          lastSuffixLeadLabel = 0xff;\n        }\n        savePrefix(prefixLength, nextFloorLeadLabel, lastSuffixLeadLabel);\n        prefixCount++;\n      }\n    }\n\n    // Remove slice from the top of the pending stack, that we just wrote:\n\n    pending.subList(pending.size()-count, pending.size()).clear();\n\n    // Append prefix terms for each prefix, since these count like real terms that also need to be \"rolled up\":\n    for(int i=0;i<prefixCount;i++) {\n      PrefixTerm pt = prefixes.get(prefixes.size()-(prefixCount-i));\n      pending.add(pt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"86c653526aa49b33e8d542315fb4de5846893e98":["3e8715d826e588419327562287d5d6a8040d63d6"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["86c653526aa49b33e8d542315fb4de5846893e98","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["86c653526aa49b33e8d542315fb4de5846893e98"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["86c653526aa49b33e8d542315fb4de5846893e98","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"]},"commit2Childs":{"86c653526aa49b33e8d542315fb4de5846893e98":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["86c653526aa49b33e8d542315fb4de5846893e98","d2638f781be724518ff6c2263d14a48cf6e68017"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}