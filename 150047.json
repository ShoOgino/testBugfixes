{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","commits":[{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9a56a9413181d8bfb3992127b4ed8a1814a97209"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a56a9413181d8bfb3992127b4ed8a1814a97209","date":1361897644,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<String,Class<? extends S>>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<String,Class<? extends S>>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c876aba909b05165f3d290e26b5a4121214f553","date":1449340310,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1b329156f9702cbfcdd80795c864111bcd341b","date":1561167997,"type":3,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        // Lookup \"NAME\" field with appropriate modifiers.\n        // Also it must be a String class and declared in the service class.\n        final Field field = service.getField(\"NAME\");\n        int modifier = field.getModifiers();\n        if (Modifier.isStatic(modifier) && Modifier.isFinal(modifier) &&\n            field.getType().equals(String.class) &&\n            Objects.equals(field.getDeclaringClass(), service)) {\n          originalName = ((String)field.get(null));\n          name = originalName.toLowerCase(Locale.ROOT);\n          if (!isValidName(originalName)) {\n            throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n                \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n          }\n        }\n      } catch (NoSuchFieldException | IllegalAccessException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    }\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services =\n      new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bc9864ea60454f962db6e9f89d513bc9a6fffee","date":1561864788,"type":3,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = AbstractAnalysisFactory.lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    }\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        // Lookup \"NAME\" field with appropriate modifiers.\n        // Also it must be a String class and declared in the service class.\n        final Field field = service.getField(\"NAME\");\n        int modifier = field.getModifiers();\n        if (Modifier.isStatic(modifier) && Modifier.isFinal(modifier) &&\n            field.getType().equals(String.class) &&\n            Objects.equals(field.getDeclaringClass(), service)) {\n          originalName = ((String)field.get(null));\n          name = originalName.toLowerCase(Locale.ROOT);\n          if (!isValidName(originalName)) {\n            throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n                \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n          }\n        }\n      } catch (NoSuchFieldException | IllegalAccessException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    }\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32694fa3bbb984d3054955e48d946708e16110ff","date":1585155816,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    ServiceLoader.load(clazz, classloader).stream().map(ServiceLoader.Provider::type).forEachOrdered(service -> {\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    });\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = AbstractAnalysisFactory.lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    }\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313c36388b6cae6118f75a1860ad0ba0af7e1344","date":1601279368,"type":5,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    ServiceLoader.load(clazz, classloader).stream().map(ServiceLoader.Provider::type).forEachOrdered(service -> {\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    });\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    ServiceLoader.load(clazz, classloader).stream().map(ServiceLoader.Provider::type).forEachOrdered(service -> {\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    });\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9a56a9413181d8bfb3992127b4ed8a1814a97209"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"32694fa3bbb984d3054955e48d946708e16110ff":["5bc9864ea60454f962db6e9f89d513bc9a6fffee"],"5bc9864ea60454f962db6e9f89d513bc9a6fffee":["7b1b329156f9702cbfcdd80795c864111bcd341b"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"313c36388b6cae6118f75a1860ad0ba0af7e1344":["32694fa3bbb984d3054955e48d946708e16110ff"],"9a56a9413181d8bfb3992127b4ed8a1814a97209":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"1c876aba909b05165f3d290e26b5a4121214f553":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7b1b329156f9702cbfcdd80795c864111bcd341b":["1c876aba909b05165f3d290e26b5a4121214f553"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["313c36388b6cae6118f75a1860ad0ba0af7e1344"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1c876aba909b05165f3d290e26b5a4121214f553"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"32694fa3bbb984d3054955e48d946708e16110ff":["313c36388b6cae6118f75a1860ad0ba0af7e1344"],"5bc9864ea60454f962db6e9f89d513bc9a6fffee":["32694fa3bbb984d3054955e48d946708e16110ff"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["aba371508186796cc6151d8223a5b4e16d02e26e","9a56a9413181d8bfb3992127b4ed8a1814a97209","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"9a56a9413181d8bfb3992127b4ed8a1814a97209":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","9499b09dd7d06d975f31e59a9b00653a86f9cad2","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"313c36388b6cae6118f75a1860ad0ba0af7e1344":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"1c876aba909b05165f3d290e26b5a4121214f553":["7b1b329156f9702cbfcdd80795c864111bcd341b"],"7b1b329156f9702cbfcdd80795c864111bcd341b":["5bc9864ea60454f962db6e9f89d513bc9a6fffee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}