{"path":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","commits":[{"id":"3f678348ac6e145f874f56992e8c0f78a1ff3c46","date":1385743501,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query.build(), reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery query = new BooleanQuery();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query, reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","pathOld":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMultiValuedSortByScore().mjava","sourceNew":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer);\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query.build(), reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiValuedSortByScore() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter( dir, newIndexWriterConfig(new MockAnalyzer( random() ) ) );\n    Document doc = new Document();\n    FieldType type = new FieldType( TextField.TYPE_STORED );\n    type.setStoreTermVectorOffsets( true );\n    type.setStoreTermVectorPositions( true );\n    type.setStoreTermVectors( true );\n    type.freeze();\n    doc.add( new Field( \"field\", \"zero if naught\", type ) ); // The first two fields contain the best match\n    doc.add( new Field( \"field\", \"hero of legend\", type ) ); // but total a lower score (3) than the bottom\n    doc.add( new Field( \"field\", \"naught of hero\", type ) ); // two fields (4)\n    doc.add( new Field( \"field\", \"naught of hero\", type ) );\n    writer.addDocument(doc);\n\n    FastVectorHighlighter highlighter = new FastVectorHighlighter();\n    \n    ScoreOrderFragmentsBuilder fragmentsBuilder = new ScoreOrderFragmentsBuilder();    \n    fragmentsBuilder.setDiscreteMultiValueHighlighting( true );\n    IndexReader reader = DirectoryReader.open(writer, true );\n    String[] preTags = new String[] { \"<b>\" };\n    String[] postTags = new String[] { \"</b>\" };\n    Encoder encoder = new DefaultEncoder();\n    int docId = 0;\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    query.add( clause( \"field\", \"hero\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"of\" ), Occur.SHOULD);\n    query.add( clause( \"field\", \"legend\" ), Occur.SHOULD);\n    FieldQuery fieldQuery = highlighter.getFieldQuery( query.build(), reader );\n\n    for ( FragListBuilder fragListBuilder : new FragListBuilder[] {\n      new SimpleFragListBuilder(), new WeightedFragListBuilder() } ) {\n      String[] bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 20, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 28, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n      bestFragments = highlighter.getBestFragments( fieldQuery, reader, docId, \"field\", 30000, 1,\n          fragListBuilder, fragmentsBuilder, preTags, postTags, encoder );\n      assertEquals(\"<b>hero</b> <b>of</b> <b>legend</b>\", bestFragments[0]);\n    }\n\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"3f678348ac6e145f874f56992e8c0f78a1ff3c46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2a1862266772deb28cdcb7d996b64d2177022687":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f678348ac6e145f874f56992e8c0f78a1ff3c46"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["3f678348ac6e145f874f56992e8c0f78a1ff3c46"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2a1862266772deb28cdcb7d996b64d2177022687"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["2a1862266772deb28cdcb7d996b64d2177022687"],"3f678348ac6e145f874f56992e8c0f78a1ff3c46":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"2a1862266772deb28cdcb7d996b64d2177022687":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f678348ac6e145f874f56992e8c0f78a1ff3c46","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}