{"path":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","commits":[{"id":"ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f","date":1178835005,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n    }\n    \n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next();\n      assertEquals( t.termText(), got.termText());\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["960e0dae888f682751b2c173774ae77a8da7e68d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe8ae1ed027200f075b0de9f264776fa32c4862f","date":1207066219,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","pathOld":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","sourceNew":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n    }\n    \n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next(t);\n      assertEquals( new String(t.termBuffer(), 0, t.termLength()), new String(got.termBuffer(), 0, got.termLength()));\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","sourceOld":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n    }\n    \n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next();\n      assertEquals( t.termText(), got.termText());\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"960e0dae888f682751b2c173774ae77a8da7e68d","date":1250187502,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","pathOld":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","sourceNew":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n\n      // phonetic token is added first in the current impl\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n\n      // add the original if applicable\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n    }\n\n    // System.out.println(\"###stream=\"+stream);\n    // System.out.println(\"###output=\"+output);\n\n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next(t);\n      // System.out.println(\"##### got=\"+got);\n\n      assertEquals( new String(t.termBuffer(), 0, t.termLength()), new String(got.termBuffer(), 0, got.termLength()));\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","sourceOld":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n    }\n    \n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next(t);\n      assertEquals( new String(t.termBuffer(), 0, t.termLength()), new String(got.termBuffer(), 0, got.termLength()));\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","bugFix":["ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cc00a3aaafb48a2fa2efdb2b20ad43f081f4fad","date":1250265144,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","pathOld":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","sourceNew":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n\n      // phonetic token is added first in the current impl\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n\n      // add the original if applicable\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n    }\n\n    // System.out.println(\"###stream=\"+stream);\n    // System.out.println(\"###output=\"+output);\n\n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n\n    Token got = new Token();\n    for( Token t : output ) {\n      got = filter.next(got);\n      // System.out.println(\"##### expect=\" + t + \" got=\"+got);\n      assertEquals( t.term(), got.term());\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","sourceOld":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n\n      // phonetic token is added first in the current impl\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n\n      // add the original if applicable\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n    }\n\n    // System.out.println(\"###stream=\"+stream);\n    // System.out.println(\"###output=\"+output);\n\n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n    \n    for( Token t : output ) {\n      Token got = filter.next(t);\n      // System.out.println(\"##### got=\"+got);\n\n      assertEquals( new String(t.termBuffer(), 0, t.termLength()), new String(got.termBuffer(), 0, got.termLength()));\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fd023a662cc25ae7e0ad0f33d71c476a16d0579","date":1261403630,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/solr/analysis/TestPhoneticFilter#runner(Encoder,boolean).mjava","sourceNew":null,"sourceOld":"  public void runner( Encoder enc, boolean inject ) throws Exception\n  {\n    String[] input = new String[] {\n       \"aaa\", \"bbb\", \"ccc\", \"easgasg\"\n    };\n\n    ArrayList<Token> stream = new ArrayList<Token>();\n    ArrayList<Token> output = new ArrayList<Token>();\n    for( String s : input ) {\n      stream.add( new Token( s, 0, s.length() ) );\n\n      // phonetic token is added first in the current impl\n      output.add( new Token( enc.encode(s).toString(), 0, s.length() ) );\n\n      // add the original if applicable\n      if( inject ) {\n        output.add( new Token( s, 0, s.length() ) );\n      }\n    }\n\n    // System.out.println(\"###stream=\"+stream);\n    // System.out.println(\"###output=\"+output);\n\n    PhoneticFilter filter = new PhoneticFilter( \n        new IterTokenStream(stream.iterator()), enc, \"text\", inject );\n\n    Token got = new Token();\n    for( Token t : output ) {\n      got = filter.next(got);\n      // System.out.println(\"##### expect=\" + t + \" got=\"+got);\n      assertEquals( t.term(), got.term());\n    }\n    assertNull( filter.next() );  // no more tokens\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":["ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f"],"ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"960e0dae888f682751b2c173774ae77a8da7e68d":["fe8ae1ed027200f075b0de9f264776fa32c4862f"],"5cc00a3aaafb48a2fa2efdb2b20ad43f081f4fad":["960e0dae888f682751b2c173774ae77a8da7e68d"],"2fd023a662cc25ae7e0ad0f33d71c476a16d0579":["5cc00a3aaafb48a2fa2efdb2b20ad43f081f4fad"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":["960e0dae888f682751b2c173774ae77a8da7e68d"],"ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f":["fe8ae1ed027200f075b0de9f264776fa32c4862f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ccea5bb6cc45a411fd349ce24ab5a37b343f1d7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"960e0dae888f682751b2c173774ae77a8da7e68d":["5cc00a3aaafb48a2fa2efdb2b20ad43f081f4fad"],"5cc00a3aaafb48a2fa2efdb2b20ad43f081f4fad":["2fd023a662cc25ae7e0ad0f33d71c476a16d0579"],"2fd023a662cc25ae7e0ad0f33d71c476a16d0579":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2fd023a662cc25ae7e0ad0f33d71c476a16d0579","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}