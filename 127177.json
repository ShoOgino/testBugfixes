{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes#getWriter(Directory,String,Mode,boolean,Comparator[BytesRef],Counter,IOContext,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes#getWriter(Directory,String,Mode,boolean,Comparator[BytesRef],Counter,IOContext,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene40/values/Bytes#getWriter(Directory,String,Mode,boolean,Comparator[BytesRef],Counter,IOContext,boolean).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param sortComparator {@link BytesRef} comparator used by sorted variants. \n   *        If <code>null</code> {@link BytesRef#getUTF8SortedAsUnicodeComparator()}\n   *        is used instead\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memory tracking\n   *          reference.\n   * @param fasterButMoreRam whether packed ints for docvalues should be optimized for speed by rounding up the bytes\n   *                         used for a value to either 8, 16, 32 or 64 bytes. This option is only applicable for\n   *                         docvalues of type {@link Type#BYTES_FIXED_SORTED} and {@link Type#BYTES_VAR_SORTED}.\n   * @param context I/O Context\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static DocValuesConsumer getWriter(Directory dir, String id, Mode mode,\n      boolean fixedSize, Comparator<BytesRef> sortComparator,\n      Counter bytesUsed, IOContext context, boolean fasterButMoreRam)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (sortComparator == null) {\n      sortComparator = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param sortComparator {@link BytesRef} comparator used by sorted variants. \n   *        If <code>null</code> {@link BytesRef#getUTF8SortedAsUnicodeComparator()}\n   *        is used instead\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memory tracking\n   *          reference.\n   * @param fasterButMoreRam whether packed ints for docvalues should be optimized for speed by rounding up the bytes\n   *                         used for a value to either 8, 16, 32 or 64 bytes. This option is only applicable for\n   *                         docvalues of type {@link Type#BYTES_FIXED_SORTED} and {@link Type#BYTES_VAR_SORTED}.\n   * @param context I/O Context\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static DocValuesConsumer getWriter(Directory dir, String id, Mode mode,\n      boolean fixedSize, Comparator<BytesRef> sortComparator,\n      Counter bytesUsed, IOContext context, boolean fasterButMoreRam)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (sortComparator == null) {\n      sortComparator = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a470c93b2b0f8f51241f52705fc110a01f27ad2","date":1337969379,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes#getWriter(Directory,String,Mode,boolean,Comparator[BytesRef],Counter,IOContext,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes#getWriter(Directory,String,Mode,boolean,Comparator[BytesRef],Counter,IOContext,boolean).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param sortComparator {@link BytesRef} comparator used by sorted variants. \n   *        If <code>null</code> {@link BytesRef#getUTF8SortedAsUnicodeComparator()}\n   *        is used instead\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memory tracking\n   *          reference.\n   * @param acceptableOverheadRatio\n   *          how to trade space for speed. This option is only applicable for\n   *          docvalues of type {@link Type#BYTES_FIXED_SORTED} and\n   *          {@link Type#BYTES_VAR_SORTED}.\n   * @param context I/O Context\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   * @see PackedInts#getReader(org.apache.lucene.store.DataInput)\n   */\n  public static DocValuesConsumer getWriter(Directory dir, String id, Mode mode,\n      boolean fixedSize, Comparator<BytesRef> sortComparator,\n      Counter bytesUsed, IOContext context, float acceptableOverheadRatio)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (sortComparator == null) {\n      sortComparator = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, acceptableOverheadRatio);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, acceptableOverheadRatio);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param sortComparator {@link BytesRef} comparator used by sorted variants. \n   *        If <code>null</code> {@link BytesRef#getUTF8SortedAsUnicodeComparator()}\n   *        is used instead\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memory tracking\n   *          reference.\n   * @param fasterButMoreRam whether packed ints for docvalues should be optimized for speed by rounding up the bytes\n   *                         used for a value to either 8, 16, 32 or 64 bytes. This option is only applicable for\n   *                         docvalues of type {@link Type#BYTES_FIXED_SORTED} and {@link Type#BYTES_VAR_SORTED}.\n   * @param context I/O Context\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static DocValuesConsumer getWriter(Directory dir, String id, Mode mode,\n      boolean fixedSize, Comparator<BytesRef> sortComparator,\n      Counter bytesUsed, IOContext context, boolean fasterButMoreRam)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (sortComparator == null) {\n      sortComparator = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, sortComparator, bytesUsed, context, fasterButMoreRam);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}