{"path":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","commits":[{"id":"637a392e2e05d4e1179ac3c532cfeef0cde977ba","date":1376347977,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"/dev/null","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        assertU(add(doc(idDoc)));\n        i++;\n      }\n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e824c614ba8ba12c19a3945f1d1c838b97a870cf","e33fd65b6439b984c75cc2e07551111fe904bacb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"/dev/null","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        assertU(add(doc(idDoc)));\n        i++;\n      }\n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e33fd65b6439b984c75cc2e07551111fe904bacb","date":1376933118,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","sourceOld":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        assertU(add(doc(idDoc)));\n        i++;\n      }\n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","bugFix":["637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","sourceOld":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        assertU(add(doc(idDoc)));\n        i++;\n      }\n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","sourceOld":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        assertU(add(doc(idDoc)));\n        i++;\n      }\n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e824c614ba8ba12c19a3945f1d1c838b97a870cf","date":1524763064,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n  }\n\n","sourceOld":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","bugFix":["637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3a3934808ca385ff0f01756464ed6f7a5ab4025","date":1524832780,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#createIndex().mjava","sourceNew":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n  }\n\n","sourceOld":"  public static void createIndex() throws IOException, Exception {\n    int i = 0;\n    List<List<String[]>> blocks = createBlocks();\n    for (List<String[]> block : blocks) {\n      List<XmlDoc> updBlock = new ArrayList<>();\n      \n      for (String[] doc : block) {\n        String[] idDoc = Arrays.copyOf(doc,doc.length+2);\n        idDoc[doc.length]=\"id\";\n        idDoc[doc.length+1]=Integer.toString(i);\n        updBlock.add(doc(idDoc));\n        i++;\n      }\n      //got xmls for every doc. now nest all into the last one\n      XmlDoc parentDoc = updBlock.get(updBlock.size()-1);\n      parentDoc.xml = parentDoc.xml.replace(\"</doc>\", \n          updBlock.subList(0, updBlock.size()-1).toString().replaceAll(\"[\\\\[\\\\]]\",\"\")+\"</doc>\");\n      assertU(add(parentDoc));\n      \n      if (random().nextBoolean()) {\n        assertU(commit());\n        // force empty segment (actually, this will no longer create an empty segment, only a new segments_n)\n        if (random().nextBoolean()) {\n          assertU(commit());\n        }\n      }\n    }\n    assertU(commit());\n    assertQ(req(\"q\", \"*:*\"), \"//*[@numFound='\" + i + \"']\");\n    /*\n     * dump docs well System.out.println(h.query(req(\"q\",\"*:*\",\n     * \"sort\",\"_docid_ asc\", \"fl\",\n     * \"parent_s,child_s,parentchild_s,grand_s,grand_child_s,grand_parentchild_s\"\n     * , \"wt\",\"csv\", \"rows\",\"1000\"))); /\n     */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","e33fd65b6439b984c75cc2e07551111fe904bacb"],"31d4861802ca404d78ca1d15f4550eec415b9199":["637a392e2e05d4e1179ac3c532cfeef0cde977ba","e33fd65b6439b984c75cc2e07551111fe904bacb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d3a3934808ca385ff0f01756464ed6f7a5ab4025":["e33fd65b6439b984c75cc2e07551111fe904bacb","e824c614ba8ba12c19a3945f1d1c838b97a870cf"],"e824c614ba8ba12c19a3945f1d1c838b97a870cf":["e33fd65b6439b984c75cc2e07551111fe904bacb"],"e33fd65b6439b984c75cc2e07551111fe904bacb":["637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d3a3934808ca385ff0f01756464ed6f7a5ab4025"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","31d4861802ca404d78ca1d15f4550eec415b9199","e33fd65b6439b984c75cc2e07551111fe904bacb"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"d3a3934808ca385ff0f01756464ed6f7a5ab4025":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e824c614ba8ba12c19a3945f1d1c838b97a870cf":["d3a3934808ca385ff0f01756464ed6f7a5ab4025"],"e33fd65b6439b984c75cc2e07551111fe904bacb":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","d3a3934808ca385ff0f01756464ed6f7a5ab4025","e824c614ba8ba12c19a3945f1d1c838b97a870cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}