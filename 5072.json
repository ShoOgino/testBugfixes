{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","commits":[{"id":"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","date":1522388336,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n          \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n          \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n          \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n          \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n          \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n          \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","date":1533256859,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14076e7b40405aa1f08702d8df762d08b5d44f70","date":1537071979,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    waitForState(\"\", collectionName, clusterShape(1, 3));\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(10);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire within 20 seconds\", triggerFiredLatch.await(20, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (@SuppressWarnings({\"rawtypes\"})SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (@SuppressWarnings({\"rawtypes\"})SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .setMaxShardsPerNode(5).process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (@SuppressWarnings({\"rawtypes\"})SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledTriggerIntegrationTest#testScheduledTrigger().mjava","sourceNew":null,"sourceOld":"  @Test\n  // commented 15-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testScheduledTrigger() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    // this collection will place 2 cores on 1st node and 1 core on 2nd node\n    String collectionName = \"testScheduledTrigger\";\n    CollectionAdminRequest.createCollection(collectionName, 1, 3)\n        .process(solrClient);\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    // create a policy which allows only 1 core per node thereby creating a violation for the above collection\n    String setClusterPolicy = \"{\\n\" +\n        \"  \\\"set-cluster-policy\\\" : [\\n\" +\n        \"    {\\\"cores\\\" : \\\"<2\\\", \\\"node\\\" : \\\"#EACH\\\"}\\n\" +\n        \"  ]\\n\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicy);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start a new node which can be used to balance the cluster as per policy\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'sched_trigger_integration1',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : '\" + new Date().toInstant().toString() + \"'\" +\n        \"'every' : '+3SECONDS'\" +\n        \"'actions' : [\" +\n        \"{'name' : 'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'recorder', 'class': '\" + ContextPropertiesRecorderAction.class.getName() + \"'}\" +\n        \"]}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    assertTrue(\"ScheduledTrigger did not fire in time\", triggerFiredLatch.await(45, TimeUnit.SECONDS));\n    assertEquals(1, events.size());\n    Map<String, Object> actionContextProps = actionContextPropertiesRef.get();\n    assertNotNull(actionContextProps);\n    TriggerEvent event = events.iterator().next();\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    List<SolrRequest> operations = (List<SolrRequest>) actionContextProps.get(\"operations\");\n    assertNotNull(operations);\n    assertEquals(1, operations.size());\n    for (@SuppressWarnings({\"rawtypes\"})SolrRequest operation : operations) {\n      SolrParams params = operation.getParams();\n      assertEquals(newNode.getNodeName(), params.get(\"targetNode\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["89948af0461fead48f44ba8fb7866f107ce83f22"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4"],"89948af0461fead48f44ba8fb7866f107ce83f22":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89948af0461fead48f44ba8fb7866f107ce83f22"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"89948af0461fead48f44ba8fb7866f107ce83f22":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}