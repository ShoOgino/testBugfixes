{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","commits":[{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0088660bdc1c051f58fbc38626d61ccf22dfd3e0","date":1427444574,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["7e4c214a1f904dde76f5611b56d4081533055b3b","0088660bdc1c051f58fbc38626d61ccf22dfd3e0"],"0088660bdc1c051f58fbc38626d61ccf22dfd3e0":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7e4c214a1f904dde76f5611b56d4081533055b3b":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0088660bdc1c051f58fbc38626d61ccf22dfd3e0"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0088660bdc1c051f58fbc38626d61ccf22dfd3e0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0088660bdc1c051f58fbc38626d61ccf22dfd3e0"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}