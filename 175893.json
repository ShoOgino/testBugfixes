{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","commits":[{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6cc2915889370c9313ee1741da315e976bdd574","date":1422111819,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere.\n   *\n   *  If this method wants to stall but the calling thread is a merge\n   *  thread, it should return false to tell caller not to kick off\n   *  any new merges. */\n\n  protected synchronized boolean maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n\n      if (mergeThreads.contains(Thread.currentThread())) {\n        // Never stall a merge thread since this blocks the thread from\n        // finishing and calling updateMergeThreads, and blocking it\n        // accomplishes nothing anyway (it's not really a segment producer):\n        return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f","a1346c5dacb766a49ec3b6160a23d2e80073501c","7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(MergeSource).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere.\n   *\n   *  If this method wants to stall but the calling thread is a merge\n   *  thread, it should return false to tell caller not to kick off\n   *  any new merges. */\n  protected synchronized boolean maybeStall(MergeSource mergeSource) {\n    long startStallTime = 0;\n    while (mergeSource.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n\n      if (mergeThreads.contains(Thread.currentThread())) {\n        // Never stall a merge thread since this blocks the thread from\n        // finishing and calling updateMergeThreads, and blocking it\n        // accomplishes nothing anyway (it's not really a segment producer):\n        return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere.\n   *\n   *  If this method wants to stall but the calling thread is a merge\n   *  thread, it should return false to tell caller not to kick off\n   *  any new merges. */\n\n  protected synchronized boolean maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n\n      if (mergeThreads.contains(Thread.currentThread())) {\n        // Never stall a merge thread since this blocks the thread from\n        // finishing and calling updateMergeThreads, and blocking it\n        // accomplishes nothing anyway (it's not really a segment producer):\n        return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89697e7abc9807639c384eecf5a2a6eef1080426":["c6cc2915889370c9313ee1741da315e976bdd574"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c6cc2915889370c9313ee1741da315e976bdd574":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89697e7abc9807639c384eecf5a2a6eef1080426"]},"commit2Childs":{"89697e7abc9807639c384eecf5a2a6eef1080426":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c6cc2915889370c9313ee1741da315e976bdd574":["89697e7abc9807639c384eecf5a2a6eef1080426"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["c6cc2915889370c9313ee1741da315e976bdd574"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}