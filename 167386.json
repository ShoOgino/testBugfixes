{"path":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","commits":[{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"/dev/null","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    CollectionAdminResponse response = CollectionAdminRequest.createCollection(collection1, 2,\n        2, 2, null, \"conf1\", \"myOwnField\", true, cloudClient);\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    CollectionAdminResponse response2 = CollectionAdminRequest.createCollection(collection2, 2,\n        2, 2, null, \"conf1\", \"myOwnField\", false, cloudClient);\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n    \n    Thread.sleep(3000);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    \n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a7d7ef06ef6f04ba2de657e90e0458048a967c6","date":1409691631,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrServer());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n    \n    Thread.sleep(3000);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    \n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    CollectionAdminResponse response = CollectionAdminRequest.createCollection(collection1, 2,\n        2, 2, null, \"conf1\", \"myOwnField\", true, cloudClient);\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    CollectionAdminResponse response2 = CollectionAdminRequest.createCollection(collection2, 2,\n        2, 2, null, \"conf1\", \"myOwnField\", false, cloudClient);\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n    \n    Thread.sleep(3000);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    \n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03d03e4c5b46c71c9359363a4310b0a9eab4fa65","date":1419436545,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrServer());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(3000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = getLiveAndActiveCount(collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > getLiveAndActiveCount(collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrServer());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n    \n    Thread.sleep(3000);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    \n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(3000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = getLiveAndActiveCount(collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > getLiveAndActiveCount(collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrServer());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(3000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = getLiveAndActiveCount(collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > getLiveAndActiveCount(collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3747a28ce6c262c1e27f7c7b30a827bc1a17260b","date":1428529761,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection3);\n    createCollectionRequest.setNumShards(5);\n    createCollectionRequest.setReplicationFactor(1);\n    createCollectionRequest.setMaxShardsPerNode(1);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(3000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, getLiveAndActiveCount(collection1));\n    assertTrue(getLiveAndActiveCount(collection2) < 4);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = getLiveAndActiveCount(collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > getLiveAndActiveCount(collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLive(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452","03d03e4c5b46c71c9359363a4310b0a9eab4fa65"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"182acd29cf4cb1644a02b8517f3a5b867c0d7cce","date":1432665213,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection1);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection2);\n    createCollectionRequest.setNumShards(2);\n    createCollectionRequest.setReplicationFactor(2);\n    createCollectionRequest.setMaxShardsPerNode(2);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(collection3);\n    createCollectionRequest.setNumShards(5);\n    createCollectionRequest.setReplicationFactor(1);\n    createCollectionRequest.setMaxShardsPerNode(1);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setRouterField(\"myOwnField\");\n    createCollectionRequest.setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"162e1895a880a7263b46e184f1478f0366eb095c","date":1467859866,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e748d9ee3a1515b2ea3903d067f1f39fffdd083f","date":1467898648,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n    \n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n    \n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr-no-core.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ce316a4153e16f795de04b24fcb57d4c2c4a993","date":1486440190,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"579fab47a447cb68f742b3ea201e3398f84daaef","date":1489485666,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d","date":1489651910,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = new Create()\n            .setCollectionName(collection1)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection2)\n            .setNumShards(2)\n            .setReplicationFactor(2)\n            .setMaxShardsPerNode(2)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = new Create()\n            .setCollectionName(collection3)\n            .setNumShards(5)\n            .setReplicationFactor(1)\n            .setMaxShardsPerNode(1)\n            .setConfigName(\"conf1\")\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = new Create()\n        .setCollectionName(collection4)\n        .setNumShards(5)\n        .setReplicationFactor(1)\n        .setMaxShardsPerNode(5)\n        .setConfigName(\"conf1\")\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    //TODO nocommit, we must test overseer failover\n    List<JettySolrRunner> stoppedJetties = notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67fd9434ab905954753628cfb5dd0270fed1d817","date":1505847195,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    //TODO SOLR-11085, we must test overseer failover\n    List<JettySolrRunner> stoppedJetties = notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    //TODO nocommit, we must test overseer failover\n    List<JettySolrRunner> stoppedJetties = notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b8cffee0b9c10b78bd087c71485b482217fe84f","date":1505950827,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    //TODO SOLR-11085, we must test overseer failover\n    List<JettySolrRunner> stoppedJetties = notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n\n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 60000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSingleReplicationAndShardSize(collection3, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 5, 30000);\n\n    assertSingleReplicationAndShardSize(collection4, 5);\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    //disable autoAddReplicas\n    Map m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS,\n        \"val\", \"false\");\n\n    SolrRequest request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    int currentCount = ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1);\n\n    ChaosMonkey.stop(jettys.get(3));\n\n    //solr.xml has defined workLoopDelay=10s and waitAfterExpiration=10s\n    //Hence waiting for 30 seconds to be on the safe side.\n    Thread.sleep(30000);\n    //Ensures that autoAddReplicas has not kicked in.\n    assertTrue(currentCount > ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n\n    //enable autoAddReplicas\n    m = makeMap(\n        \"action\", CollectionParams.CollectionAction.CLUSTERPROP.toLower(),\n        \"name\", ZkStateReader.AUTO_ADD_REPLICAS);\n\n    request = new QueryRequest(new MapSolrParams(m));\n    request.setPath(\"/admin/collections\");\n    cloudClient.request(request);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 90000));\n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    // restart all to test core saved state\n    \n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), collection1, 120000));\n    \n    assertSliceAndReplicaCount(collection1);\n\n    assertUlogDir(collections);\n    \n    assertSliceAndReplicaCount(collection1);\n    assertSingleReplicationAndShardSize(collection3, 5);\n\n    // all docs should be queried\n    assertSingleReplicationAndShardSize(collection4, 5);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    jettys.get(1).stop();\n    jettys.get(2).stop();\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    controlJetty.stop();\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    controlJetty.start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    jettys.get(jettyIndex).stop();\n    jettys.get(jettyIndex).start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    ChaosMonkey.stop(jettys.get(1));\n    ChaosMonkey.stop(jettys.get(2));\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    ChaosMonkey.stop(controlJetty);\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    ChaosMonkey.start(controlJetty);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    ChaosMonkey.stop(jettys.get(jettyIndex));\n    ChaosMonkey.start(jettys.get(jettyIndex));\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","bugFix":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    jettys.get(1).stop();\n    jettys.get(2).stop();\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    controlJetty.stop();\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    controlJetty.start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    jettys.get(jettyIndex).stop();\n    jettys.get(jettyIndex).start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setMaxShardsPerNode(2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setMaxShardsPerNode(1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setMaxShardsPerNode(5)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    jettys.get(1).stop();\n    jettys.get(2).stop();\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    controlJetty.stop();\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    controlJetty.start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    jettys.get(jettyIndex).stop();\n    jettys.get(jettyIndex).start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest#testBasics().mjava","sourceNew":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\");\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\");\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setRouterField(\"myOwnField\");\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setRouterField(\"text\");\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    jettys.get(1).stop();\n    jettys.get(2).stop();\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    controlJetty.stop();\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    controlJetty.start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    jettys.get(jettyIndex).stop();\n    jettys.get(jettyIndex).start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","sourceOld":"  // very slow tests, especially since jetty is started and stopped\n  // serially\n  private void testBasics() throws Exception {\n    String collection1 = \"solrj_collection\";\n    Create createCollectionRequest = CollectionAdminRequest.createCollection(collection1,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response = createCollectionRequest.process(cloudClient);\n\n    assertEquals(0, response.getStatus());\n    assertTrue(response.isSuccess());\n    waitForRecoveriesToFinish(collection1, false);\n    \n    String collection2 = \"solrj_collection2\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection2,\"conf1\",2,2)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(false);\n    CollectionAdminResponse response2 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response2.getStatus());\n    assertTrue(response2.isSuccess());\n    \n    waitForRecoveriesToFinish(collection2, false);\n    \n    String collection3 = \"solrj_collection3\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection3,\"conf1\",5,1)\n            .setRouterField(\"myOwnField\")\n            .setAutoAddReplicas(true);\n    CollectionAdminResponse response3 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response3.getStatus());\n    assertTrue(response3.isSuccess());\n    \n    waitForRecoveriesToFinish(collection3, false);\n\n    // a collection has only 1 replica per a shard\n    String collection4 = \"solrj_collection4\";\n    createCollectionRequest = CollectionAdminRequest.createCollection(collection4,\"conf1\",5,1)\n        .setRouterField(\"text\")\n        .setAutoAddReplicas(true);\n    CollectionAdminResponse response4 = createCollectionRequest.process(getCommonCloudSolrClient());\n\n    assertEquals(0, response4.getStatus());\n    assertTrue(response4.isSuccess());\n\n    waitForRecoveriesToFinish(collection4, false);\n\n    // all collections\n    String[] collections = {collection1, collection2, collection3, collection4};\n\n    // add some documents to collection4\n    final int numDocs = 100;\n    addDocs(collection4, numDocs, false);  // indexed but not committed\n\n    // no result because not committed yet\n    queryAndAssertResultSize(collection4, 0, 10000);\n\n    assertUlogDir(collections);\n\n    jettys.get(1).stop();\n    jettys.get(2).stop();\n\n    Thread.sleep(5000);\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    // collection3 has maxShardsPerNode=1, there are 4 standard jetties and one control jetty and 2 nodes stopped\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection3, 3, 30000);\n\n    // collection4 has maxShardsPerNode=5 and setMaxShardsPerNode=5\n    ClusterStateUtil.waitForLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection4, 5, 30000);\n\n    // all docs should be queried after failover\n    cloudClient.commit(); // to query all docs\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    // collection1 should still be at 4\n    assertEquals(4, ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection1));\n    // and collection2 less than 4\n    assertTrue(ClusterStateUtil.getLiveAndActiveReplicaCount(cloudClient.getZkStateReader(), collection2) < 4);\n\n    assertUlogDir(collections);\n\n    boolean allowOverseerRestart = random().nextBoolean();\n    List<JettySolrRunner> stoppedJetties = allowOverseerRestart\n        ? jettys.stream().filter(jettySolrRunner -> random().nextBoolean()).collect(Collectors.toList()) : notOverseerJetties();\n    ChaosMonkey.stop(stoppedJetties);\n    controlJetty.stop();\n\n    assertTrue(\"Timeout waiting for all not live\", waitingForReplicasNotLive(cloudClient.getZkStateReader(), 45000, stoppedJetties));\n\n    ChaosMonkey.start(stoppedJetties);\n    controlJetty.start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n\n    // all docs should be queried\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n    queryAndAssertResultSize(collection4, numDocs, 10000);\n\n    assertUlogDir(collections);\n\n    int jettyIndex = random().nextInt(jettys.size());\n    jettys.get(jettyIndex).stop();\n    jettys.get(jettyIndex).start();\n\n    assertSliceAndReplicaCount(collection1, 2, 2, 120000);\n\n    assertUlogDir(collections);\n\n    assertSliceAndReplicaCount(collection3, 5, 1, 120000);\n    assertSliceAndReplicaCount(collection4, 5, 1, 120000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"162e1895a880a7263b46e184f1478f0366eb095c":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["3217321f3e1d7922898c6c633d17acfa840d6875","5b8cffee0b9c10b78bd087c71485b482217fe84f"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["560c18d71dad43d675158783c3840f8c80d6d39c"],"bafca15d8e408346a67f4282ad1143b88023893b":["03d03e4c5b46c71c9359363a4310b0a9eab4fa65"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e748d9ee3a1515b2ea3903d067f1f39fffdd083f":["162e1895a880a7263b46e184f1478f0366eb095c"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"579fab47a447cb68f742b3ea201e3398f84daaef":["6ce316a4153e16f795de04b24fcb57d4c2c4a993"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["3217321f3e1d7922898c6c633d17acfa840d6875","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"ab68488225b6a6c357dda72ed11dedca9914a192":["6ce316a4153e16f795de04b24fcb57d4c2c4a993","6ae3ad2b3d171060b5f8d2780f38b1dae608e02d"],"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d":["6ce316a4153e16f795de04b24fcb57d4c2c4a993"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["579fab47a447cb68f742b3ea201e3398f84daaef"],"3217321f3e1d7922898c6c633d17acfa840d6875":["579fab47a447cb68f742b3ea201e3398f84daaef","ac97ea104d893f16aab430d9904473bc1f233f3c"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["bafca15d8e408346a67f4282ad1143b88023893b"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["579fab47a447cb68f742b3ea201e3398f84daaef","3217321f3e1d7922898c6c633d17acfa840d6875"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce","e748d9ee3a1515b2ea3903d067f1f39fffdd083f"],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"03d03e4c5b46c71c9359363a4310b0a9eab4fa65":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["67fd9434ab905954753628cfb5dd0270fed1d817"],"67fd9434ab905954753628cfb5dd0270fed1d817":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"6ce316a4153e16f795de04b24fcb57d4c2c4a993":["e748d9ee3a1515b2ea3903d067f1f39fffdd083f"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"162e1895a880a7263b46e184f1478f0366eb095c":["e748d9ee3a1515b2ea3903d067f1f39fffdd083f"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["67fd9434ab905954753628cfb5dd0270fed1d817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bafca15d8e408346a67f4282ad1143b88023893b":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"e748d9ee3a1515b2ea3903d067f1f39fffdd083f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6ce316a4153e16f795de04b24fcb57d4c2c4a993"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"579fab47a447cb68f742b3ea201e3398f84daaef":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"560c18d71dad43d675158783c3840f8c80d6d39c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"3217321f3e1d7922898c6c633d17acfa840d6875":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["03d03e4c5b46c71c9359363a4310b0a9eab4fa65"],"03d03e4c5b46c71c9359363a4310b0a9eab4fa65":["bafca15d8e408346a67f4282ad1143b88023893b"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"67fd9434ab905954753628cfb5dd0270fed1d817":["5b8cffee0b9c10b78bd087c71485b482217fe84f"],"6ce316a4153e16f795de04b24fcb57d4c2c4a993":["579fab47a447cb68f742b3ea201e3398f84daaef","ab68488225b6a6c357dda72ed11dedca9914a192","6ae3ad2b3d171060b5f8d2780f38b1dae608e02d"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["162e1895a880a7263b46e184f1478f0366eb095c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}