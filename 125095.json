{"path":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","commits":[{"id":"aca9a18be9d7251531953284ee8d8012b022cbc7","date":1519116407,"type":0,"author":"koji","isMerge":false,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      if (config.getPing() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                List<String> cores = getCores(httpSolrClient);\n                for (String core : cores) {\n                  SolrScraperConfig pingConfig;\n                  try {\n                    pingConfig = config.getPing().clone();\n                  } catch (CloneNotSupportedException e) {\n                    logger.error(e.getMessage());\n                    continue;\n                  }\n\n                  pingConfig.getQuery().setCore(core);\n\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, pingConfig, Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n                  Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n\n          try {\n            List<String> collections = getCollections((CloudSolrClient) solrClient);\n            for (String collection : collections) {\n              SolrScraperConfig pingConfig;\n              try {\n                pingConfig = config.getPing().clone();\n              } catch (CloneNotSupportedException e) {\n                logger.error(e.getMessage());\n                continue;\n              }\n\n              pingConfig.getQuery().setCollection(collection);\n              LinkedHashMap<String, String> distrib = new LinkedHashMap<>();\n              distrib.put(\"distrib\", \"true\");\n              pingConfig.getQuery().setParams(Collections.singletonList(distrib));\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        } else {\n          try {\n            List<String> cores = getCores((HttpSolrClient) solrClient);\n            for (String core : cores) {\n              SolrScraperConfig pingConfig = new SolrScraperConfig();\n              pingConfig.setQuery(config.getPing().getQuery());\n              pingConfig.getQuery().setCore(core);\n\n              pingConfig.setJsonQueries(config.getPing().getJsonQueries());\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        }\n      }\n\n      // Metrics\n      if (config.getMetrics() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              SolrScraper scraper = new SolrScraper(httpSolrClient, config.getMetrics(), Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getMetrics());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Collections\n      if (config.getCollections() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getCollections());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Query\n      if (config.getQueries() != null) {\n        for (SolrScraperConfig c : config.getQueries()) {\n          SolrScraper scraper = new SolrScraper(solrClient, c);\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          logger.error(e.getMessage());\n        }\n      }\n    } finally {\n      executorService.shutdown();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6edfc2dfac665ac59cb5f5335512bea5456d1dc3","date":1519140363,"type":4,"author":"koji","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":null,"sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      if (config.getPing() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                List<String> cores = getCores(httpSolrClient);\n                for (String core : cores) {\n                  SolrScraperConfig pingConfig;\n                  try {\n                    pingConfig = config.getPing().clone();\n                  } catch (CloneNotSupportedException e) {\n                    logger.error(e.getMessage());\n                    continue;\n                  }\n\n                  pingConfig.getQuery().setCore(core);\n\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, pingConfig, Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n                  Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n\n          try {\n            List<String> collections = getCollections((CloudSolrClient) solrClient);\n            for (String collection : collections) {\n              SolrScraperConfig pingConfig;\n              try {\n                pingConfig = config.getPing().clone();\n              } catch (CloneNotSupportedException e) {\n                logger.error(e.getMessage());\n                continue;\n              }\n\n              pingConfig.getQuery().setCollection(collection);\n              LinkedHashMap<String, String> distrib = new LinkedHashMap<>();\n              distrib.put(\"distrib\", \"true\");\n              pingConfig.getQuery().setParams(Collections.singletonList(distrib));\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        } else {\n          try {\n            List<String> cores = getCores((HttpSolrClient) solrClient);\n            for (String core : cores) {\n              SolrScraperConfig pingConfig = new SolrScraperConfig();\n              pingConfig.setQuery(config.getPing().getQuery());\n              pingConfig.getQuery().setCore(core);\n\n              pingConfig.setJsonQueries(config.getPing().getJsonQueries());\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        }\n      }\n\n      // Metrics\n      if (config.getMetrics() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              SolrScraper scraper = new SolrScraper(httpSolrClient, config.getMetrics(), Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getMetrics());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Collections\n      if (config.getCollections() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getCollections());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Query\n      if (config.getQueries() != null) {\n        for (SolrScraperConfig c : config.getQueries()) {\n          SolrScraper scraper = new SolrScraper(solrClient, c);\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          logger.error(e.getMessage());\n        }\n      }\n    } finally {\n      executorService.shutdown();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"873efcdf87d1e2a7c3014c56779fec9967a3ec9f","date":1519279726,"type":0,"author":"koji","isMerge":false,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n    \n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      if (config.getPing() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                List<String> cores = getCores(httpSolrClient);\n                for (String core : cores) {\n                  SolrScraperConfig pingConfig;\n                  try {\n                    pingConfig = config.getPing().clone();\n                  } catch (CloneNotSupportedException e) {\n                    logger.error(e.getMessage());\n                    continue;\n                  }\n\n                  pingConfig.getQuery().setCore(core);\n\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, pingConfig, Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n                  Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n\n          try {\n            List<String> collections = getCollections((CloudSolrClient) solrClient);\n            for (String collection : collections) {\n              SolrScraperConfig pingConfig;\n              try {\n                pingConfig = config.getPing().clone();\n              } catch (CloneNotSupportedException e) {\n                logger.error(e.getMessage());\n                continue;\n              }\n\n              pingConfig.getQuery().setCollection(collection);\n              LinkedHashMap<String, String> distrib = new LinkedHashMap<>();\n              distrib.put(\"distrib\", \"true\");\n              pingConfig.getQuery().setParams(Collections.singletonList(distrib));\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        } else {\n          try {\n            List<String> cores = getCores((HttpSolrClient) solrClient);\n            for (String core : cores) {\n              SolrScraperConfig pingConfig = new SolrScraperConfig();\n              pingConfig.setQuery(config.getPing().getQuery());\n              pingConfig.getQuery().setCore(core);\n\n              pingConfig.setJsonQueries(config.getPing().getJsonQueries());\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        }\n      }\n\n      // Metrics\n      if (config.getMetrics() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              SolrScraper scraper = new SolrScraper(httpSolrClient, config.getMetrics(), Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getMetrics());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Collections\n      if (config.getCollections() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getCollections());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Query\n      if (config.getQueries() != null) {\n        for (SolrScraperConfig c : config.getQueries()) {\n          SolrScraper scraper = new SolrScraper(solrClient, c);\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          logger.error(e.getMessage());\n        }\n      }\n    } finally {\n      executorService.shutdown();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b857dd3d30acf3541d2bf24a619d81effc9c11d","date":1519436286,"type":4,"author":"koji","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":null,"sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n    \n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      if (config.getPing() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                List<String> cores = getCores(httpSolrClient);\n                for (String core : cores) {\n                  SolrScraperConfig pingConfig;\n                  try {\n                    pingConfig = config.getPing().clone();\n                  } catch (CloneNotSupportedException e) {\n                    logger.error(e.getMessage());\n                    continue;\n                  }\n\n                  pingConfig.getQuery().setCore(core);\n\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, pingConfig, Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n                  Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n\n          try {\n            List<String> collections = getCollections((CloudSolrClient) solrClient);\n            for (String collection : collections) {\n              SolrScraperConfig pingConfig;\n              try {\n                pingConfig = config.getPing().clone();\n              } catch (CloneNotSupportedException e) {\n                logger.error(e.getMessage());\n                continue;\n              }\n\n              pingConfig.getQuery().setCollection(collection);\n              LinkedHashMap<String, String> distrib = new LinkedHashMap<>();\n              distrib.put(\"distrib\", \"true\");\n              pingConfig.getQuery().setParams(Collections.singletonList(distrib));\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        } else {\n          try {\n            List<String> cores = getCores((HttpSolrClient) solrClient);\n            for (String core : cores) {\n              SolrScraperConfig pingConfig = new SolrScraperConfig();\n              pingConfig.setQuery(config.getPing().getQuery());\n              pingConfig.getQuery().setCore(core);\n\n              pingConfig.setJsonQueries(config.getPing().getJsonQueries());\n\n              SolrScraper scraper = new SolrScraper(solrClient, pingConfig);\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          }\n        }\n      }\n\n      // Metrics\n      if (config.getMetrics() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              SolrScraper scraper = new SolrScraper(httpSolrClient, config.getMetrics(), Arrays.asList(\"zk_host\"), Arrays.asList(((CloudSolrClient) solrClient).getZkHost()));\n              Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n              futureList.add(future);\n            }\n\n            // get future\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getMetrics());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Collections\n      if (config.getCollections() != null) {\n        if (solrClient instanceof CloudSolrClient) {\n          SolrScraper scraper = new SolrScraper(solrClient, config.getCollections());\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Query\n      if (config.getQueries() != null) {\n        for (SolrScraperConfig c : config.getQueries()) {\n          SolrScraper scraper = new SolrScraper(solrClient, c);\n          Future<Map<String, MetricFamilySamples>> future = executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          logger.error(e.getMessage());\n        }\n      }\n    } finally {\n      executorService.shutdown();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1a927b2bca4e3939de1ef05d142c13cee9c1245","date":1520231792,"type":0,"author":"koji","isMerge":false,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.logger.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.logger.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.logger.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f18e0fcd4f3356dffc51840f1d11607f930a1b86","date":1530193458,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.log.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.log.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.log.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.logger.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.logger.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.logger.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.log.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.log.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.log.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.logger.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.logger.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.logger.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.log.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.log.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.log.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.logger.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.logger.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.logger.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.logger.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.logger.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.logger.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cd8a9425419baa85ef4a56ed411ffb4c57964d3","date":1551677567,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/prometheus-exporter/src/java/org/apache/solr/prometheus/collector/SolrCollector#collect().mjava","sourceNew":null,"sourceOld":"  /**\n   * Collect samples.\n   */\n  public List<MetricFamilySamples> collect() {\n    // start time of scraping.\n    long startTime = System.nanoTime();\n\n    this.executorService = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"solr-exporter\"));\n\n    Map<String, MetricFamilySamples> metricFamilySamplesMap = new LinkedHashMap<>();\n\n    List<Future<Map<String, MetricFamilySamples>>> futureList = new ArrayList<>();\n\n    try {\n      // Ping\n      Node pingNode = this.config.getNode(\"/config/rules/ping\", true);\n      if (pingNode != null) {\n        NamedList pingNL = DOMUtil.childNodesToNamedList(pingNode);\n        List<NamedList> requestsNL = pingNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n                String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n                if (coreName == null && collectionName == null) {\n                  try {\n                    List<String> cores = getCores(httpSolrClient);\n                    for (String core : cores) {\n                      LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                      LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                      if (query != null) {\n                        query.put(\"core\", core);\n                      }\n\n                      SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                      Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                      futureList.add(future);\n                    }\n                  } catch (SolrServerException | IOException e) {\n                    this.log.error(\"failed to get cores: \" + e.getMessage());\n                  }\n                } else if (coreName != null && collectionName == null) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(\"failed to get HttpSolrClients: \" + e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(\"failed to close HttpSolrClient: \" + e.getMessage());\n              }\n            }\n          }\n\n          // collection\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            String collectionName = (String) ((NamedList) requestNL.get(\"query\")).get(\"collection\");\n            if (coreName == null && collectionName == null) {\n              try {\n                List<String> collections = getCollections((CloudSolrClient) this.solrClient);\n                for (String collection : collections) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"collection\", collection);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else if (coreName == null && collectionName != null) {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            String coreName = (String) ((NamedList) requestNL.get(\"query\")).get(\"core\");\n            if (coreName == null) {\n              try {\n                List<String> cores = getCores((HttpSolrClient) this.solrClient);\n                for (String core : cores) {\n                  LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n                  LinkedHashMap query = (LinkedHashMap) conf.get(\"query\");\n                  if (query != null) {\n                    query.put(\"core\", core);\n                  }\n\n                  SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n                  Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                  futureList.add(future);\n                }\n              } catch (SolrServerException | IOException e) {\n                this.log.error(\"failed to get cores: \" + e.getMessage());\n              }\n            } else {\n              LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n              SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n              Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n              futureList.add(future);\n            }\n          }\n        }\n      }\n\n      // Metrics\n      Node metricsNode = this.config.getNode(\"/config/rules/metrics\", false);\n      if (metricsNode != null) {\n        NamedList metricsNL = DOMUtil.childNodesToNamedList(metricsNode);\n        List<NamedList> requestsNL = metricsNL.getAll(\"request\");\n\n        if (this.solrClient instanceof CloudSolrClient) {\n          // in SolrCloud mode\n          List<HttpSolrClient> httpSolrClients = new ArrayList<>();\n          try {\n            httpSolrClients = getHttpSolrClients((CloudSolrClient) this.solrClient);\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              for (NamedList requestNL : requestsNL) {\n                LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n                SolrScraper scraper = new SolrScraper(httpSolrClient, conf);\n                Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n                futureList.add(future);\n              }\n            }\n\n            // wait for HttpColeClients\n            for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n              try {\n                Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n                mergeMetrics(metricFamilySamplesMap, m);\n              } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          } catch (SolrServerException | IOException e) {\n            this.log.error(e.getMessage());\n          } finally {\n            for (HttpSolrClient httpSolrClient : httpSolrClients) {\n              try {\n                httpSolrClient.close();\n              } catch (IOException e) {\n                this.log.error(e.getMessage());\n              }\n            }\n          }\n        } else {\n          // in Standalone mode\n          for (NamedList requestNL : requestsNL) {\n            LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n            SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n            Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n            futureList.add(future);\n          }\n        }\n      }\n\n      // Collections\n      Node collectionsNode = this.config.getNode(\"/config/rules/collections\", false);\n      if (collectionsNode != null && this.solrClient instanceof CloudSolrClient) {\n        NamedList collectionsNL = DOMUtil.childNodesToNamedList(collectionsNode);\n        List<NamedList> requestsNL = collectionsNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // Search\n      Node searchNode = this.config.getNode(\"/config/rules/search\", false);\n      if (searchNode != null) {\n        NamedList searchNL = DOMUtil.childNodesToNamedList(searchNode);\n        List<NamedList> requestsNL = searchNL.getAll(\"request\");\n\n        for (NamedList requestNL : requestsNL) {\n          LinkedHashMap conf = (LinkedHashMap) requestNL.asMap(10);\n\n          SolrScraper scraper = new SolrScraper(this.solrClient, conf);\n          Future<Map<String, MetricFamilySamples>> future = this.executorService.submit(scraper);\n          futureList.add(future);\n        }\n      }\n\n      // get future\n      for (Future<Map<String, MetricFamilySamples>> future : futureList) {\n        try {\n          Map<String, MetricFamilySamples> m = future.get(60, TimeUnit.SECONDS);\n          mergeMetrics(metricFamilySamplesMap, m);\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          this.log.error(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      this.log.error(e.getMessage());\n      e.printStackTrace();\n    }\n\n    // return value\n    List<MetricFamilySamples> metricFamiliesSamplesList = new ArrayList<>();\n\n    // add solr metrics\n    for (String gaugeMetricName : metricFamilySamplesMap.keySet()) {\n      MetricFamilySamples metricFamilySamples = metricFamilySamplesMap.get(gaugeMetricName);\n      if (metricFamilySamples.samples.size() > 0) {\n        metricFamiliesSamplesList.add(metricFamilySamples);\n      }\n    }\n\n    // add scrape duration metric\n    List<MetricFamilySamples.Sample> durationSample = new ArrayList<>();\n    durationSample.add(new MetricFamilySamples.Sample(\"solr_exporter_duration_seconds\", new ArrayList<>(), new ArrayList<>(), (System.nanoTime() - startTime) / 1.0E9));\n    metricFamiliesSamplesList.add(new MetricFamilySamples(\"solr_exporter_duration_seconds\", Type.GAUGE, \"Time this Solr exporter took, in seconds.\", durationSample));\n\n    this.executorService.shutdown();\n\n    return metricFamiliesSamplesList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["f1a927b2bca4e3939de1ef05d142c13cee9c1245","f18e0fcd4f3356dffc51840f1d11607f930a1b86"],"873efcdf87d1e2a7c3014c56779fec9967a3ec9f":["6edfc2dfac665ac59cb5f5335512bea5456d1dc3"],"f1a927b2bca4e3939de1ef05d142c13cee9c1245":["0b857dd3d30acf3541d2bf24a619d81effc9c11d"],"f18e0fcd4f3356dffc51840f1d11607f930a1b86":["f1a927b2bca4e3939de1ef05d142c13cee9c1245"],"0b857dd3d30acf3541d2bf24a619d81effc9c11d":["873efcdf87d1e2a7c3014c56779fec9967a3ec9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6edfc2dfac665ac59cb5f5335512bea5456d1dc3":["aca9a18be9d7251531953284ee8d8012b022cbc7"],"aca9a18be9d7251531953284ee8d8012b022cbc7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4cd8a9425419baa85ef4a56ed411ffb4c57964d3"],"4cd8a9425419baa85ef4a56ed411ffb4c57964d3":["f18e0fcd4f3356dffc51840f1d11607f930a1b86"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f1a927b2bca4e3939de1ef05d142c13cee9c1245","f18e0fcd4f3356dffc51840f1d11607f930a1b86"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"873efcdf87d1e2a7c3014c56779fec9967a3ec9f":["0b857dd3d30acf3541d2bf24a619d81effc9c11d"],"f1a927b2bca4e3939de1ef05d142c13cee9c1245":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f18e0fcd4f3356dffc51840f1d11607f930a1b86","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"f18e0fcd4f3356dffc51840f1d11607f930a1b86":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","4cd8a9425419baa85ef4a56ed411ffb4c57964d3","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0b857dd3d30acf3541d2bf24a619d81effc9c11d":["f1a927b2bca4e3939de1ef05d142c13cee9c1245"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aca9a18be9d7251531953284ee8d8012b022cbc7"],"6edfc2dfac665ac59cb5f5335512bea5456d1dc3":["873efcdf87d1e2a7c3014c56779fec9967a3ec9f"],"aca9a18be9d7251531953284ee8d8012b022cbc7":["6edfc2dfac665ac59cb5f5335512bea5456d1dc3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"4cd8a9425419baa85ef4a56ed411ffb4c57964d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}