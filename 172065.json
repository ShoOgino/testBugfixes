{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","commits":[{"id":"b4e5bbc7f726dbcc466cb9b3c029d539a06f6545","date":1336310014,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(10);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6","date":1341575807,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(10);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e7f30683f53928b2fce016e6430c9795caff22","date":1341839598,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(10);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(10);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) _TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = _TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = _TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[_TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/charfilter/TestMappingCharFilter#testRandomMaps2().mjava","sourceNew":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","sourceOld":"  public void testRandomMaps2() throws Exception {\n    final Random random = random();\n    final int numIterations = atLeast(3);\n    for(int iter=0;iter<numIterations;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST iter=\" + iter);\n      }\n\n      final char endLetter = (char) TestUtil.nextInt(random, 'b', 'z');\n\n      final Map<String,String> map = new HashMap<String,String>();\n      final NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();\n      final int numMappings = atLeast(5);\n      if (VERBOSE) {\n        System.out.println(\"  mappings:\");\n      }\n      while (map.size() < numMappings) {\n        final String key = TestUtil.randomSimpleStringRange(random, 'a', endLetter, 7);\n        if (key.length() != 0 && !map.containsKey(key)) {\n          final String value = TestUtil.randomSimpleString(random);\n          map.put(key, value);\n          builder.add(key, value);\n          if (VERBOSE) {\n            System.out.println(\"    \" + key + \" -> \" + value);\n          }\n        }\n      }\n\n      final NormalizeCharMap charMap = builder.build();\n\n      if (VERBOSE) {\n        System.out.println(\"  test random documents...\");\n      }\n\n      for(int iter2=0;iter2<100;iter2++) {\n        final String content = TestUtil.randomSimpleStringRange(random, 'a', endLetter, atLeast(1000));\n\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + content);\n        }\n\n        // Do stupid dog-slow mapping:\n\n        // Output string:\n        final StringBuilder output = new StringBuilder();\n\n        // Maps output offset to input offset:\n        final List<Integer> inputOffsets = new ArrayList<Integer>();\n\n        int cumDiff = 0;\n        int charIdx = 0;\n        while(charIdx < content.length()) {\n\n          int matchLen = -1;\n          String matchRepl = null;\n\n          for(Map.Entry<String,String> ent : map.entrySet()) {\n            final String match = ent.getKey();\n            if (charIdx + match.length() <= content.length()) {\n              final int limit = charIdx+match.length();\n              boolean matches = true;\n              for(int charIdx2=charIdx;charIdx2<limit;charIdx2++) {\n                if (match.charAt(charIdx2-charIdx) != content.charAt(charIdx2)) {\n                  matches = false;\n                  break;\n                }\n              }\n\n              if (matches) {\n                final String repl = ent.getValue();\n                if (match.length() > matchLen) {\n                  // Greedy: longer match wins\n                  matchLen = match.length();\n                  matchRepl = repl;\n                }\n              }\n            }\n          }\n\n          if (matchLen != -1) {\n            // We found a match here!\n            if (VERBOSE) {\n              System.out.println(\"    match=\" + content.substring(charIdx, charIdx+matchLen) + \" @ off=\" + charIdx + \" repl=\" + matchRepl);\n            }\n            output.append(matchRepl);\n            final int minLen = Math.min(matchLen, matchRepl.length());\n\n            // Common part, directly maps back to input\n            // offset:\n            for(int outIdx=0;outIdx<minLen;outIdx++) {\n              inputOffsets.add(output.length() - matchRepl.length() + outIdx + cumDiff);\n            }\n\n            cumDiff += matchLen - matchRepl.length();\n            charIdx += matchLen;\n\n            if (matchRepl.length() < matchLen) {\n              // Replacement string is shorter than matched\n              // input: nothing to do\n            } else if (matchRepl.length() > matchLen) {\n              // Replacement string is longer than matched\n              // input: for all the \"extra\" chars we map\n              // back to a single input offset:\n              for(int outIdx=matchLen;outIdx<matchRepl.length();outIdx++) {\n                inputOffsets.add(output.length() + cumDiff - 1);\n              }\n            } else {\n              // Same length: no change to offset\n            }\n\n            assert inputOffsets.size() == output.length(): \"inputOffsets.size()=\" + inputOffsets.size() + \" vs output.length()=\" + output.length();\n          } else {\n            inputOffsets.add(output.length() + cumDiff);\n            output.append(content.charAt(charIdx));\n            charIdx++;\n          }\n        }\n\n        final String expected = output.toString();\n        if (VERBOSE) {\n          System.out.print(\"    expected:\");\n          for(int charIdx2=0;charIdx2<expected.length();charIdx2++) {\n            System.out.print(\" \" + expected.charAt(charIdx2) + \"/\" + inputOffsets.get(charIdx2));\n          }\n          System.out.println();\n        }\n\n        final MappingCharFilter mapFilter = new MappingCharFilter(charMap, new StringReader(content));\n\n        final StringBuilder actualBuilder = new StringBuilder();\n        final List<Integer> actualInputOffsets = new ArrayList<Integer>();\n\n        // Now consume the actual mapFilter, somewhat randomly:\n        while (true) {\n          if (random.nextBoolean()) {\n            final int ch = mapFilter.read();\n            if (ch == -1) {\n              break;\n            }\n            actualBuilder.append((char) ch);\n          } else {\n            final char[] buffer = new char[TestUtil.nextInt(random, 1, 100)];\n            final int off = buffer.length == 1 ? 0 : random.nextInt(buffer.length-1);\n            final int count = mapFilter.read(buffer, off, buffer.length-off);\n            if (count == -1) {\n              break;\n            } else {\n              actualBuilder.append(buffer, off, count);\n            }\n          }\n\n          if (random.nextInt(10) == 7) {\n            // Map offsets\n            while(actualInputOffsets.size() < actualBuilder.length()) {\n              actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n            }\n          }\n        }\n\n        // Finish mappping offsets\n        while(actualInputOffsets.size() < actualBuilder.length()) {\n          actualInputOffsets.add(mapFilter.correctOffset(actualInputOffsets.size()));\n        }\n\n        final String actual = actualBuilder.toString();\n\n        // Verify:\n        assertEquals(expected, actual);\n        assertEquals(inputOffsets, actualInputOffsets);\n      }        \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"04e7f30683f53928b2fce016e6430c9795caff22":["b4e5bbc7f726dbcc466cb9b3c029d539a06f6545","16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6"],"16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6":["b4e5bbc7f726dbcc466cb9b3c029d539a06f6545"],"6613659748fe4411a7dcf85266e55db1f95f7315":["16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b4e5bbc7f726dbcc466cb9b3c029d539a06f6545","16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6"],"b4e5bbc7f726dbcc466cb9b3c029d539a06f6545":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04e7f30683f53928b2fce016e6430c9795caff22":[],"16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6":["04e7f30683f53928b2fce016e6430c9795caff22","6613659748fe4411a7dcf85266e55db1f95f7315","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"b4e5bbc7f726dbcc466cb9b3c029d539a06f6545":["04e7f30683f53928b2fce016e6430c9795caff22","16f1a3d2871e09ea6774ec5e5d5c21f853a7d5d6","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e5bbc7f726dbcc466cb9b3c029d539a06f6545"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["04e7f30683f53928b2fce016e6430c9795caff22","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}