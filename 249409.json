{"path":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","commits":[{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"/dev/null","sourceNew":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is simpler: you don't have to deal with missing count, etc\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10307c7cc22e7e4087990972985e1d1043f01442","date":1376933032,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is different\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null && term >= 0) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is simpler: you don't have to deal with missing count, etc\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is different\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null && term >= 0) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is simpler: you don't have to deal with missing count, etc\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is different\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null && term >= 0) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is simpler: you don't have to deal with missing count, etc\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bde94df914e38596e2ce6907c04bcca8925e19","date":1385775146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment single-valued facet counts */\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    if (startTermIndex == -1 && (map == null || si.getValueCount() < disi.cost()*10)) {\n      // no prefixing, not too many unique values wrt matching docs (lucene/facets heuristic): \n      //   collect separately per-segment, then map to global ords\n      accumSingleSeg(counts, si, disi, subIndex, map);\n    } else {\n      // otherwise: do collect+map on the fly\n      accumSingleGeneric(counts, startTermIndex, si, disi, subIndex, map);\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is different\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null && term >= 0) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumSingle(int[],int,SortedDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment single-valued facet counts */\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    if (startTermIndex == -1 && (map == null || si.getValueCount() < disi.cost()*10)) {\n      // no prefixing, not too many unique values wrt matching docs (lucene/facets heuristic): \n      //   collect separately per-segment, then map to global ords\n      accumSingleSeg(counts, si, disi, subIndex, map);\n    } else {\n      // otherwise: do collect+map on the fly\n      accumSingleGeneric(counts, startTermIndex, si, disi, subIndex, map);\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment single-valued facet counts, mapping to global ordinal space */\n  // specialized since the single-valued case is different\n  static void accumSingle(int counts[], int startTermIndex, SortedDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int term = si.getOrd(doc);\n      if (map != null && term >= 0) {\n        term = (int) map.getGlobalOrd(subIndex, term);\n      }\n      int arrIdx = term-startTermIndex;\n      if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"10307c7cc22e7e4087990972985e1d1043f01442":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","c7bde94df914e38596e2ce6907c04bcca8925e19"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","10307c7cc22e7e4087990972985e1d1043f01442"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7bde94df914e38596e2ce6907c04bcca8925e19"],"c7bde94df914e38596e2ce6907c04bcca8925e19":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["10307c7cc22e7e4087990972985e1d1043f01442","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"10307c7cc22e7e4087990972985e1d1043f01442":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","74f45af4339b0daf7a95c820ab88c1aea74fbce0","c7bde94df914e38596e2ce6907c04bcca8925e19"],"c7bde94df914e38596e2ce6907c04bcca8925e19":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}