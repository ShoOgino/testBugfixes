{"path":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null) {\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null) {\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0935c850ea562932997b72c69d93e345f21d7f45","date":1344711506,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null) {\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552","date":1344797146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null) {\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null) {\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc124b3b129ef11a255212f3af482b771c5b3a6c","date":1344947616,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    BytesRef payload = current.getPayload();\n    if (mergeState.currentPayloadProcessor[upto] != null && payload != null) {\n      // to not violate the D&P api, we must give the processor a private copy\n      // TODO: reuse a BytesRef if there is a PPP\n      payload = BytesRef.deepCopyOf(payload);\n      mergeState.currentPayloadProcessor[upto].processPayload(payload);\n      if (payload.length == 0) {\n        // don't let PayloadProcessors corrumpt the index\n        return null;\n      }\n    }\n    return payload;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MappingMultiDocsAndPositionsEnum#getPayload().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MappingMultiDocsAndPositionsEnum#getPayload().mjava","sourceNew":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","sourceOld":"  @Override\n  public BytesRef getPayload() throws IOException {\n    return current.getPayload();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","bc124b3b129ef11a255212f3af482b771c5b3a6c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","bc124b3b129ef11a255212f3af482b771c5b3a6c"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["0935c850ea562932997b72c69d93e345f21d7f45"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["bc124b3b129ef11a255212f3af482b771c5b3a6c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bc124b3b129ef11a255212f3af482b771c5b3a6c":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"0935c850ea562932997b72c69d93e345f21d7f45":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"]},"commit2Childs":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c7869f64c874ebf7f317d22c00baf2b6857797a6","0935c850ea562932997b72c69d93e345f21d7f45","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["c7869f64c874ebf7f317d22c00baf2b6857797a6","bc124b3b129ef11a255212f3af482b771c5b3a6c","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc124b3b129ef11a255212f3af482b771c5b3a6c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"0935c850ea562932997b72c69d93e345f21d7f45":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}