{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#UTF16toUTF8(CharSequence,int,int,byte[],IntConsumer).mjava","commits":[{"id":"fad01f81cc24b33263ccec7dbff3fb907702f91e","date":1535461373,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#UTF16toUTF8(CharSequence,int,int,byte[],IntConsumer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A consumer-based UTF16-UTF8 encoder (writes the input string in smaller buffers.).\n   */\n  private static int UTF16toUTF8(final CharSequence s, \n                                final int offset, \n                                final int length, \n                                byte[] buf, \n                                IntConsumer bufferFlusher) {\n    int utf8Len = 0;\n    int j = 0;    \n    for (int i = offset, end = offset + length; i < end; i++) {\n      final int chr = (int) s.charAt(i);\n\n      if (j + 4 >= buf.length) {\n        bufferFlusher.accept(j);\n        utf8Len += j;\n        j = 0;\n      }\n\n      if (chr < 0x80)\n        buf[j++] = (byte) chr;\n      else if (chr < 0x800) {\n        buf[j++] = (byte) (0xC0 | (chr >> 6));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else if (chr < 0xD800 || chr > 0xDFFF) {\n        buf[j++] = (byte) (0xE0 | (chr >> 12));\n        buf[j++] = (byte) (0x80 | ((chr >> 6) & 0x3F));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else {\n        // A surrogate pair. Confirm valid high surrogate.\n        if (chr < 0xDC00 && (i < end - 1)) {\n          int utf32 = (int) s.charAt(i + 1);\n          // Confirm valid low surrogate and write pair.\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) { \n            utf32 = (chr << 10) + utf32 + SURROGATE_OFFSET;\n            i++;\n            buf[j++] = (byte) (0xF0 | (utf32 >> 18));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 12) & 0x3F));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 6) & 0x3F));\n            buf[j++] = (byte) (0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        // Replace unpaired surrogate or out-of-order low surrogate\n        // with substitution character.\n        buf[j++] = (byte) 0xEF;\n        buf[j++] = (byte) 0xBF;\n        buf[j++] = (byte) 0xBD;\n      }\n    }\n\n    bufferFlusher.accept(j);\n    utf8Len += j;\n\n    return utf8Len;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["026ea77412266e9bae6039097f946631d6e8218f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"026ea77412266e9bae6039097f946631d6e8218f","date":1545990925,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#UTF16toUTF8(CharSequence,int,int,byte[],IntConsumer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#UTF16toUTF8(CharSequence,int,int,byte[],IntConsumer).mjava","sourceNew":"  /**\n   * A consumer-based UTF16-UTF8 encoder (writes the input string in smaller buffers.).\n   */\n  private static int UTF16toUTF8(final CharSequence s, \n                                 final int offset,\n                                 final int length,\n                                 byte[] buf,\n                                 IntConsumer bufferFlusher) {\n    int utf8Len = 0;\n    int j = 0;    \n    for (int i = offset, end = offset + length; i < end; i++) {\n      final int chr = (int) s.charAt(i);\n\n      if (j + 4 >= buf.length) {\n        bufferFlusher.accept(j);\n        utf8Len += j;\n        j = 0;\n      }\n\n      if (chr < 0x80)\n        buf[j++] = (byte) chr;\n      else if (chr < 0x800) {\n        buf[j++] = (byte) (0xC0 | (chr >> 6));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else if (chr < 0xD800 || chr > 0xDFFF) {\n        buf[j++] = (byte) (0xE0 | (chr >> 12));\n        buf[j++] = (byte) (0x80 | ((chr >> 6) & 0x3F));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else {\n        // A surrogate pair. Confirm valid high surrogate.\n        if (chr < 0xDC00 && (i < end - 1)) {\n          int utf32 = (int) s.charAt(i + 1);\n          // Confirm valid low surrogate and write pair.\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) { \n            utf32 = (chr << 10) + utf32 + SURROGATE_OFFSET;\n            i++;\n            buf[j++] = (byte) (0xF0 | (utf32 >> 18));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 12) & 0x3F));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 6) & 0x3F));\n            buf[j++] = (byte) (0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        // Replace unpaired surrogate or out-of-order low surrogate\n        // with substitution character.\n        buf[j++] = (byte) 0xEF;\n        buf[j++] = (byte) 0xBF;\n        buf[j++] = (byte) 0xBD;\n      }\n    }\n\n    bufferFlusher.accept(j);\n    utf8Len += j;\n\n    return utf8Len;\n  }\n\n","sourceOld":"  /**\n   * A consumer-based UTF16-UTF8 encoder (writes the input string in smaller buffers.).\n   */\n  private static int UTF16toUTF8(final CharSequence s, \n                                final int offset, \n                                final int length, \n                                byte[] buf, \n                                IntConsumer bufferFlusher) {\n    int utf8Len = 0;\n    int j = 0;    \n    for (int i = offset, end = offset + length; i < end; i++) {\n      final int chr = (int) s.charAt(i);\n\n      if (j + 4 >= buf.length) {\n        bufferFlusher.accept(j);\n        utf8Len += j;\n        j = 0;\n      }\n\n      if (chr < 0x80)\n        buf[j++] = (byte) chr;\n      else if (chr < 0x800) {\n        buf[j++] = (byte) (0xC0 | (chr >> 6));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else if (chr < 0xD800 || chr > 0xDFFF) {\n        buf[j++] = (byte) (0xE0 | (chr >> 12));\n        buf[j++] = (byte) (0x80 | ((chr >> 6) & 0x3F));\n        buf[j++] = (byte) (0x80 | (chr & 0x3F));\n      } else {\n        // A surrogate pair. Confirm valid high surrogate.\n        if (chr < 0xDC00 && (i < end - 1)) {\n          int utf32 = (int) s.charAt(i + 1);\n          // Confirm valid low surrogate and write pair.\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) { \n            utf32 = (chr << 10) + utf32 + SURROGATE_OFFSET;\n            i++;\n            buf[j++] = (byte) (0xF0 | (utf32 >> 18));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 12) & 0x3F));\n            buf[j++] = (byte) (0x80 | ((utf32 >> 6) & 0x3F));\n            buf[j++] = (byte) (0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        // Replace unpaired surrogate or out-of-order low surrogate\n        // with substitution character.\n        buf[j++] = (byte) 0xEF;\n        buf[j++] = (byte) 0xBF;\n        buf[j++] = (byte) 0xBD;\n      }\n    }\n\n    bufferFlusher.accept(j);\n    utf8Len += j;\n\n    return utf8Len;\n  }\n\n","bugFix":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"026ea77412266e9bae6039097f946631d6e8218f":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["026ea77412266e9bae6039097f946631d6e8218f"]},"commit2Childs":{"026ea77412266e9bae6039097f946631d6e8218f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["026ea77412266e9bae6039097f946631d6e8218f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}