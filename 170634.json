{"path":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],MergeState.DocMap[],SortedSourceSlice).mjava","commits":[{"id":"e25729298aefe258b77e1b2676ae1088c1a2c49d","date":1338320376,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],MergeState.DocMap[],SortedSourceSlice).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, MergeState.DocMap[] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final MergeState.DocMap currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null && currentDocMap.hasDeletions()) { // we have deletes\n      for (int i = 0; i < currentDocMap.maxDoc(); i++) {\n        final int doc = currentDocMap.get(i);\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],MergeState.DocMap[],SortedSourceSlice).mjava","sourceNew":null,"sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, MergeState.DocMap[] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final MergeState.DocMap currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null && currentDocMap.hasDeletions()) { // we have deletes\n      for (int i = 0; i < currentDocMap.maxDoc(); i++) {\n        final int doc = currentDocMap.get(i);\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],MergeState.DocMap[],SortedSourceSlice).mjava","sourceNew":null,"sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, MergeState.DocMap[] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final MergeState.DocMap currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null && currentDocMap.hasDeletions()) { // we have deletes\n      for (int i = 0; i < currentDocMap.maxDoc(); i++) {\n        final int doc = currentDocMap.get(i);\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e25729298aefe258b77e1b2676ae1088c1a2c49d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["e25729298aefe258b77e1b2676ae1088c1a2c49d","0837ab0472feecb3a54260729d845f839e1cbd72"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["e25729298aefe258b77e1b2676ae1088c1a2c49d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"e25729298aefe258b77e1b2676ae1088c1a2c49d":["d4d69c535930b5cce125cff868d40f6373dc27d4","0837ab0472feecb3a54260729d845f839e1cbd72"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e25729298aefe258b77e1b2676ae1088c1a2c49d"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}