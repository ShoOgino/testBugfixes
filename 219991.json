{"path":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","commits":[{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e708f948b384f9aa85c665caee4486eb2d9e197d","date":1533106881,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32dc2e73f68d239029f9fe76729eda505b75bb6e","date":1569593453,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      private final BottomValueChecker bottomValueChecker = (executor ==null || leafSlices.length <= 1) ? BottomValueChecker.createMaxBottomScoreChecker() : null;\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c61a0c2cde0e02fd02dc00bb3acf05690975b0f","date":1569842900,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? BottomValueChecker.createMaxBottomScoreChecker() : null;\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      private final BottomValueChecker bottomValueChecker = (executor ==null || leafSlices.length <= 1) ? BottomValueChecker.createMaxBottomScoreChecker() : null;\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74844ead01492c17079ed382d0924f4df2fa72e3","date":1569970726,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? null : BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? BottomValueChecker.createMaxBottomScoreChecker() : null;\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? null : BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60a97329527e682292497dd2f6fae1c519840bae","date":1587668642,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(Math.max(TOTAL_HITS_THRESHOLD, numHits)) :\n          HitsThresholdChecker.createShared(Math.max(TOTAL_HITS_THRESHOLD, numHits));\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    TopFieldDocs topDocs = search(query, manager);\n    if (doDocScores) {\n      TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n    }\n    return topDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"807314aa41c10866aec273a0e54fd0d24d8971de":["74844ead01492c17079ed382d0924f4df2fa72e3"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["e19eef45a852c3316ae52fdf941731448ece967a"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","807314aa41c10866aec273a0e54fd0d24d8971de"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"60a97329527e682292497dd2f6fae1c519840bae":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74844ead01492c17079ed382d0924f4df2fa72e3":["7c61a0c2cde0e02fd02dc00bb3acf05690975b0f"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c61a0c2cde0e02fd02dc00bb3acf05690975b0f":["32dc2e73f68d239029f9fe76729eda505b75bb6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60a97329527e682292497dd2f6fae1c519840bae"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["1d3f7ab1a502671bbdb03bcced21e764d2483221"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["32dc2e73f68d239029f9fe76729eda505b75bb6e","3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"807314aa41c10866aec273a0e54fd0d24d8971de":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["7c61a0c2cde0e02fd02dc00bb3acf05690975b0f"],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["60a97329527e682292497dd2f6fae1c519840bae"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"fccd4a691aac1aff06ab8110d8693514a34160c3":["e19eef45a852c3316ae52fdf941731448ece967a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"60a97329527e682292497dd2f6fae1c519840bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"74844ead01492c17079ed382d0924f4df2fa72e3":["807314aa41c10866aec273a0e54fd0d24d8971de"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["04c370507e5521b2eb998530736f1c19b851ed5a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"7c61a0c2cde0e02fd02dc00bb3acf05690975b0f":["74844ead01492c17079ed382d0924f4df2fa72e3"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}