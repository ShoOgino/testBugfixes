{"path":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","commits":[{"id":"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","date":1310389132,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"/dev/null","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          if (matchIDX < numInputs) {\n            keepOrigs[matchIDX] |= syn.keepOrig;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (outputs[inputIDX] == null || keepOrigs[inputIDX])) {\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["de11853c992f764e52d4164cc9afdebb989dba8a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de11853c992f764e52d4164cc9afdebb989dba8a","date":1313510465,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          if (matchIDX < numInputs) {\n            keepOrigs[matchIDX] |= syn.keepOrig;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (outputs[inputIDX] == null || keepOrigs[inputIDX])) {\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"865b7d0f8430a08d385370b6b87a89a737aa6145","date":1325953575,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          if (synOutputs.length == 1) {\n            // Add endOffset\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + ((inputIDX*2) + syn.in.length());\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41b736fa49f5b885b65c469fb3715600fa88cd2c","date":1325964487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          if (synOutputs.length == 1) {\n            // Add endOffset\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + ((inputIDX*2) + syn.in.length());\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffbcd36aff3bb411177ed61f02fb3d3aa9588d27","date":1333918532,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ffbcd36aff3bb411177ed61f02fb3d3aa9588d27"],"865b7d0f8430a08d385370b6b87a89a737aa6145":["de11853c992f764e52d4164cc9afdebb989dba8a"],"de11853c992f764e52d4164cc9afdebb989dba8a":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"ffbcd36aff3bb411177ed61f02fb3d3aa9588d27":["41b736fa49f5b885b65c469fb3715600fa88cd2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"41b736fa49f5b885b65c469fb3715600fa88cd2c":["865b7d0f8430a08d385370b6b87a89a737aa6145"],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"865b7d0f8430a08d385370b6b87a89a737aa6145":["41b736fa49f5b885b65c469fb3715600fa88cd2c"],"de11853c992f764e52d4164cc9afdebb989dba8a":["865b7d0f8430a08d385370b6b87a89a737aa6145"],"ffbcd36aff3bb411177ed61f02fb3d3aa9588d27":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"41b736fa49f5b885b65c469fb3715600fa88cd2c":["ffbcd36aff3bb411177ed61f02fb3d3aa9588d27"],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["de11853c992f764e52d4164cc9afdebb989dba8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}