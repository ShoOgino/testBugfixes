{"path":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","commits":[{"id":"2070bf73ffa1039a505000f99ea245884ff19e11","date":1177653367,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docID, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      \n      // TODO? how can this ever be 0?!  it is in the document!\n      int freq = reader.docFreq( t );\n      if( freq > 0 ) {\n        f.add( \"docFreq\", reader.docFreq( t ) ); \n      }\n      else {\n        f.add( \"docFreq\", \"zero! How can that be?\" ); \n      }\n      \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docID, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a1a9076189f9cc832856840119afe5c70b4274c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"890ae3a3dee75140a9b592175a15164c7b95f8ed","date":1177740357,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      \n      // TODO? how can this ever be 0?!  it is in the document!\n      int freq = reader.docFreq( t );\n      if( freq > 0 ) {\n        f.add( \"docFreq\", reader.docFreq( t ) ); \n      }\n      else {\n        f.add( \"docFreq\", \"zero! How can that be?\" ); \n      }\n      \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docID, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      \n      // TODO? how can this ever be 0?!  it is in the document!\n      int freq = reader.docFreq( t );\n      if( freq > 0 ) {\n        f.add( \"docFreq\", reader.docFreq( t ) ); \n      }\n      else {\n        f.add( \"docFreq\", \"zero! How can that be?\" ); \n      }\n      \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docID, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6511cb621c585259d6a1f2da408bad8c636c7035","date":1177826927,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      \n      // TODO? how can this ever be 0?!  it is in the document!\n      int freq = reader.docFreq( t );\n      if( freq > 0 ) {\n        f.add( \"docFreq\", reader.docFreq( t ) ); \n      }\n      else {\n        f.add( \"docFreq\", \"zero! How can that be?\" ); \n      }\n      \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":["a1a9076189f9cc832856840119afe5c70b4274c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.warn( \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.log( Level.WARNING, \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1a9076189f9cc832856840119afe5c70b4274c0","date":1258930628,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n\n      Term t = new Term(fieldable.name(), ftype!=null ? ftype.storedToIndexed(fieldable) : fieldable.stringValue());\n\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n\n      // TODO: this really should be \"stored\"\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n\n      byte[] arr = fieldable.getBinaryValue();\n      if (arr != null) {\n        f.add( \"binary\", Base64.byteArrayToBase64(arr, 0, arr.length));\n      }\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", t.text()==null ? 0 : reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.warn( \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n      \n      Term t = new Term( fieldable.name(), fieldable.stringValue() );\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.warn( \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","bugFix":["6511cb621c585259d6a1f2da408bad8c636c7035","2070bf73ffa1039a505000f99ea245884ff19e11"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getDocumentFieldsInfo(Document,int,IndexReader,IndexSchema).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n\n      Term t = new Term(fieldable.name(), ftype!=null ? ftype.storedToIndexed(fieldable) : fieldable.stringValue());\n\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n\n      // TODO: this really should be \"stored\"\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n\n      byte[] arr = fieldable.getBinaryValue();\n      if (arr != null) {\n        f.add( \"binary\", Base64.byteArrayToBase64(arr, 0, arr.length));\n      }\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", t.text()==null ? 0 : reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.warn( \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getDocumentFieldsInfo( Document doc, int docId, IndexReader reader, IndexSchema schema ) throws IOException\n  { \n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    for( Object o : doc.getFields() ) {\n      Fieldable fieldable = (Fieldable)o;\n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldable.name() );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      f.add( \"flags\", getFieldFlags( fieldable ) );\n\n      Term t = new Term(fieldable.name(), ftype!=null ? ftype.storedToIndexed(fieldable) : fieldable.stringValue());\n\n      f.add( \"value\", (ftype==null)?null:ftype.toExternal( fieldable ) );\n\n      // TODO: this really should be \"stored\"\n      f.add( \"internal\", fieldable.stringValue() );  // may be a binary number\n\n      byte[] arr = fieldable.getBinaryValue();\n      if (arr != null) {\n        f.add( \"binary\", Base64.byteArrayToBase64(arr, 0, arr.length));\n      }\n      f.add( \"boost\", fieldable.getBoost() );\n      f.add( \"docFreq\", t.text()==null ? 0 : reader.docFreq( t ) ); // this can be 0 for non-indexed fields\n            \n      // If we have a term vector, return that\n      if( fieldable.isTermVectorStored() ) {\n        try {\n          TermFreqVector v = reader.getTermFreqVector( docId, fieldable.name() );\n          if( v != null ) {\n            SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<Integer>();\n            for( int i=0; i<v.size(); i++ ) {\n              tfv.add( v.getTerms()[i], v.getTermFrequencies()[i] );\n            }\n            f.add( \"termVector\", tfv );\n          }\n        }\n        catch( Exception ex ) {\n          log.warn( \"error writing term vector\", ex );\n        }\n      }\n      \n      finfo.add( fieldable.name(), f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a1a9076189f9cc832856840119afe5c70b4274c0":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"2070bf73ffa1039a505000f99ea245884ff19e11":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ad94625fb8d088209f46650c8097196fec67f00c":["a1a9076189f9cc832856840119afe5c70b4274c0"],"890ae3a3dee75140a9b592175a15164c7b95f8ed":["2070bf73ffa1039a505000f99ea245884ff19e11"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["6511cb621c585259d6a1f2da408bad8c636c7035"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6511cb621c585259d6a1f2da408bad8c636c7035":["890ae3a3dee75140a9b592175a15164c7b95f8ed"]},"commit2Childs":{"a1a9076189f9cc832856840119afe5c70b4274c0":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["2070bf73ffa1039a505000f99ea245884ff19e11"],"2070bf73ffa1039a505000f99ea245884ff19e11":["890ae3a3dee75140a9b592175a15164c7b95f8ed"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"890ae3a3dee75140a9b592175a15164c7b95f8ed":["6511cb621c585259d6a1f2da408bad8c636c7035"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["a1a9076189f9cc832856840119afe5c70b4274c0"],"6511cb621c585259d6a1f2da408bad8c636c7035":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}