{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","commits":[{"id":"c07dc645ff236a7d51da2a5ef49a948dfbf8610c","date":1498242650,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":["c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"bugIntro":["ecdfdb19afb3a1902f1f231678145f8bf94ac07e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecdfdb19afb3a1902f1f231678145f8bf94ac07e","date":1576177083,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6abc35f056fb21f759228d3abc8a471a8721b4a","date":1576230674,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ccce37cad288882dccdbc01a43e6969c28e3aec","date":1582201760,"type":3,"author":"Marc A. Morissette","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#ConcurrentUpdateSolrClient(Builder).mjava","sourceNew":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","sourceOld":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["43d1e498704edd2bba13548a189eed4dfccff11b"],"ecdfdb19afb3a1902f1f231678145f8bf94ac07e":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"43d1e498704edd2bba13548a189eed4dfccff11b":["28288370235ed02234a64753cdbf0c6ec096304a"],"a229cb50768e988c50a2106bdae3a92154f428bf":["43d1e498704edd2bba13548a189eed4dfccff11b","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","43d1e498704edd2bba13548a189eed4dfccff11b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["0ccce37cad288882dccdbc01a43e6969c28e3aec"],"0ccce37cad288882dccdbc01a43e6969c28e3aec":["ecdfdb19afb3a1902f1f231678145f8bf94ac07e"],"f6abc35f056fb21f759228d3abc8a471a8721b4a":["a229cb50768e988c50a2106bdae3a92154f428bf","ecdfdb19afb3a1902f1f231678145f8bf94ac07e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["ecdfdb19afb3a1902f1f231678145f8bf94ac07e","a229cb50768e988c50a2106bdae3a92154f428bf"],"ecdfdb19afb3a1902f1f231678145f8bf94ac07e":["0ccce37cad288882dccdbc01a43e6969c28e3aec","f6abc35f056fb21f759228d3abc8a471a8721b4a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"28288370235ed02234a64753cdbf0c6ec096304a":["43d1e498704edd2bba13548a189eed4dfccff11b"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"43d1e498704edd2bba13548a189eed4dfccff11b":["482ca6c86d7073e3c19096bdc74fe0e73da4554a","a229cb50768e988c50a2106bdae3a92154f428bf","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"a229cb50768e988c50a2106bdae3a92154f428bf":["f6abc35f056fb21f759228d3abc8a471a8721b4a"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ccce37cad288882dccdbc01a43e6969c28e3aec":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"f6abc35f056fb21f759228d3abc8a471a8721b4a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","f6abc35f056fb21f759228d3abc8a471a8721b4a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}