{"path":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            Fieldable [] fields = destinationField.createFields(val, boost);\n            if (fields != null) { // null fields are not added\n              for (Fieldable f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f; \n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getFieldable(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","6d8777a0e10e1e79c0a4aca9faf92867422dd411","fd6ef1120d3887d6a8783b5506c8fea3ddf707f0","d1336abe0899b2984e5652903556c1925fbdca9f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1336abe0899b2984e5652903556c1925fbdca9f","date":1329580100,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, omitNorms ? 1F : docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":["fd6ef1120d3887d6a8783b5506c8fea3ddf707f0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f36ceff99ca3a8239d208fd052bf021c039453a","date":1331681041,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, omitNorms ? 1F : docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, omitNorms ? 1F : docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"'\", ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd6ef1120d3887d6a8783b5506c8fea3ddf707f0","date":1331744509,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.omitNorms() ? 1F : docBoost*boost);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            \n            IndexableField [] fields = destinationField.createFields(val, omitNorms ? 1F : docBoost*boost);\n            if (fields != null) { // null fields are not added\n              for (IndexableField f : fields) {\n                if(f != null) out.add(f);\n              }\n            }\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["b7b4eb250c17a81777008099426ffc71d5ec542b","d1336abe0899b2984e5652903556c1925fbdca9f","292ece8c0acfbfc6126153b17f0c3ca809add4f0","1509f151d7692d84fae414b2b799ac06ba60fcb4","f6ac07612daf67b134b954f2152921766bcddd0d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a3635dad24b0681f0088f2ef680456482cdb451","date":1344025573,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? docBoost*boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? docBoost*boost : 1F);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.omitNorms() ? 1F : docBoost*boost);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","6d8777a0e10e1e79c0a4aca9faf92867422dd411"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? docBoost*boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? docBoost*boost : 1F);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.omitNorms() ? 1F : docBoost*boost);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? docBoost*boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? docBoost*boost : 1F);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean omitNorms = sfield != null && sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (omitNorms && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, omitNorms ? 1F : docBoost*boost);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.omitNorms() ? 1F : docBoost*boost);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d8777a0e10e1e79c0a4aca9faf92867422dd411","date":1348525183,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves (do this after the applyBoost error check so we don't \n      // give an error on fields that don't support boost just because of a \n      // docBoost)\n      boost *= docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? boost : 1F);\n          }\n          \n          // The boost for a given field is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? docBoost*boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? docBoost*boost : 1F);\n          }\n          \n          // In lucene, the boost for a given field is the product of the \n          // document boost and *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = docBoost;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["b7b4eb250c17a81777008099426ffc71d5ec542b","3a3635dad24b0681f0088f2ef680456482cdb451","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","8c8a38c5f82c9db108fb5da0ae290461de3f6ed7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4148af0b1a0b6991d37fc16a075d88fc63068f9","date":1351120943,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n\n            final boolean destHasValues = \n              (null != out.getField(destinationField.getName()));\n\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && destHasValues) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n\n            // we can't copy any boost unless the dest field is \n            // indexed & !omitNorms, but which boost we copy depends\n            // on wether the dest field already contains values (we \n            // don't want to apply the compounded docBoost more then once)\n            final float destBoost = \n              (destinationField.indexed() && !destinationField.omitNorms()) ?\n              (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n            \n            addField(out, destinationField, val, destBoost);\n          }\n          \n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves (do this after the applyBoost error check so we don't \n      // give an error on fields that don't support boost just because of a \n      // docBoost)\n      boost *= docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? boost : 1F);\n          }\n          \n          // The boost for a given field is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["b7b4eb250c17a81777008099426ffc71d5ec542b","6d8777a0e10e1e79c0a4aca9faf92867422dd411","3a3635dad24b0681f0088f2ef680456482cdb451","1509f151d7692d84fae414b2b799ac06ba60fcb4","ebb24ab555aab7c4dd5d2264c06a4f19fb217913"],"bugIntro":["6650a4949e4e39d56b9fe627bdf6060ef4349af2","8c8a38c5f82c9db108fb5da0ae290461de3f6ed7","7602e63987582091a0e432f8d8f7619d2206fab7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n\n            final boolean destHasValues = \n              (null != out.getField(destinationField.getName()));\n\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && destHasValues) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n\n            // we can't copy any boost unless the dest field is \n            // indexed & !omitNorms, but which boost we copy depends\n            // on wether the dest field already contains values (we \n            // don't want to apply the compounded docBoost more then once)\n            final float destBoost = \n              (destinationField.indexed() && !destinationField.omitNorms()) ?\n              (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n            \n            addField(out, destinationField, val, destBoost);\n          }\n          \n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      float boost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      if (applyBoost == false && boost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves (do this after the applyBoost error check so we don't \n      // give an error on fields that don't support boost just because of a \n      // docBoost)\n      boost *= docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? boost : 1f);\n          }\n  \n          // Check if we should copy this field to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n            addField(out, destinationField, val, destinationField.indexed() && !destinationField.omitNorms() ? boost : 1F);\n          }\n          \n          // The boost for a given field is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          boost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7602e63987582091a0e432f8d8f7619d2206fab7","date":1361393626,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n\n            final boolean destHasValues = \n              (null != out.getField(destinationField.getName()));\n\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && destHasValues) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n\n            // we can't copy any boost unless the dest field is \n            // indexed & !omitNorms, but which boost we copy depends\n            // on whether the dest field already contains values (we\n            // don't want to apply the compounded docBoost more then once)\n            final float destBoost = \n              (destinationField.indexed() && !destinationField.omitNorms()) ?\n              (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n            \n            addField(out, destinationField, val, destBoost);\n          }\n          \n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n\n            final boolean destHasValues = \n              (null != out.getField(destinationField.getName()));\n\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && destHasValues) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n\n            // we can't copy any boost unless the dest field is \n            // indexed & !omitNorms, but which boost we copy depends\n            // on wether the dest field already contains values (we \n            // don't want to apply the compounded docBoost more then once)\n            final float destBoost = \n              (destinationField.indexed() && !destinationField.omitNorms()) ?\n              (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n            \n            addField(out, destinationField, val, destBoost);\n          }\n          \n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["d4148af0b1a0b6991d37fc16a075d88fc63068f9"],"bugIntro":["8c8a38c5f82c9db108fb5da0ae290461de3f6ed7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c8a38c5f82c9db108fb5da0ae290461de3f6ed7","date":1405753836,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n            \n            // The final boost for a given field named is the product of the \n            // *all* boosts on values of that field. \n            // For multi-valued fields, we only want to set the boost on the\n            // first field.\n            fieldBoost = compoundBoost = 1.0f;\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          List<CopyField> copyFields = schema.getCopyFieldsList(name);\n          for (CopyField cf : copyFields) {\n            SchemaField destinationField = cf.getDestination();\n\n            final boolean destHasValues = \n              (null != out.getField(destinationField.getName()));\n\n            // check if the copy field is a multivalued or not\n            if (!destinationField.multiValued() && destHasValues) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                              destinationField.getName() + \": \" + v);\n            }\n  \n            used = true;\n            \n            // Perhaps trim the length of a copy field\n            Object val = v;\n            if( val instanceof String && cf.getMaxChars() > 0 ) {\n              val = cf.getLimitedValue((String)val);\n            }\n\n            // we can't copy any boost unless the dest field is \n            // indexed & !omitNorms, but which boost we copy depends\n            // on whether the dest field already contains values (we\n            // don't want to apply the compounded docBoost more then once)\n            final float destBoost = \n              (destinationField.indexed() && !destinationField.omitNorms()) ?\n              (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n            \n            addField(out, destinationField, val, destBoost);\n          }\n          \n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["b7b4eb250c17a81777008099426ffc71d5ec542b","6d8777a0e10e1e79c0a4aca9faf92867422dd411","d4148af0b1a0b6991d37fc16a075d88fc63068f9","292ece8c0acfbfc6126153b17f0c3ca809add4f0","7602e63987582091a0e432f8d8f7619d2206fab7"],"bugIntro":["6650a4949e4e39d56b9fe627bdf6060ef4349af2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","date":1423508552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n            \n            // The final boost for a given field named is the product of the \n            // *all* boosts on values of that field. \n            // For multi-valued fields, we only want to set the boost on the\n            // first field.\n            fieldBoost = compoundBoost = 1.0f;\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n            \n            // The final boost for a given field named is the product of the \n            // *all* boosts on values of that field. \n            // For multi-valued fields, we only want to set the boost on the\n            // first field.\n            fieldBoost = compoundBoost = 1.0f;\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["4230c91a8f260cc364b5a46269bd21d6122b4fbd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6650a4949e4e39d56b9fe627bdf6060ef4349af2","date":1432338324,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n            \n            // The final boost for a given field named is the product of the \n            // *all* boosts on values of that field. \n            // For multi-valued fields, we only want to set the boost on the\n            // first field.\n            fieldBoost = compoundBoost = 1.0f;\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","8c8a38c5f82c9db108fb5da0ae290461de3f6ed7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false);\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false);\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if( copyFields != null ){\n            for (CopyField cf : copyFields) {\n              SchemaField destinationField = cf.getDestination();\n  \n              final boolean destHasValues = usedFields.contains(destinationField.getName());\n  \n              // check if the copy field is a multivalued or not\n              if (!destinationField.multiValued() && destHasValues) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                        \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                                destinationField.getName() + \": \" + v);\n              }\n    \n              used = true;\n              \n              // Perhaps trim the length of a copy field\n              Object val = v;\n              if( val instanceof String && cf.getMaxChars() > 0 ) {\n                val = cf.getLimitedValue((String)val);\n              }\n  \n              // we can't copy any boost unless the dest field is \n              // indexed & !omitNorms, but which boost we copy depends\n              // on whether the dest field already contains values (we\n              // don't want to apply the compounded docBoost more then once)\n              final float destBoost = \n                (destinationField.indexed() && !destinationField.omitNorms()) ?\n                (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n              \n              addField(out, destinationField, val, destBoost);\n              // record the field as having a value\n              usedFields.add(destinationField.getName());\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false, true);\n  }\n\n","sourceOld":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false, true);\n  }\n\n","sourceOld":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false, true);\n  }\n\n","sourceOld":"  /**\n   * @see DocumentBuilder#toDocument(SolrInputDocument, IndexSchema, boolean)\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {\n    return toDocument(doc, schema, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["6650a4949e4e39d56b9fe627bdf6060ef4349af2"],"6d8777a0e10e1e79c0a4aca9faf92867422dd411":["3a3635dad24b0681f0088f2ef680456482cdb451"],"fd6ef1120d3887d6a8783b5506c8fea3ddf707f0":["0f36ceff99ca3a8239d208fd052bf021c039453a"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["6650a4949e4e39d56b9fe627bdf6060ef4349af2","415bbbe7da8065dd3c477bdc3c703c6425622998"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"0f36ceff99ca3a8239d208fd052bf021c039453a":["d1336abe0899b2984e5652903556c1925fbdca9f"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fd6ef1120d3887d6a8783b5506c8fea3ddf707f0","3a3635dad24b0681f0088f2ef680456482cdb451"],"3a3635dad24b0681f0088f2ef680456482cdb451":["fd6ef1120d3887d6a8783b5506c8fea3ddf707f0"],"d4148af0b1a0b6991d37fc16a075d88fc63068f9":["6d8777a0e10e1e79c0a4aca9faf92867422dd411"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["415bbbe7da8065dd3c477bdc3c703c6425622998","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1336abe0899b2984e5652903556c1925fbdca9f":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["fd6ef1120d3887d6a8783b5506c8fea3ddf707f0","3a3635dad24b0681f0088f2ef680456482cdb451"],"6650a4949e4e39d56b9fe627bdf6060ef4349af2":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c26f00b574427b55127e869b935845554afde1fa"],"f2126b84bd093fa3d921582a109a0ee578c28126":["6d8777a0e10e1e79c0a4aca9faf92867422dd411","d4148af0b1a0b6991d37fc16a075d88fc63068f9"],"8c8a38c5f82c9db108fb5da0ae290461de3f6ed7":["7602e63987582091a0e432f8d8f7619d2206fab7"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["8c8a38c5f82c9db108fb5da0ae290461de3f6ed7"],"7602e63987582091a0e432f8d8f7619d2206fab7":["d4148af0b1a0b6991d37fc16a075d88fc63068f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["415bbbe7da8065dd3c477bdc3c703c6425622998","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"6d8777a0e10e1e79c0a4aca9faf92867422dd411":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","f2126b84bd093fa3d921582a109a0ee578c28126"],"fd6ef1120d3887d6a8783b5506c8fea3ddf707f0":["8fd5be977c105554c6a7b68afcdbc511439723ab","3a3635dad24b0681f0088f2ef680456482cdb451","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"c26f00b574427b55127e869b935845554afde1fa":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"0f36ceff99ca3a8239d208fd052bf021c039453a":["fd6ef1120d3887d6a8783b5506c8fea3ddf707f0"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"3a3635dad24b0681f0088f2ef680456482cdb451":["6d8777a0e10e1e79c0a4aca9faf92867422dd411","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d4148af0b1a0b6991d37fc16a075d88fc63068f9":["f2126b84bd093fa3d921582a109a0ee578c28126","7602e63987582091a0e432f8d8f7619d2206fab7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"d1336abe0899b2984e5652903556c1925fbdca9f":["0f36ceff99ca3a8239d208fd052bf021c039453a"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"6650a4949e4e39d56b9fe627bdf6060ef4349af2":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["d1336abe0899b2984e5652903556c1925fbdca9f"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"8c8a38c5f82c9db108fb5da0ae290461de3f6ed7":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["6650a4949e4e39d56b9fe627bdf6060ef4349af2"],"7602e63987582091a0e432f8d8f7619d2206fab7":["8c8a38c5f82c9db108fb5da0ae290461de3f6ed7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","8fd5be977c105554c6a7b68afcdbc511439723ab","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}