{"path":"lucene/grouping/src/test/org/apache/lucene/search/grouping/BaseGroupSelectorTestCase#testShardedGrouping().mjava","commits":[{"id":"fdedc06ffe6518d5666d12901a738624563d147d","date":1588593300,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/BaseGroupSelectorTestCase#testShardedGrouping().mjava","pathOld":"/dev/null","sourceNew":"  public void testShardedGrouping() throws IOException {\n\n    Shard control = new Shard();\n\n    int shardCount = random().nextInt(3) + 2; // between 2 and 4 shards\n    Shard[] shards = new Shard[shardCount];\n    for (int i = 0; i < shardCount; i++) {\n      shards[i] = new Shard();\n    }\n\n    String[] texts = new String[]{ \"foo\", \"bar\", \"bar baz\", \"foo foo bar\" };\n\n    // Create a bunch of random documents, and index them - once into the control index,\n    // and once into a randomly picked shard.\n\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      doc.add(new NumericDocValuesField(\"id\", i));\n      doc.add(new TextField(\"name\", Integer.toString(i), Field.Store.YES));\n      doc.add(new TextField(\"text\", texts[random().nextInt(texts.length)], Field.Store.NO));\n      doc.add(new SortedDocValuesField(\"sort1\", new BytesRef(\"sort\" + random().nextInt(4))));\n      doc.add(new NumericDocValuesField(\"sort2\", random().nextLong()));\n      addGroupField(doc, i);\n      control.writer.addDocument(doc);\n      int shard = random().nextInt(shardCount);\n      shards[shard].writer.addDocument(doc);\n    }\n\n    String[] query = new String[]{ \"foo\", \"bar\", \"baz\" };\n    Query topLevel = new TermQuery(new Term(\"text\", query[random().nextInt(query.length)]));\n\n    Sort sort = new Sort(new SortField(\"sort1\", SortField.Type.STRING), new SortField(\"sort2\", SortField.Type.LONG));\n\n    // A grouped query run in two phases against the control should give us the same\n    // result as the query run against shards and merged back together after each phase.\n\n    FirstPassGroupingCollector<T> singletonFirstPass = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n    control.getIndexSearcher().search(topLevel, singletonFirstPass);\n    Collection<SearchGroup<T>> singletonGroups = singletonFirstPass.getTopGroups(0);\n\n    List<Collection<SearchGroup<T>>> shardGroups = new ArrayList<>();\n    for (Shard shard : shards) {\n      FirstPassGroupingCollector<T> fc = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n      shard.getIndexSearcher().search(topLevel, fc);\n      shardGroups.add(fc.getTopGroups(0));\n    }\n    Collection<SearchGroup<T>> mergedGroups = SearchGroup.merge(shardGroups, 0, 5, sort);\n    assertEquals(singletonGroups, mergedGroups);\n\n    TopGroupsCollector<T> singletonSecondPass = new TopGroupsCollector<>(getGroupSelector(), singletonGroups, sort,\n        Sort.RELEVANCE, 5, true);\n    control.getIndexSearcher().search(topLevel, singletonSecondPass);\n    TopGroups<T> singletonTopGroups = singletonSecondPass.getTopGroups(0);\n\n    // TODO why does SearchGroup.merge() take a list but TopGroups.merge() take an array?\n    @SuppressWarnings(\"unchecked\")\n    TopGroups<T>[] shardTopGroups = new TopGroups[shards.length];\n    int j = 0;\n    for (Shard shard : shards) {\n      TopGroupsCollector<T> sc = new TopGroupsCollector<>(getGroupSelector(), mergedGroups, sort, Sort.RELEVANCE, 5, true);\n      shard.getIndexSearcher().search(topLevel, sc);\n      shardTopGroups[j] = sc.getTopGroups(0);\n      j++;\n    }\n    TopGroups<T> mergedTopGroups = TopGroups.merge(shardTopGroups, sort, Sort.RELEVANCE, 0, 5, TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    assertEquals(singletonTopGroups.totalGroupedHitCount, mergedTopGroups.totalGroupedHitCount);\n    assertEquals(singletonTopGroups.totalHitCount, mergedTopGroups.totalHitCount);\n    assertEquals(singletonTopGroups.totalGroupCount, mergedTopGroups.totalGroupCount);\n    assertEquals(singletonTopGroups.groups.length, mergedTopGroups.groups.length);\n    for (int i = 0; i < singletonTopGroups.groups.length; i++) {\n      assertEquals(singletonTopGroups.groups[i].groupValue, mergedTopGroups.groups[i].groupValue);\n      assertEquals(singletonTopGroups.groups[i].scoreDocs.length, mergedTopGroups.groups[i].scoreDocs.length);\n    }\n\n    control.close();\n    for (Shard shard : shards) {\n      shard.close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/BaseGroupSelectorTestCase#testShardedGrouping().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/BaseGroupSelectorTestCase#testShardedGrouping().mjava","sourceNew":"  public void testShardedGrouping() throws IOException {\n\n    Shard control = new Shard();\n\n    int shardCount = random().nextInt(3) + 2; // between 2 and 4 shards\n    Shard[] shards = new Shard[shardCount];\n    for (int i = 0; i < shardCount; i++) {\n      shards[i] = new Shard();\n    }\n\n    String[] texts = new String[]{ \"foo\", \"bar\", \"bar baz\", \"foo foo bar\" };\n\n    // Create a bunch of random documents, and index them - once into the control index,\n    // and once into a randomly picked shard.\n\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      doc.add(new NumericDocValuesField(\"id\", i));\n      doc.add(new TextField(\"name\", Integer.toString(i), Field.Store.YES));\n      doc.add(new TextField(\"text\", texts[random().nextInt(texts.length)], Field.Store.NO));\n      doc.add(new SortedDocValuesField(\"sort1\", new BytesRef(\"sort\" + random().nextInt(4))));\n      doc.add(new NumericDocValuesField(\"sort2\", random().nextLong()));\n      addGroupField(doc, i);\n      control.writer.addDocument(doc);\n      int shard = random().nextInt(shardCount);\n      shards[shard].writer.addDocument(doc);\n    }\n\n    String[] query = new String[]{ \"foo\", \"bar\", \"baz\" };\n    Query topLevel = new TermQuery(new Term(\"text\", query[random().nextInt(query.length)]));\n\n    Sort sort = new Sort(new SortField(\"sort1\", SortField.Type.STRING), new SortField(\"sort2\", SortField.Type.LONG));\n\n    // A grouped query run in two phases against the control should give us the same\n    // result as the query run against shards and merged back together after each phase.\n\n    FirstPassGroupingCollector<T> singletonFirstPass = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n    control.getIndexSearcher().search(topLevel, singletonFirstPass);\n    Collection<SearchGroup<T>> singletonGroups = singletonFirstPass.getTopGroups(0);\n\n    List<Collection<SearchGroup<T>>> shardGroups = new ArrayList<>();\n    for (Shard shard : shards) {\n      FirstPassGroupingCollector<T> fc = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n      shard.getIndexSearcher().search(topLevel, fc);\n      shardGroups.add(fc.getTopGroups(0));\n    }\n    Collection<SearchGroup<T>> mergedGroups = SearchGroup.merge(shardGroups, 0, 5, sort);\n    assertEquals(singletonGroups, mergedGroups);\n\n    TopGroupsCollector<T> singletonSecondPass = new TopGroupsCollector<>(getGroupSelector(), singletonGroups, sort,\n        Sort.RELEVANCE, 5, true);\n    control.getIndexSearcher().search(topLevel, singletonSecondPass);\n    TopGroups<T> singletonTopGroups = singletonSecondPass.getTopGroups(0);\n\n    // TODO why does SearchGroup.merge() take a list but TopGroups.merge() take an array?\n    @SuppressWarnings(\"unchecked\")\n    TopGroups<T>[] shardTopGroups = (TopGroups<T>[]) new TopGroups<?>[shards.length];\n    int j = 0;\n    for (Shard shard : shards) {\n      TopGroupsCollector<T> sc = new TopGroupsCollector<>(getGroupSelector(), mergedGroups, sort, Sort.RELEVANCE, 5, true);\n      shard.getIndexSearcher().search(topLevel, sc);\n      shardTopGroups[j] = sc.getTopGroups(0);\n      j++;\n    }\n    TopGroups<T> mergedTopGroups = TopGroups.merge(shardTopGroups, sort, Sort.RELEVANCE, 0, 5, TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    assertEquals(singletonTopGroups.totalGroupedHitCount, mergedTopGroups.totalGroupedHitCount);\n    assertEquals(singletonTopGroups.totalHitCount, mergedTopGroups.totalHitCount);\n    assertEquals(singletonTopGroups.totalGroupCount, mergedTopGroups.totalGroupCount);\n    assertEquals(singletonTopGroups.groups.length, mergedTopGroups.groups.length);\n    for (int i = 0; i < singletonTopGroups.groups.length; i++) {\n      assertEquals(singletonTopGroups.groups[i].groupValue, mergedTopGroups.groups[i].groupValue);\n      assertEquals(singletonTopGroups.groups[i].scoreDocs.length, mergedTopGroups.groups[i].scoreDocs.length);\n    }\n\n    control.close();\n    for (Shard shard : shards) {\n      shard.close();\n    }\n\n  }\n\n","sourceOld":"  public void testShardedGrouping() throws IOException {\n\n    Shard control = new Shard();\n\n    int shardCount = random().nextInt(3) + 2; // between 2 and 4 shards\n    Shard[] shards = new Shard[shardCount];\n    for (int i = 0; i < shardCount; i++) {\n      shards[i] = new Shard();\n    }\n\n    String[] texts = new String[]{ \"foo\", \"bar\", \"bar baz\", \"foo foo bar\" };\n\n    // Create a bunch of random documents, and index them - once into the control index,\n    // and once into a randomly picked shard.\n\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      doc.add(new NumericDocValuesField(\"id\", i));\n      doc.add(new TextField(\"name\", Integer.toString(i), Field.Store.YES));\n      doc.add(new TextField(\"text\", texts[random().nextInt(texts.length)], Field.Store.NO));\n      doc.add(new SortedDocValuesField(\"sort1\", new BytesRef(\"sort\" + random().nextInt(4))));\n      doc.add(new NumericDocValuesField(\"sort2\", random().nextLong()));\n      addGroupField(doc, i);\n      control.writer.addDocument(doc);\n      int shard = random().nextInt(shardCount);\n      shards[shard].writer.addDocument(doc);\n    }\n\n    String[] query = new String[]{ \"foo\", \"bar\", \"baz\" };\n    Query topLevel = new TermQuery(new Term(\"text\", query[random().nextInt(query.length)]));\n\n    Sort sort = new Sort(new SortField(\"sort1\", SortField.Type.STRING), new SortField(\"sort2\", SortField.Type.LONG));\n\n    // A grouped query run in two phases against the control should give us the same\n    // result as the query run against shards and merged back together after each phase.\n\n    FirstPassGroupingCollector<T> singletonFirstPass = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n    control.getIndexSearcher().search(topLevel, singletonFirstPass);\n    Collection<SearchGroup<T>> singletonGroups = singletonFirstPass.getTopGroups(0);\n\n    List<Collection<SearchGroup<T>>> shardGroups = new ArrayList<>();\n    for (Shard shard : shards) {\n      FirstPassGroupingCollector<T> fc = new FirstPassGroupingCollector<>(getGroupSelector(), sort, 5);\n      shard.getIndexSearcher().search(topLevel, fc);\n      shardGroups.add(fc.getTopGroups(0));\n    }\n    Collection<SearchGroup<T>> mergedGroups = SearchGroup.merge(shardGroups, 0, 5, sort);\n    assertEquals(singletonGroups, mergedGroups);\n\n    TopGroupsCollector<T> singletonSecondPass = new TopGroupsCollector<>(getGroupSelector(), singletonGroups, sort,\n        Sort.RELEVANCE, 5, true);\n    control.getIndexSearcher().search(topLevel, singletonSecondPass);\n    TopGroups<T> singletonTopGroups = singletonSecondPass.getTopGroups(0);\n\n    // TODO why does SearchGroup.merge() take a list but TopGroups.merge() take an array?\n    @SuppressWarnings(\"unchecked\")\n    TopGroups<T>[] shardTopGroups = new TopGroups[shards.length];\n    int j = 0;\n    for (Shard shard : shards) {\n      TopGroupsCollector<T> sc = new TopGroupsCollector<>(getGroupSelector(), mergedGroups, sort, Sort.RELEVANCE, 5, true);\n      shard.getIndexSearcher().search(topLevel, sc);\n      shardTopGroups[j] = sc.getTopGroups(0);\n      j++;\n    }\n    TopGroups<T> mergedTopGroups = TopGroups.merge(shardTopGroups, sort, Sort.RELEVANCE, 0, 5, TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    assertEquals(singletonTopGroups.totalGroupedHitCount, mergedTopGroups.totalGroupedHitCount);\n    assertEquals(singletonTopGroups.totalHitCount, mergedTopGroups.totalHitCount);\n    assertEquals(singletonTopGroups.totalGroupCount, mergedTopGroups.totalGroupCount);\n    assertEquals(singletonTopGroups.groups.length, mergedTopGroups.groups.length);\n    for (int i = 0; i < singletonTopGroups.groups.length; i++) {\n      assertEquals(singletonTopGroups.groups[i].groupValue, mergedTopGroups.groups[i].groupValue);\n      assertEquals(singletonTopGroups.groups[i].scoreDocs.length, mergedTopGroups.groups[i].scoreDocs.length);\n    }\n\n    control.close();\n    for (Shard shard : shards) {\n      shard.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["fdedc06ffe6518d5666d12901a738624563d147d"],"fdedc06ffe6518d5666d12901a738624563d147d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fdedc06ffe6518d5666d12901a738624563d147d"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fdedc06ffe6518d5666d12901a738624563d147d":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}