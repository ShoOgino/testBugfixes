{"path":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","commits":[{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = Operations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = Operations.union(a, Automata.makeInterval(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    LightAutomaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = BasicOperations.concatenateLight(BasicAutomata.makeStringLight(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = BasicOperations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          LightAutomaton newA = unionTerms(newTerms);\n          a = BasicOperations.unionLight(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = BasicOperations.optionalLight(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(BasicOperations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            LightAutomaton a2 = unionTerms(toRemove);\n            a = BasicOperations.minusLight(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<LightAutomaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          LightAutomaton a2 = randomNoOp(BasicOperations.unionLight(as));\n          a = BasicOperations.minusLight(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<LightAutomaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          LightAutomaton a2 = BasicOperations.unionLight(as);\n          if (random().nextBoolean()) {\n            a2 = BasicOperations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperationsLight.minimize(a2);\n          }\n          a = BasicOperations.intersectionLight(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = SpecialOperations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeIntervalLight(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = BasicOperations.minusLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bab620c8ab32bb77a62753eca4afb8e47efa87c","date":1402997861,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 10) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm);\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm);\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      }\n\n      // assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = Operations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = Operations.union(a, Automata.makeInterval(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 10) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm);\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm);\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      }\n\n      // assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21373874db2a1898e75172c8a5b95e106bac0732","date":1403438868,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm);\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm);\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      }\n\n      // assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 10) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm);\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm);\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      }\n\n      // assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm);\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm);\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      }\n\n      // assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":["6bab620c8ab32bb77a62753eca4afb8e47efa87c","31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95f40061e6a72bec9fae78f9676c006a7a720065","date":1408021099,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 200) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c6ef4579ac33a8699af4e2c72f08960668af682","date":1408096212,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 200) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b2842292fa10ba000930b4d38a7f9abf20b589","date":1415179076,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c035a06cf409b6ffa53965f3cb068908c375f734","date":1435741751,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, Integer.MAX_VALUE);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13b60e3f947fc4f9e2fd81e1929a6809327ff537","date":1435953804,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          // NOTE: This can add a dead state:\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, Integer.MAX_VALUE);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n\n      if (random().nextInt(10) == 7) {\n        a = verifyTopoSort(a);\n      }\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numTerms=\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString()));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size() + \" a.numStates=\" + a.getNumStates());\n        /*\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n        */\n      }\n      switch(random().nextInt(15)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString());\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString());\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRefBuilder newTerm = new BytesRefBuilder();\n          for(BytesRef term : terms) {\n            newTerm.copyBytes(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm.toBytesRef());\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a, Integer.MAX_VALUE);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (a.getNumStates() < 100) {\n          if (VERBOSE) {\n            System.out.println(\"  op=minimize\");\n          }\n          // minimize\n          a = MinimizationOperations.minimize(a, DEFAULT_MAX_DETERMINIZED_STATES);\n        } else if (VERBOSE) {\n          System.out.println(\"  skip op=minimize: too many states (\" + a.getNumStates() + \")\");\n        }\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString()));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2, Integer.MAX_VALUE);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2, DEFAULT_MAX_DETERMINIZED_STATES);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2, DEFAULT_MAX_DETERMINIZED_STATES);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=reverse\");\n          }\n          a = Operations.reverse(a);\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n          }\n          terms = newTerms;\n        }\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        {\n          int min = random().nextInt(1000);\n          int max = min + random().nextInt(50);\n          // digits must be non-zero else we make cycle\n          int digits = Integer.toString(max).length();\n          if (VERBOSE) {\n            System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n          }\n          a = Operations.union(a, Automata.makeDecimalInterval(min, max, digits));\n          StringBuilder b = new StringBuilder();\n          for(int i=0;i<digits;i++) {\n            b.append('0');\n          }\n          String prefix = b.toString();\n          for(int i=min;i<=max;i++) {\n            String s = Integer.toString(i);\n            if (s.length() < digits) {\n              // Left-fill with 0s\n              s = prefix.substring(s.length()) + s;\n            }\n            terms.add(new BytesRef(s));\n          }\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString(), DEFAULT_MAX_DETERMINIZED_STATES);\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n\n      case 14:\n        // Safety in case we are really unlucky w/ the dice:\n        if (terms.size() <= numTerms * 3) {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat finite automaton\");\n          }\n          int count = random().nextBoolean() ? 2 : 3;\n          Set<BytesRef> addTerms = new HashSet<>();\n          while (addTerms.size() < count) {\n            addTerms.add(new BytesRef(getRandomString()));\n          }\n          if (VERBOSE) {\n            for(BytesRef term : addTerms) {\n              System.out.println(\"    term=\" + term);\n            }\n          }\n          Automaton a2 = unionTerms(addTerms);\n          Set<BytesRef> newTerms = new HashSet<>();\n          if (random().nextBoolean()) {\n            // suffix\n            if (VERBOSE) {\n              System.out.println(\"  do suffix\");\n            }\n            a = Operations.concatenate(a, randomNoOp(a2));\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef suffix : addTerms) {\n                newTerm.copyBytes(term);\n                newTerm.append(suffix);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          } else {\n            // prefix\n            if (VERBOSE) {\n              System.out.println(\"  do prefix\");\n            }\n            a = Operations.concatenate(randomNoOp(a2), a);\n            BytesRefBuilder newTerm = new BytesRefBuilder();\n            for(BytesRef term : terms) {\n              for(BytesRef prefix : addTerms) {\n                newTerm.copyBytes(prefix);\n                newTerm.append(term);\n                newTerms.add(newTerm.toBytesRef());\n              }\n            }\n          }\n\n          terms = newTerms;\n        }\n        break;\n      default:\n        throw new AssertionError();\n      }\n\n      assertSame(terms, a);\n      assertEquals(AutomatonTestUtil.isDeterministicSlow(a), a.isDeterministic());\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"c035a06cf409b6ffa53965f3cb068908c375f734":["3e8715d826e588419327562287d5d6a8040d63d6"],"55b2842292fa10ba000930b4d38a7f9abf20b589":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["8c6ef4579ac33a8699af4e2c72f08960668af682"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["21373874db2a1898e75172c8a5b95e106bac0732"],"13b60e3f947fc4f9e2fd81e1929a6809327ff537":["c035a06cf409b6ffa53965f3cb068908c375f734"],"21373874db2a1898e75172c8a5b95e106bac0732":["5c84485629d80d203608e8975a1139de9933cc38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d2638f781be724518ff6c2263d14a48cf6e68017":["55b2842292fa10ba000930b4d38a7f9abf20b589","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["55b2842292fa10ba000930b4d38a7f9abf20b589"],"5c84485629d80d203608e8975a1139de9933cc38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["13b60e3f947fc4f9e2fd81e1929a6809327ff537"],"8c6ef4579ac33a8699af4e2c72f08960668af682":["95f40061e6a72bec9fae78f9676c006a7a720065"],"95f40061e6a72bec9fae78f9676c006a7a720065":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["5c84485629d80d203608e8975a1139de9933cc38"],"c035a06cf409b6ffa53965f3cb068908c375f734":["13b60e3f947fc4f9e2fd81e1929a6809327ff537"],"55b2842292fa10ba000930b4d38a7f9abf20b589":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["55b2842292fa10ba000930b4d38a7f9abf20b589"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["95f40061e6a72bec9fae78f9676c006a7a720065"],"13b60e3f947fc4f9e2fd81e1929a6809327ff537":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21373874db2a1898e75172c8a5b95e106bac0732":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","5c84485629d80d203608e8975a1139de9933cc38"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["c035a06cf409b6ffa53965f3cb068908c375f734","d2638f781be724518ff6c2263d14a48cf6e68017"],"5c84485629d80d203608e8975a1139de9933cc38":["21373874db2a1898e75172c8a5b95e106bac0732"],"8c6ef4579ac33a8699af4e2c72f08960668af682":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"95f40061e6a72bec9fae78f9676c006a7a720065":["8c6ef4579ac33a8699af4e2c72f08960668af682"]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}