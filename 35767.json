{"path":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testForcedMergeWithPending().mjava","commits":[{"id":"79ba4baff197d5691f403962548d82fe855e4101","date":1552642047,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testForcedMergeWithPending().mjava","pathOld":"/dev/null","sourceNew":"  // Make sure that TieredMergePolicy doesn't do the final merge while there are merges ongoing, but does do non-final\n  // merges while merges are ongoing.\n  public void testForcedMergeWithPending() throws Exception {\n    final TieredMergePolicy tmp = new TieredMergePolicy();\n    final double maxSegmentSize = 10.0D;\n    tmp.setMaxMergedSegmentMB(maxSegmentSize);\n\n    SegmentInfos infos = new SegmentInfos(Version.LATEST.major);\n    for (int j = 0; j < 30; ++j) {\n      infos.add(makeSegmentCommitInfo(\"_\" + j, 1000, 0, 1.0D, IndexWriter.SOURCE_MERGE));\n    }\n    final MockMergeContext mergeContext = new MockMergeContext(SegmentCommitInfo::getDelCount);\n    mergeContext.setMergingSegments(Collections.singleton(infos.asList().get(0)));\n    final int expectedCount = random().nextInt(10) + 3;\n    final MergeSpecification specification = tmp.findForcedMerges(infos, expectedCount, segmentsToMerge(infos), mergeContext);\n    // Since we have fewer than 30 (the max merge count) segments more than the final size this would have been the final merge\n    // so we check that it was prevented.\n    assertNull(specification);\n\n    SegmentInfos manySegmentsInfos = new SegmentInfos(Version.LATEST.major);\n    final int manySegmentsCount = atLeast(500);\n    for (int j = 0; j < manySegmentsCount; ++j) {\n      manySegmentsInfos.add(makeSegmentCommitInfo(\"_\" + j, 1000, 0, 0.1D, IndexWriter.SOURCE_MERGE));\n    }\n\n    // We set one merge to be ongoing. Since we have more than 30 (the max merge count) times the number of segments\n    // of that we want to merge to this is not the final merge and hence the returned specification must not be null.\n    mergeContext.setMergingSegments(Collections.singleton(manySegmentsInfos.asList().get(0)));\n    final MergeSpecification specificationManySegments =\n        tmp.findForcedMerges(manySegmentsInfos, expectedCount, segmentsToMerge(manySegmentsInfos), mergeContext);\n    assertMaxSize(specificationManySegments, maxSegmentSize);\n    for (OneMerge merge : specificationManySegments.merges) {\n      assertEquals(\"No merges of less than the max merge count are permitted while another merge is in progress\",\n          merge.segments.size(), tmp.getMaxMergeAtOnceExplicit());\n    }\n    final int resultingCountManySegments = manySegmentsInfos.size() + specificationManySegments.merges.size()\n        - specificationManySegments.merges.stream().mapToInt(spec -> spec.segments.size()).sum();\n    assertTrue(resultingCountManySegments >= expectedCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"79ba4baff197d5691f403962548d82fe855e4101":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["79ba4baff197d5691f403962548d82fe855e4101"]},"commit2Childs":{"79ba4baff197d5691f403962548d82fe855e4101":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["79ba4baff197d5691f403962548d82fe855e4101"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}