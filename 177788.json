{"path":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","commits":[{"id":"50cdf7ad2df581562492397453567ab551cc74f9","date":1335885944,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does reopen at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.lock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ab98cea4388ed9a87f9d519696e2f7b68c25a84","date":1335888959,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does reopen at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does reopen at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.lock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b7a1bc6030c258e47d63eff3455a2b1bbf32683","date":1339494023,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does reopen at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":["50cdf7ad2df581562492397453567ab551cc74f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException, InterruptedException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef","date":1351890270,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   * @throws IOException if refreshing the resource causes an {@link IOException}\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   * @throws IOException if refreshing the resource causes an {@link IOException}\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   * @throws IOException if refreshing the resource causes an {@link IOException}\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#maybeRefreshBlocking().mjava","sourceNew":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   * @throws IOException if refreshing the resource causes an {@link IOException}\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this (or {@link #maybeRefresh()}), periodically, if you want\n   * that {@link #acquire()} will return refreshed instances.\n   * \n   * <p>\n   * <b>Threads</b>: unlike {@link #maybeRefresh()}, if another thread is\n   * currently refreshing, this method blocks until that thread completes. It is\n   * useful if you want to guarantee that the next call to {@link #acquire()}\n   * will return a refreshed instance. Otherwise, consider using the\n   * non-blocking {@link #maybeRefresh()}.\n   * @throws IOException if refreshing the resource causes an {@link IOException}\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final void maybeRefreshBlocking() throws IOException {\n    ensureOpen();\n\n    // Ensure only 1 thread does refresh at once\n    refreshLock.lock();\n    try {\n      doMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["0ab98cea4388ed9a87f9d519696e2f7b68c25a84"],"0ab98cea4388ed9a87f9d519696e2f7b68c25a84":["50cdf7ad2df581562492397453567ab551cc74f9"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"50cdf7ad2df581562492397453567ab551cc74f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["19275ba31e621f6da1b83bf13af75233876fd3d4"]},"commit2Childs":{"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50cdf7ad2df581562492397453567ab551cc74f9"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0ab98cea4388ed9a87f9d519696e2f7b68c25a84":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef"],"50cdf7ad2df581562492397453567ab551cc74f9":["0ab98cea4388ed9a87f9d519696e2f7b68c25a84"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}