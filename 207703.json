{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","commits":[{"id":"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf","date":1440482195,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    List<String> children = null;\n    try {\n      children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n    } catch (KeeperException.NoNodeException e) {\n      log.warn(\"Error fetching collection names\");\n      // fall through\n    }\n    if (children == null || children.isEmpty()) {\n      lazyCollectionStates.clear();\n      return;\n    }\n\n    // Don't mess with watchedCollections, they should self-manage.\n\n    // First, drop any children that disappeared.\n    this.lazyCollectionStates.keySet().retainAll(children);\n    for (String coll : children) {\n      // We will create an eager collection for any interesting collections, so don't add to lazy.\n      if (!interestingCollections.contains(coll)) {\n        // Double check contains just to avoid allocating an object.\n        LazyCollectionRef existing = lazyCollectionStates.get(coll);\n        if (existing == null) {\n          lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7477015ee104ad8144fba06b9b0a8ea93aea50f8","date":1450790907,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    List<String> children = null;\n    try {\n      children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n    } catch (KeeperException.NoNodeException e) {\n      LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n      // fall through\n    }\n    if (children == null || children.isEmpty()) {\n      lazyCollectionStates.clear();\n      return;\n    }\n\n    // Don't mess with watchedCollections, they should self-manage.\n\n    // First, drop any children that disappeared.\n    this.lazyCollectionStates.keySet().retainAll(children);\n    for (String coll : children) {\n      // We will create an eager collection for any interesting collections, so don't add to lazy.\n      if (!interestingCollections.contains(coll)) {\n        // Double check contains just to avoid allocating an object.\n        LazyCollectionRef existing = lazyCollectionStates.get(coll);\n        if (existing == null) {\n          lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    List<String> children = null;\n    try {\n      children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n    } catch (KeeperException.NoNodeException e) {\n      log.warn(\"Error fetching collection names\");\n      // fall through\n    }\n    if (children == null || children.isEmpty()) {\n      lazyCollectionStates.clear();\n      return;\n    }\n\n    // Don't mess with watchedCollections, they should self-manage.\n\n    // First, drop any children that disappeared.\n    this.lazyCollectionStates.keySet().retainAll(children);\n    for (String coll : children) {\n      // We will create an eager collection for any interesting collections, so don't add to lazy.\n      if (!interestingCollections.contains(coll)) {\n        // Double check contains just to avoid allocating an object.\n        LazyCollectionRef existing = lazyCollectionStates.get(coll);\n        if (existing == null) {\n          lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3726445f8e9a7d398466439f0f84b5bb329fdcc","date":1460555680,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    List<String> children = null;\n    try {\n      children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n    } catch (KeeperException.NoNodeException e) {\n      LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n      // fall through\n    }\n    if (children == null || children.isEmpty()) {\n      lazyCollectionStates.clear();\n      return;\n    }\n\n    // Don't mess with watchedCollections, they should self-manage.\n\n    // First, drop any children that disappeared.\n    this.lazyCollectionStates.keySet().retainAll(children);\n    for (String coll : children) {\n      // We will create an eager collection for any interesting collections, so don't add to lazy.\n      if (!interestingCollections.contains(coll)) {\n        // Double check contains just to avoid allocating an object.\n        LazyCollectionRef existing = lazyCollectionStates.get(coll);\n        if (existing == null) {\n          lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n        }\n      }\n    }\n  }\n\n","bugFix":["7477015ee104ad8144fba06b9b0a8ea93aea50f8","8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    List<String> children = null;\n    try {\n      children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n    } catch (KeeperException.NoNodeException e) {\n      LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n      // fall through\n    }\n    if (children == null || children.isEmpty()) {\n      lazyCollectionStates.clear();\n      return;\n    }\n\n    // Don't mess with watchedCollections, they should self-manage.\n\n    // First, drop any children that disappeared.\n    this.lazyCollectionStates.keySet().retainAll(children);\n    for (String coll : children) {\n      // We will create an eager collection for any interesting collections, so don't add to lazy.\n      if (!interestingCollections.contains(coll)) {\n        // Double check contains just to avoid allocating an object.\n        LazyCollectionRef existing = lazyCollectionStates.get(coll);\n        if (existing == null) {\n          lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} method as a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b4df85b7268ca40452d6c01343d8eb00ed1f70a","date":1463171656,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f","date":1467384467,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Map)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c","date":1467728244,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Map)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            LOG.info(\"Adding lazy collectionRef for collection {}\", coll);\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Map)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f54f0eff6955cf57610f6b93dbbba3a2bf540619","date":1467968491,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Map)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            LOG.info(\"Adding lazy collectionRef for collection {}\", coll);\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f","b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState()} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!interestingCollections.contains(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["e9974f61802aea1d15849a1053f88f5e89fc32b4"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollections()} and {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        LOG.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   * <p>\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   *\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable collections.\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable state format2 collections.\n   * <p>\n   * A stateFormat=1 collection which is not interesting to us can also\n   * be put into the {@link #lazyCollectionStates} map here. But that is okay\n   * because {@link #constructState(Set)} will give priority to collections in the\n   * shared collection state over this map.\n   * In fact this is a clever way to avoid doing a ZK exists check on\n   * the /collections/collection_name/state.json znode\n   * Such an exists check is done in {@link ClusterState#hasCollection(String)} and\n   * {@link ClusterState#getCollectionsMap()} methods\n   * have a safeguard against exposing wrong collection names to the users\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["f54f0eff6955cf57610f6b93dbbba3a2bf540619","344b0840364d990b29b97467bfcc766ff8325d11","e9974f61802aea1d15849a1053f88f5e89fc32b4","8bf04c3f77a2936f29948b9c0dd215d82d43f5cf","2668c99990e4c94a78bac005aa682b7c5986d23a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshCollectionList(Watcher).mjava","sourceNew":"  /**\n   * Search for any lazy-loadable collections.\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: \", e);\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Search for any lazy-loadable collections.\n   */\n  private void refreshCollectionList(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshCollectionListLock) {\n      List<String> children = null;\n      try {\n        children = zkClient.getChildren(COLLECTIONS_ZKNODE, watcher, true);\n      } catch (KeeperException.NoNodeException e) {\n        log.warn(\"Error fetching collection names: [{}]\", e.getMessage());\n        // fall through\n      }\n      if (children == null || children.isEmpty()) {\n        lazyCollectionStates.clear();\n        return;\n      }\n\n      // Don't lock getUpdateLock() here, we don't need it and it would cause deadlock.\n      // Don't mess with watchedCollections, they should self-manage.\n\n      // First, drop any children that disappeared.\n      this.lazyCollectionStates.keySet().retainAll(children);\n      for (String coll : children) {\n        // We will create an eager collection for any interesting collections, so don't add to lazy.\n        if (!collectionWatches.containsKey(coll)) {\n          // Double check contains just to avoid allocating an object.\n          LazyCollectionRef existing = lazyCollectionStates.get(coll);\n          if (existing == null) {\n            lazyCollectionStates.putIfAbsent(coll, new LazyCollectionRef(coll));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c"],"73450c0955930295d34703e7ddbfc6973b7a121a":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","73450c0955930295d34703e7ddbfc6973b7a121a"],"344b0840364d990b29b97467bfcc766ff8325d11":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"0ad30c6a479e764150a3316e57263319775f1df2":["73450c0955930295d34703e7ddbfc6973b7a121a","5b4df85b7268ca40452d6c01343d8eb00ed1f70a"],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73450c0955930295d34703e7ddbfc6973b7a121a","0ad30c6a479e764150a3316e57263319775f1df2"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["f54f0eff6955cf57610f6b93dbbba3a2bf540619","344b0840364d990b29b97467bfcc766ff8325d11"],"b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["7477015ee104ad8144fba06b9b0a8ea93aea50f8","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["344b0840364d990b29b97467bfcc766ff8325d11"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["344b0840364d990b29b97467bfcc766ff8325d11","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"73450c0955930295d34703e7ddbfc6973b7a121a":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","5b4df85b7268ca40452d6c01343d8eb00ed1f70a"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"b40d6d2c1c421c3a8eaef4f9fa4a2710576c104c":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["d3726445f8e9a7d398466439f0f84b5bb329fdcc","9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["0ad30c6a479e764150a3316e57263319775f1df2"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}