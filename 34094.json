{"path":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e230a61047bc041516c811baa08a7174d6f8322a","date":1306175633,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e230a61047bc041516c811baa08a7174d6f8322a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["9454a6510e2db155fb01faa5c049b06ece95fab9","e230a61047bc041516c811baa08a7174d6f8322a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e230a61047bc041516c811baa08a7174d6f8322a"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["9454a6510e2db155fb01faa5c049b06ece95fab9","e230a61047bc041516c811baa08a7174d6f8322a"]},"commit2Childs":{"e230a61047bc041516c811baa08a7174d6f8322a":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e230a61047bc041516c811baa08a7174d6f8322a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}