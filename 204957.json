{"path":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","commits":[{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(NO_OUTPUT, Util.get(fst, input2));\n          nextInput(r, ints2);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(input2, pair.input);\n          assertEquals(NO_OUTPUT, pair.output);\n          upto++;\n          nextInput(r, ints2);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        r = new Random(seed);\n        Arrays.fill(ints, 0);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          r.nextBytes(outputBytes);\n          assertEquals(output, Util.get(fst, input));\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          r.nextBytes(outputBytes);\n          assertEquals(output, pair.output);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints, 0);\n\n        output = 1;\n        r = new Random(seed);\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n\n          // forward lookup:\n          assertEquals(output, Util.get(fst, input).longValue());\n          // reverse lookup:\n          assertEquals(input, Util.getByOutput(fst, output));\n          output += 1 + r.nextInt(10);\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        output = 1;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          assertEquals(output, pair.output.longValue());\n          output += 1 + r.nextInt(10);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8405d98acebb7e287bf7ac40e937ba05b8661285","651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(NO_OUTPUT, Util.get(fst, input2));\n          nextInput(r, ints2);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(input2, pair.input);\n          assertEquals(NO_OUTPUT, pair.output);\n          upto++;\n          nextInput(r, ints2);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        r = new Random(seed);\n        Arrays.fill(ints, 0);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          r.nextBytes(outputBytes);\n          assertEquals(output, Util.get(fst, input));\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          r.nextBytes(outputBytes);\n          assertEquals(output, pair.output);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints, 0);\n\n        output = 1;\n        r = new Random(seed);\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n\n          // forward lookup:\n          assertEquals(output, Util.get(fst, input).longValue());\n          // reverse lookup:\n          assertEquals(input, Util.getByOutput(fst, output));\n          output += 1 + r.nextInt(10);\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        output = 1;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          assertEquals(output, pair.output.longValue());\n          output += 1 + r.nextInt(10);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"651a27b35167c2ea81f87f4749722e52b7d5b750","date":1359669118,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(_TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(NO_OUTPUT, Util.get(fst, input2));\n          nextInput(r, ints2);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(input2, pair.input);\n          assertEquals(NO_OUTPUT, pair.output);\n          upto++;\n          nextInput(r, ints2);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        r = new Random(seed);\n        Arrays.fill(ints, 0);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          r.nextBytes(outputBytes);\n          assertEquals(output, Util.get(fst, input));\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          r.nextBytes(outputBytes);\n          assertEquals(output, pair.output);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints, 0);\n\n        output = 1;\n        r = new Random(seed);\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n\n          // forward lookup:\n          assertEquals(output, Util.get(fst, input).longValue());\n          // reverse lookup:\n          assertEquals(input, Util.getByOutput(fst, output));\n          output += 1 + r.nextInt(10);\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        output = 1;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          assertEquals(output, pair.output.longValue());\n          output += 1 + r.nextInt(10);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n    }\n  }\n\n","bugFix":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"bugIntro":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","date":1359670147,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(_TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(NO_OUTPUT, Util.get(fst, input2));\n          nextInput(r, ints2);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n        Arrays.fill(ints2, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          for(int j=10;j<ints2.length;j++) {\n            ints2[j] = r.nextInt(256);\n          }\n          assertEquals(input2, pair.input);\n          assertEquals(NO_OUTPUT, pair.output);\n          upto++;\n          nextInput(r, ints2);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        r = new Random(seed);\n        Arrays.fill(ints, 0);\n\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n          r.nextBytes(outputBytes);\n          assertEquals(output, Util.get(fst, input));\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          r.nextBytes(outputBytes);\n          assertEquals(output, pair.output);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n        Arrays.fill(ints, 0);\n\n        output = 1;\n        r = new Random(seed);\n        for(int i=0;i<count;i++) {\n          if (i % 1000000 == 0) {\n            System.out.println(i + \"...: \");\n          }\n\n          // forward lookup:\n          assertEquals(output, Util.get(fst, input).longValue());\n          // reverse lookup:\n          assertEquals(input, Util.getByOutput(fst, output));\n          output += 1 + r.nextInt(10);\n          nextInput(r, ints);\n        }\n\n        System.out.println(\"\\nTEST: enum all input/outputs\");\n        IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n        Arrays.fill(ints, 0);\n        r = new Random(seed);\n        int upto = 0;\n        output = 1;\n        while(true) {\n          IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n          if (pair == null) {\n            break;\n          }\n          assertEquals(input, pair.input);\n          assertEquals(output, pair.output.longValue());\n          output += 1 + r.nextInt(10);\n          upto++;\n          nextInput(r, ints);\n        }\n        assertEquals(count, upto);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","date":1370275238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(_TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(_TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 3B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, false, false, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(_TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<Object>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<Object>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Object>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<BytesRef>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<BytesRef>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<Long>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<Long>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(TestUtil.getTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8405d98acebb7e287bf7ac40e937ba05b8661285","date":1401433291,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstSizeInBytes() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstSizeInBytes() + \" bytes\");\n          }\n          if (b.fstSizeInBytes() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.sizeInBytes() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","651a27b35167c2ea81f87f4749722e52b7d5b750"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                      null, doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                          null, doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  null, doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getTotStateCount() + \" nodes\");\n          }\n          if (b.getTotStateCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fst.getNodeCount() + \"; arcCount=\" + fst.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFiles(Collections.singleton(\"fst\"));\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int doPackIter=0;doPackIter<2;doPackIter++) {\n      boolean doPack = doPackIter == 1;\n\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      if (!doPack) {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                doPack, PackedInts.COMPACT, true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  doPack, PackedInts.COMPACT, true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; doPack=\" + doPack + \" outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              doPack, PackedInts.COMPACT, true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"336a0bd816238e31c31e191e1b046e974f7ae5fe","date":1482358070,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15, true);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15, true);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15, true);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 1000000 == 0) {\n            System.out.println(count + \"...: \" + b.fstRamBytesUsed() + \" bytes\");\n          }\n          if (b.fstRamBytesUsed() > LIMIT) {\n            break;\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15, true);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15, true);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15, true);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  @SuppressWarnings(\"deprecation\")\n  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"deprecation\")\n  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final Builder<Object> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                true, 15);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          b.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + b.fstRamBytesUsed() + \" bytes; \" + b.getNodeCount() + \" nodes\");\n          }\n          if (b.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final Builder<BytesRef> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                                  true, 15);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = b.finish();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final Builder<Long> b = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs,\n                                              true, 15);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          b.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = b.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = b.finish();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + b.getNodeCount() + \"; arcCount=\" + b.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            @SuppressWarnings(\"deprecation\")\n            IntsRef inputResult = Util.getByOutput(fst, output);\n            assertEquals(input, inputResult);\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            assertEquals(input, Util.getByOutput(fst, output));\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/Test2BFST#test().mjava","sourceNew":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out, out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out, out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            @SuppressWarnings(\"deprecation\")\n            IntsRef inputResult = Util.getByOutput(fst, output);\n            assertEquals(input, inputResult);\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out, out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    assumeWorkingMMapOnWindows();\n    \n    int[] ints = new int[7];\n    IntsRef input = new IntsRef(ints, 0, ints.length);\n    long seed = random().nextLong();\n\n    Directory dir = new MMapDirectory(createTempDir(\"2BFST\"));\n\n    for(int iter=0;iter<1;iter++) {\n      // Build FST w/ NoOutputs and stop when nodeCount > 2.2B\n      {\n        System.out.println(\"\\nTEST: 3B nodes; doPack=false output=NO_OUTPUTS\");\n        Outputs<Object> outputs = NoOutputs.getSingleton();\n        Object NO_OUTPUT = outputs.getNoOutput();\n        final FSTCompiler<Object> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        int count = 0;\n        Random r = new Random(seed);\n        int[] ints2 = new int[200];\n        IntsRef input2 = new IntsRef(ints2, 0, ints2.length);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          for(int i=10;i<ints2.length;i++) {\n            ints2[i] = r.nextInt(256);\n          }\n          fstCompiler.add(input2, NO_OUTPUT);\n          count++;\n          if (count % 100000 == 0) {\n            System.out.println(count + \": \" + fstCompiler.fstRamBytesUsed() + \" bytes; \" + fstCompiler.getNodeCount() + \" nodes\");\n          }\n          if (fstCompiler.getNodeCount() > Integer.MAX_VALUE + 100L * 1024 * 1024) {\n            break;\n          }\n          nextInput(r, ints2);\n        }\n\n        FST<Object> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(NO_OUTPUT, Util.get(fst, input2));\n            nextInput(r, ints2);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Object> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints2, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Object> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            for(int j=10;j<ints2.length;j++) {\n              ints2[j] = r.nextInt(256);\n            }\n            assertEquals(input2, pair.input);\n            assertEquals(NO_OUTPUT, pair.output);\n            upto++;\n            nextInput(r, ints2);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ ByteSequenceOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=bytes\");\n        Outputs<BytesRef> outputs = ByteSequenceOutputs.getSingleton();\n        final FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        byte[] outputBytes = new byte[20];\n        BytesRef output = new BytesRef(outputBytes);\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          r.nextBytes(outputBytes);\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, BytesRef.deepCopyOf(output));\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<BytesRef> fst = fstCompiler.compile();\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          r = new Random(seed);\n          Arrays.fill(ints, 0);\n\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n            r.nextBytes(outputBytes);\n            assertEquals(output, Util.get(fst, input));\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<BytesRef> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<BytesRef> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            r.nextBytes(outputBytes);\n            assertEquals(output, pair.output);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n\n      // Build FST w/ PositiveIntOutputs and stop when FST\n      // size = 3GB\n      {\n        System.out.println(\"\\nTEST: 3 GB size; outputs=long\");\n        Outputs<Long> outputs = PositiveIntOutputs.getSingleton();\n        final FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n        long output = 1;\n\n        Arrays.fill(ints, 0);\n        int count = 0;\n        Random r = new Random(seed);\n        while(true) {\n          //System.out.println(\"add: \" + input + \" -> \" + output);\n          fstCompiler.add(input, output);\n          output += 1+r.nextInt(10);\n          count++;\n          if (count % 10000 == 0) {\n            long size = fstCompiler.fstRamBytesUsed();\n            if (count % 1000000 == 0) {\n              System.out.println(count + \"...: \" + size + \" bytes\");\n            }\n            if (size > LIMIT) {\n              break;\n            }\n          }\n          nextInput(r, ints);\n        }\n\n        FST<Long> fst = fstCompiler.compile();\n\n        for(int verify=0;verify<2;verify++) {\n\n          System.out.println(\"\\nTEST: now verify [fst size=\" + fst.ramBytesUsed() + \"; nodeCount=\" + fstCompiler.getNodeCount() + \"; arcCount=\" + fstCompiler.getArcCount() + \"]\");\n\n          Arrays.fill(ints, 0);\n\n          output = 1;\n          r = new Random(seed);\n          for(int i=0;i<count;i++) {\n            if (i % 1000000 == 0) {\n              System.out.println(i + \"...: \");\n            }\n\n            // forward lookup:\n            assertEquals(output, Util.get(fst, input).longValue());\n            // reverse lookup:\n            @SuppressWarnings(\"deprecation\")\n            IntsRef inputResult = Util.getByOutput(fst, output);\n            assertEquals(input, inputResult);\n            output += 1 + r.nextInt(10);\n            nextInput(r, ints);\n          }\n\n          System.out.println(\"\\nTEST: enum all input/outputs\");\n          IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n\n          Arrays.fill(ints, 0);\n          r = new Random(seed);\n          int upto = 0;\n          output = 1;\n          while(true) {\n            IntsRefFSTEnum.InputOutput<Long> pair = fstEnum.next();\n            if (pair == null) {\n              break;\n            }\n            assertEquals(input, pair.input);\n            assertEquals(output, pair.output.longValue());\n            output += 1 + r.nextInt(10);\n            upto++;\n            nextInput(r, ints);\n          }\n          assertEquals(count, upto);\n\n          if (verify == 0) {\n            System.out.println(\"\\nTEST: save/load FST and re-verify\");\n            IndexOutput out = dir.createOutput(\"fst\", IOContext.DEFAULT);\n            fst.save(out);\n            out.close();\n            IndexInput in = dir.openInput(\"fst\", IOContext.DEFAULT);\n            fst = new FST<>(in, outputs);\n            in.close();\n          } else {\n            dir.deleteFile(\"fst\");\n          }\n        }\n      }\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["f838187609fee3a1afa5f162f93c796046242c84"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["bb9c3baacabd473e8ecd6c4948aabacead49b88e","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"336a0bd816238e31c31e191e1b046e974f7ae5fe":["6244579a467d5f2673ac98265d74bddbea1a8114"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["59a1204a92958bea883656169000a87a6c55c2d0"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5"],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["336a0bd816238e31c31e191e1b046e974f7ae5fe"],"d0d579490a72f2e6297eaa648940611234c57cf1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f838187609fee3a1afa5f162f93c796046242c84":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["199dfa410f1fdbfd3294106b04096cce5ed34b21","336a0bd816238e31c31e191e1b046e974f7ae5fe"],"59a1204a92958bea883656169000a87a6c55c2d0":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":["8917bfede3b4ca30f4305c1e391e9218959cd723","651a27b35167c2ea81f87f4749722e52b7d5b750"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["199dfa410f1fdbfd3294106b04096cce5ed34b21","6bfe104fc023fadc9e709f8d17403d2cc61133fe","6244579a467d5f2673ac98265d74bddbea1a8114"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["f838187609fee3a1afa5f162f93c796046242c84"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8917bfede3b4ca30f4305c1e391e9218959cd723","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["99f06f5dd087b1829e7b4139e4d014c786b92572"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"336a0bd816238e31c31e191e1b046e974f7ae5fe":["ae67e1f82a53594208ca929f382ee861dad3d7a8","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","651a27b35167c2ea81f87f4749722e52b7d5b750"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","336a0bd816238e31c31e191e1b046e974f7ae5fe"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["59a1204a92958bea883656169000a87a6c55c2d0"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"f838187609fee3a1afa5f162f93c796046242c84":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"59a1204a92958bea883656169000a87a6c55c2d0":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["6613659748fe4411a7dcf85266e55db1f95f7315"],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":[],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","f03e4bed5023ec3ef93a771b8888cae991cf448d","b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}