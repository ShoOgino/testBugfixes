{"path":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0883328ff2cc09b5c999d05c04e16530d819c627","date":1285860918,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/QueryParsing#parseSort(String,IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns null if the sortSpec is the standard sort desc.\n   * <p/>\n   * <p>\n   * The form of the sort specification string currently parsed is:\n   * </p>\n   * <pre>>\n   * SortSpec ::= SingleSort [, SingleSort]*\n   * SingleSort ::= <fieldname> SortDirection\n   * SortDirection ::= top | desc | bottom | asc\n   * </pre>\n   * Examples:\n   * <pre>\n   *   score desc               #normal sort by score (will return null)\n   *   weight bottom            #sort by weight ascending\n   *   weight desc              #sort by weight descending\n   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\n   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\n   * </pre>\n   */\n  public static Sort parseSort(String sortSpec, IndexSchema schema) {\n    if (sortSpec == null || sortSpec.length() == 0) return null;\n    char[] chars = sortSpec.toCharArray();\n    int i = 0;\n    StringBuilder buffer = new StringBuilder(sortSpec.length());\n    String sort = null;\n    String order = null;\n    int functionDepth = 0;\n    boolean score = true;\n    List<SortField> lst = new ArrayList<SortField>(5);\n    boolean needOrder = false;\n    while (i < chars.length) {\n      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {\n        if (buffer.length() == 0) {\n          //do nothing\n        } else {\n          if (needOrder == false) {\n            sort = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = true;\n          } else {\n            order = buffer.toString().trim();\n            buffer.setLength(0);\n            needOrder = false;\n          }\n        }\n      } else if (chars[i] == '(' && functionDepth >= 0) {\n        buffer.append(chars[i]);\n        functionDepth++;\n      } else if (chars[i] == ')' && functionDepth > 0) {\n        buffer.append(chars[i]);\n        functionDepth--;//close up one layer\n      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function\n        //we have a separator between sort declarations,\n        // We may need an order still, but then evaluate it, as we should have everything we need\n        if (needOrder == true && buffer.length() > 0){\n          order = buffer.toString().trim();\n          buffer.setLength(0);\n          needOrder = false;\n        }\n        score = processSort(schema, sort, order, lst);\n        sort = null;\n        order = null;\n        buffer.setLength(0);//get ready for the next one, if there is one\n      } else if (chars[i] == ',' && functionDepth > 0) {\n        //we are in a function\n        buffer.append(chars[i]);\n      } else {\n        //just a regular old char, add it to the buffer\n        buffer.append(chars[i]);\n      }\n      i++;\n    }\n    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order\n      order = buffer.toString().trim();\n      buffer.setLength(0);\n      needOrder = false;\n    }\n\n    //do some sanity checks\n    if (functionDepth != 0){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec, mismatched parentheses: \" + sortSpec);\n    }\n    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse sort spec: \" + sortSpec);\n    }\n    if (needOrder == false && sort != null && sort.equals(\"\") == false && order != null && order.equals(\"\") == false){//handle the last declaration\n      score = processSort(schema, sort, order, lst);\n    }\n    //If the normal case (by score desc) do nothing\n    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {\n      return null; // do normal scoring...\n    }\n    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0883328ff2cc09b5c999d05c04e16530d819c627":["1da8d55113b689b06716246649de6f62430f15c0"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","0883328ff2cc09b5c999d05c04e16530d819c627"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0883328ff2cc09b5c999d05c04e16530d819c627"]},"commit2Childs":{"0883328ff2cc09b5c999d05c04e16530d819c627":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1da8d55113b689b06716246649de6f62430f15c0":["0883328ff2cc09b5c999d05c04e16530d819c627","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}