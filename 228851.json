{"path":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f49143da0a5d278a72f741432047fcfa6da996e","date":1316927425,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76fa9933adb0556e752e8af9734c4d0ae14622ff","date":1339178321,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc555744b1a581a4beccd0b75f8d3fe49735a2f","date":1367588265,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"804b857d1066ab5185b3b9101bde41b0b71426ec","date":1435846169,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","date":1501254464,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final BytesRef rawBytes;\n      if (token.hasAttribute(BytesTermAttribute.class)) {\n        final BytesTermAttribute bytesAtt = token.getAttribute(BytesTermAttribute.class);\n        rawBytes = bytesAtt.getBytesRef(); \n      } else {\n        final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n        rawBytes = termAtt.getBytesRef();\n      }\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":["b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final BytesRef rawBytes;\n      if (token.hasAttribute(BytesTermAttribute.class)) {\n        final BytesTermAttribute bytesAtt = token.getAttribute(BytesTermAttribute.class);\n        rawBytes = bytesAtt.getBytesRef(); \n      } else {\n        final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n        rawBytes = termAtt.getBytesRef();\n      }\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  @SuppressWarnings({\"rawtypes\"})\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final BytesRef rawBytes;\n      if (token.hasAttribute(BytesTermAttribute.class)) {\n        final BytesTermAttribute bytesAtt = token.getAttribute(BytesTermAttribute.class);\n        rawBytes = bytesAtt.getBytesRef(); \n      } else {\n        final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n        rawBytes = termAtt.getBytesRef();\n      }\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokenList  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absolute position\n    ArrayUtil.timSort(tokens, new Comparator<AttributeSource>() {\n      @Override\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<>();\n      final BytesRef rawBytes;\n      if (token.hasAttribute(BytesTermAttribute.class)) {\n        final BytesTermAttribute bytesAtt = token.getAttribute(BytesTermAttribute.class);\n        rawBytes = bytesAtt.getBytesRef(); \n      } else {\n        final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n        rawBytes = termAtt.getBytesRef();\n      }\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRefBuilder()).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        @Override\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof BytesRef) {\n            final BytesRef p = (BytesRef) value;\n            value = p.toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"804b857d1066ab5185b3b9101bde41b0b71426ec":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["76fa9933adb0556e752e8af9734c4d0ae14622ff","7530de27b87b961b51f01bd1299b7004d46e8823"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["804b857d1066ab5185b3b9101bde41b0b71426ec","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["804b857d1066ab5185b3b9101bde41b0b71426ec","0158ced21948b6626f733c1c42c1e18d94449789"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["d470c8182e92b264680e34081b75e70a9f2b3c89","fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["7530de27b87b961b51f01bd1299b7004d46e8823"],"2f49143da0a5d278a72f741432047fcfa6da996e":["c26f00b574427b55127e869b935845554afde1fa"],"76fa9933adb0556e752e8af9734c4d0ae14622ff":["2f49143da0a5d278a72f741432047fcfa6da996e"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["76fa9933adb0556e752e8af9734c4d0ae14622ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"0158ced21948b6626f733c1c42c1e18d94449789":["804b857d1066ab5185b3b9101bde41b0b71426ec"]},"commit2Childs":{"804b857d1066ab5185b3b9101bde41b0b71426ec":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"c26f00b574427b55127e869b935845554afde1fa":["2f49143da0a5d278a72f741432047fcfa6da996e"],"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["804b857d1066ab5185b3b9101bde41b0b71426ec"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2f49143da0a5d278a72f741432047fcfa6da996e":["76fa9933adb0556e752e8af9734c4d0ae14622ff"],"76fa9933adb0556e752e8af9734c4d0ae14622ff":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}