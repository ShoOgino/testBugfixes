{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"init child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = isPrimary ? TestNRTReplication.DO_CRASH_PRIMARY : TestNRTReplication.DO_CRASH_REPLICA;\n    boolean doRandomClose = isPrimary ? false : TestNRTReplication.DO_CLOSE_REPLICA;\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0)) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"init child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0)) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"init child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = isPrimary ? TestNRTReplication.DO_CRASH_PRIMARY : TestNRTReplication.DO_CRASH_REPLICA;\n    boolean doRandomClose = isPrimary ? false : TestNRTReplication.DO_CLOSE_REPLICA;\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0)) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"init child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0)) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38cf1409ac117286eb0df7d6ef31d9cfdad8cfec","date":1454767455,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n    boolean doCheckIndexOnClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.checkonclose\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy, doCheckIndexOnClose);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null, doCheckIndexOnClose);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n    boolean doCheckIndexOnClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.checkonclose\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy, doCheckIndexOnClose);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null, doCheckIndexOnClose);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleServer#test().mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n    boolean doCheckIndexOnClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.checkonclose\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy, doCheckIndexOnClose);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null, doCheckIndexOnClose);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    int id = Integer.parseInt(System.getProperty(\"tests.nrtreplication.nodeid\"));\n    Thread.currentThread().setName(\"main child \" + id);\n    Path indexPath = Paths.get(System.getProperty(\"tests.nrtreplication.indexpath\"));\n    boolean isPrimary = System.getProperty(\"tests.nrtreplication.isPrimary\") != null;\n    int primaryTCPPort;\n    long forcePrimaryVersion;\n    if (isPrimary == false) {\n      forcePrimaryVersion = -1;\n      primaryTCPPort = Integer.parseInt(System.getProperty(\"tests.nrtreplication.primaryTCPPort\"));\n    } else {\n      primaryTCPPort = -1;\n      forcePrimaryVersion = Long.parseLong(System.getProperty(\"tests.nrtreplication.forcePrimaryVersion\"));\n    }\n    long primaryGen = Long.parseLong(System.getProperty(\"tests.nrtreplication.primaryGen\"));\n    Node.globalStartNS = Long.parseLong(System.getProperty(\"tests.nrtreplication.startNS\"));\n\n    boolean doRandomCrash = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomCrash\"));\n    boolean doRandomClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.doRandomClose\"));\n    boolean doFlipBitsDuringCopy = \"true\".equals(System.getProperty(\"tests.nrtreplication.doFlipBitsDuringCopy\"));\n    boolean doCheckIndexOnClose = \"true\".equals(System.getProperty(\"tests.nrtreplication.checkonclose\"));\n\n    // Create server socket that we listen for incoming requests on:\n    try (final ServerSocket ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress())) {\n\n      int tcpPort = ((InetSocketAddress) ss.getLocalSocketAddress()).getPort();\n      System.out.println(\"\\nPORT: \" + tcpPort);\n      final Node node;\n      if (isPrimary) {\n        node = new SimplePrimaryNode(random(), indexPath, id, tcpPort, primaryGen, forcePrimaryVersion, null, doFlipBitsDuringCopy, doCheckIndexOnClose);\n        System.out.println(\"\\nCOMMIT VERSION: \" + ((PrimaryNode) node).getLastCommitVersion());\n      } else {\n        try {\n          node = new SimpleReplicaNode(random(), id, tcpPort, indexPath, primaryGen, primaryTCPPort, null, doCheckIndexOnClose);\n        } catch (RuntimeException re) {\n          if (re.getMessage().startsWith(\"replica cannot start\")) {\n            // this is \"OK\": it means MDW's refusal to delete a segments_N commit point means we cannot start:\n            assumeTrue(re.getMessage(), false);\n          }\n          throw re;\n        }\n      }\n      System.out.println(\"\\nINFOS VERSION: \" + node.getCurrentSearchingVersion());\n\n      if (doRandomClose || doRandomCrash) {\n        final int waitForMS;\n        if (isPrimary) {\n          waitForMS = TestUtil.nextInt(random(), 20000, 60000);\n        } else {\n          waitForMS = TestUtil.nextInt(random(), 5000, 60000);\n        }\n\n        boolean doClose;\n        if (doRandomCrash == false) {\n          doClose = true;\n        } else if (doRandomClose) {\n          doClose = random().nextBoolean();\n        } else {\n          doClose = false;\n        }\n\n        if (doClose) {\n          node.message(\"top: will close after \" + (waitForMS/1000.0) + \" seconds\");\n        } else {\n          node.message(\"top: will crash after \" + (waitForMS/1000.0) + \" seconds\");\n        }\n\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n              long endTime = System.nanoTime() + waitForMS*1000000L;\n              while (System.nanoTime() < endTime) {\n                try {\n                  Thread.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                if (stop.get()) {\n                  break;\n                }\n              }\n\n              if (stop.get() == false) {\n                if (doClose) {\n                  try {\n                    node.message(\"top: now force close server socket after \" + (waitForMS/1000.0) + \" seconds\");\n                    node.state = \"top-closing\";\n                    ss.close();\n                  } catch (IOException ioe) {     \n                    throw new RuntimeException(ioe);\n                  }\n                } else {        \n                  node.message(\"top: now crash JVM after \" + (waitForMS/1000.0) + \" seconds\");\n                  crashJRE();\n                }\n              }\n            }\n          };\n\n        if (isPrimary) {\n          t.setName(\"crasher P\" + id);\n        } else {\n          t.setName(\"crasher R\" + id);\n        }\n\n        // So that if node exits naturally, this thread won't prevent process exit:\n        t.setDaemon(true);\n        t.start();\n      }\n      System.out.println(\"\\nNODE STARTED\");\n\n      //List<Thread> clientThreads = new ArrayList<>();\n\n      // Naive thread-per-connection server:\n      while (true) {\n        Socket socket;\n        try {\n          socket = ss.accept();\n        } catch (SocketException se) {\n          // when ClientHandler closes our ss we will hit this\n          node.message(\"top: server socket exc; now exit\");\n          break;\n        }\n        Thread thread = new ClientHandler(ss, node, socket);\n        thread.setDaemon(true);\n        thread.start();\n\n        clientThreads.add(thread);\n\n        // Prune finished client threads:\n        Iterator<Thread> it = clientThreads.iterator();\n        while (it.hasNext()) {\n          Thread t = it.next();\n          if (t.isAlive() == false) {\n            it.remove();\n          }\n        }\n        //node.message(clientThreads.size() + \" client threads are still alive\");\n      }\n\n      stop.set(true);\n\n      // Make sure all client threads are done, else we get annoying (yet ultimately \"harmless\") messages about threads still running /\n      // lingering for them to finish from the child processes:\n      for(Thread clientThread : clientThreads) {\n        node.message(\"top: join clientThread=\" + clientThread);\n        clientThread.join();\n        node.message(\"top: done join clientThread=\" + clientThread);\n      }\n      node.message(\"done join all client threads; now close node\");\n      node.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","38cf1409ac117286eb0df7d6ef31d9cfdad8cfec"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["68496c2200e559fb7802f7575427b7a482659afb"],"38cf1409ac117286eb0df7d6ef31d9cfdad8cfec":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["38cf1409ac117286eb0df7d6ef31d9cfdad8cfec"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"38cf1409ac117286eb0df7d6ef31d9cfdad8cfec":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}