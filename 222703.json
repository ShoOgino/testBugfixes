{"path":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#checkFetchSources(SolrReturnFields.FIELD_SOURCES).mjava","commits":[{"id":"96ecd141e96e7a7a65822d7fada5ddc585b21149","date":1534786652,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#checkFetchSources(SolrReturnFields.FIELD_SOURCES).mjava","pathOld":"/dev/null","sourceNew":"  private void checkFetchSources(SolrReturnFields.FIELD_SOURCES source) throws Exception {\n    String flAll = fieldsHolder.allFields.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    List<RetrieveField> toCheck = new ArrayList<>();\n    String idField = idNotStoredDv + \",\";\n    switch (source) {\n      case ALL_FROM_DV:\n        toCheck = new ArrayList(fieldsHolder.dvNotStoredFields);\n        break;\n      case ALL_FROM_STORED:\n        idField = idStoredNotDv + \",\";\n        toCheck = new ArrayList(fieldsHolder.storedNotDvFields);\n        break;\n      case MIXED_SOURCES:\n        toCheck = new ArrayList(fieldsHolder.allFields);\n        break;\n      default:\n        fail(\"Value passed to checkFetchSources unknown: \" + source.toString());\n    }\n\n    // MultiValued fields are _always_ read from stored data.\n    toCheck.removeAll(fieldsHolder.multiValuedFields);\n\n    // At this point, toCheck should be only singleValued fields. Adding in even a single multiValued field should\n    // read stuff from stored.\n    String fl = idField + toCheck.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    // Even a single multiValued and stored field should cause stored fields to be visited.\n\n    List<Integer> shuffled = Arrays.asList(0, 1, 2);\n    Collections.shuffle(shuffled, random());\n    for (int which : shuffled) {\n      switch (which) {\n        case 0:\n          check(fl, source);\n          break;\n\n        case 1:\n          check(flAll, MIXED_SOURCES);\n          break;\n\n        case 2:\n          List<RetrieveField> toCheckPlusMv = new ArrayList<>(toCheck);\n          toCheckPlusMv.add(fieldsHolder.storedMvFields.get(random().nextInt(fieldsHolder.storedMvFields.size())));\n\n          String flWithMv = idField + toCheckPlusMv.stream()\n              .map(RetrieveField::getName) // This will call testField.getName()\n              .collect(Collectors.joining(\",\"));\n          if (source == ALL_FROM_STORED) {\n            check(flWithMv, ALL_FROM_STORED);\n          } else {\n            check(flWithMv, MIXED_SOURCES);\n          }\n          break;\n        default:\n          fail(\"Your shuffling should be between 0 and 2, inclusive. It was: \" + which);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#checkFetchSources(SolrReturnFields.FIELD_SOURCES).mjava","pathOld":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#checkFetchSources(SolrReturnFields.FIELD_SOURCES).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private void checkFetchSources(SolrReturnFields.FIELD_SOURCES source) throws Exception {\n    String flAll = fieldsHolder.allFields.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    List<RetrieveField> toCheck = new ArrayList<>();\n    String idField = idNotStoredDv + \",\";\n    switch (source) {\n      case ALL_FROM_DV:\n        toCheck = new ArrayList(fieldsHolder.dvNotStoredFields);\n        break;\n      case ALL_FROM_STORED:\n        idField = idStoredNotDv + \",\";\n        toCheck = new ArrayList(fieldsHolder.storedNotDvFields);\n        break;\n      case MIXED_SOURCES:\n        toCheck = new ArrayList(fieldsHolder.allFields);\n        break;\n      default:\n        fail(\"Value passed to checkFetchSources unknown: \" + source.toString());\n    }\n\n    // MultiValued fields are _always_ read from stored data.\n    toCheck.removeAll(fieldsHolder.multiValuedFields);\n\n    // At this point, toCheck should be only singleValued fields. Adding in even a single multiValued field should\n    // read stuff from stored.\n    String fl = idField + toCheck.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    // Even a single multiValued and stored field should cause stored fields to be visited.\n\n    List<Integer> shuffled = Arrays.asList(0, 1, 2);\n    Collections.shuffle(shuffled, random());\n    for (int which : shuffled) {\n      switch (which) {\n        case 0:\n          check(fl, source);\n          break;\n\n        case 1:\n          check(flAll, MIXED_SOURCES);\n          break;\n\n        case 2:\n          List<RetrieveField> toCheckPlusMv = new ArrayList<>(toCheck);\n          toCheckPlusMv.add(fieldsHolder.storedMvFields.get(random().nextInt(fieldsHolder.storedMvFields.size())));\n\n          String flWithMv = idField + toCheckPlusMv.stream()\n              .map(RetrieveField::getName) // This will call testField.getName()\n              .collect(Collectors.joining(\",\"));\n          if (source == ALL_FROM_STORED) {\n            check(flWithMv, ALL_FROM_STORED);\n          } else {\n            check(flWithMv, MIXED_SOURCES);\n          }\n          break;\n        default:\n          fail(\"Your shuffling should be between 0 and 2, inclusive. It was: \" + which);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkFetchSources(SolrReturnFields.FIELD_SOURCES source) throws Exception {\n    String flAll = fieldsHolder.allFields.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    List<RetrieveField> toCheck = new ArrayList<>();\n    String idField = idNotStoredDv + \",\";\n    switch (source) {\n      case ALL_FROM_DV:\n        toCheck = new ArrayList(fieldsHolder.dvNotStoredFields);\n        break;\n      case ALL_FROM_STORED:\n        idField = idStoredNotDv + \",\";\n        toCheck = new ArrayList(fieldsHolder.storedNotDvFields);\n        break;\n      case MIXED_SOURCES:\n        toCheck = new ArrayList(fieldsHolder.allFields);\n        break;\n      default:\n        fail(\"Value passed to checkFetchSources unknown: \" + source.toString());\n    }\n\n    // MultiValued fields are _always_ read from stored data.\n    toCheck.removeAll(fieldsHolder.multiValuedFields);\n\n    // At this point, toCheck should be only singleValued fields. Adding in even a single multiValued field should\n    // read stuff from stored.\n    String fl = idField + toCheck.stream()\n        .map(RetrieveField::getName) // This will call testField.getName()\n        .collect(Collectors.joining(\",\"));\n\n    // Even a single multiValued and stored field should cause stored fields to be visited.\n\n    List<Integer> shuffled = Arrays.asList(0, 1, 2);\n    Collections.shuffle(shuffled, random());\n    for (int which : shuffled) {\n      switch (which) {\n        case 0:\n          check(fl, source);\n          break;\n\n        case 1:\n          check(flAll, MIXED_SOURCES);\n          break;\n\n        case 2:\n          List<RetrieveField> toCheckPlusMv = new ArrayList<>(toCheck);\n          toCheckPlusMv.add(fieldsHolder.storedMvFields.get(random().nextInt(fieldsHolder.storedMvFields.size())));\n\n          String flWithMv = idField + toCheckPlusMv.stream()\n              .map(RetrieveField::getName) // This will call testField.getName()\n              .collect(Collectors.joining(\",\"));\n          if (source == ALL_FROM_STORED) {\n            check(flWithMv, ALL_FROM_STORED);\n          } else {\n            check(flWithMv, MIXED_SOURCES);\n          }\n          break;\n        default:\n          fail(\"Your shuffling should be between 0 and 2, inclusive. It was: \" + which);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["96ecd141e96e7a7a65822d7fada5ddc585b21149"]},"commit2Childs":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}