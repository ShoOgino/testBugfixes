{"path":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"/dev/null","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.getDocCount() != oldReader.getSegmentInfo().info.getDocCount();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f412711b73fe38b28bb793928ad02da8c829cff5","f412711b73fe38b28bb793928ad02da8c829cff5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.getDocCount() != oldReader.getSegmentInfo().info.getDocCount();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":["f412711b73fe38b28bb793928ad02da8c829cff5","f412711b73fe38b28bb793928ad02da8c829cff5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.getDocCount() != oldReader.getSegmentInfo().info.getDocCount();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.getDocCount() != oldReader.getSegmentInfo().info.getDocCount();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a4e9a587014c4251898aed4d040c93922cc06bf","date":1446808581,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = new HashMap<>();\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)} */\n  private static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f412711b73fe38b28bb793928ad02da8c829cff5","date":1465765014,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b0267c69e2456a3477a1ad785723f2135da3117e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    \n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n              && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n            // No change; this reader will be shared between\n            // the old and the new one, so we must incRef\n            // it:\n            oldReader.incRef();\n            newReaders[i] = oldReader;\n          } else {\n            // Steal the ref returned by SegmentReader ctor:\n            assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n            // Make a best effort to detect when the app illegally \"rm -rf\" their\n            // index while a reader was open, and then called openIfChanged:\n            boolean illegalDocCountChange = commitInfo.info.maxDoc() != oldReader.getSegmentInfo().info.maxDoc();\n            \n            boolean hasNeitherDeletionsNorUpdates = commitInfo.hasDeletions()== false && commitInfo.hasFieldUpdates() == false;\n\n            boolean deletesWereLost = commitInfo.getDelGen() == -1 && oldReader.getSegmentInfo().getDelGen() != -1;\n\n            if (illegalDocCountChange || hasNeitherDeletionsNorUpdates || deletesWereLost) {\n              throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid changes; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or OpenMode.CREATE instead\");\n            }\n\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n              // only DV updates\n              newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n            } else {\n              // both DV and liveDocs have changed\n              newReaders[i] = new SegmentReader(commitInfo, oldReader);\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb0130363fa13c53e4e78317c35b3b45a3089276","date":1523267438,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs());\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"578a4d73d90ecd838846cc32bf1098aaa262b524","date":1532504076,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            newReaders[i] = new SegmentReader(commitInfo, oldReader);\n          } else {\n            \n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                newReaders[i] = new SegmentReader(commitInfo, oldReader);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790693f23f4e88a59fbb25e47cc25f6d493b03cb","date":1553077690,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader],Map[String,String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders, Map<String, String> readerAttributes) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ, readerAttributes);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false, readerAttributes);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader],Map[String,String]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders, Map<String, String> readerAttributes) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ, readerAttributes);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false, readerAttributes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec68e7c41fed133827595747d853cad504e481e","date":1583501052,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["578a4d73d90ecd838846cc32bf1098aaa262b524"],"6a4e9a587014c4251898aed4d040c93922cc06bf":["b0267c69e2456a3477a1ad785723f2135da3117e"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"b0267c69e2456a3477a1ad785723f2135da3117e":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"bec68e7c41fed133827595747d853cad504e481e":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"578a4d73d90ecd838846cc32bf1098aaa262b524":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","f412711b73fe38b28bb793928ad02da8c829cff5"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["f412711b73fe38b28bb793928ad02da8c829cff5"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["31741cf1390044e38a2ec3127cf302ba841bfd75","cb0130363fa13c53e4e78317c35b3b45a3089276"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b0267c69e2456a3477a1ad785723f2135da3117e"],"b06445ae1731e049327712db0454e5643ca9b7fe":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cb0130363fa13c53e4e78317c35b3b45a3089276":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"68496c2200e559fb7802f7575427b7a482659afb":["6a4e9a587014c4251898aed4d040c93922cc06bf","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"f412711b73fe38b28bb793928ad02da8c829cff5":["68496c2200e559fb7802f7575427b7a482659afb"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["f412711b73fe38b28bb793928ad02da8c829cff5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bec68e7c41fed133827595747d853cad504e481e"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["6a4e9a587014c4251898aed4d040c93922cc06bf"]},"commit2Childs":{"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"6a4e9a587014c4251898aed4d040c93922cc06bf":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"b0267c69e2456a3477a1ad785723f2135da3117e":["6a4e9a587014c4251898aed4d040c93922cc06bf","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"bec68e7c41fed133827595747d853cad504e481e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"578a4d73d90ecd838846cc32bf1098aaa262b524":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["bec68e7c41fed133827595747d853cad504e481e"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d58e44159788900f4a2113b84463dc3fbbf80f20","cb0130363fa13c53e4e78317c35b3b45a3089276"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["578a4d73d90ecd838846cc32bf1098aaa262b524"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cb0130363fa13c53e4e78317c35b3b45a3089276":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"68496c2200e559fb7802f7575427b7a482659afb":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f412711b73fe38b28bb793928ad02da8c829cff5"],"f412711b73fe38b28bb793928ad02da8c829cff5":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","92212fd254551a0b1156aafc3a1a6ed1a43932ad","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}