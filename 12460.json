{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open().mjava","commits":[{"id":"261bc548c130304500988d5439455607f5cc79be","date":1587485357,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open() throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n\n    // true if the InputStream is not already randomly seek'd after the if/else block below:\n    boolean needSkip;\n    boolean skipFirstLineFragment = false;\n    \n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Jenkins' home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and seek to one of the pre-computed skip points:\n        is = Files.newInputStream(file);\n        needSkip = true;\n      } else {\n        // file is not compressed: optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n\n        // we (likely) seeked to the middle of a line:\n        skipFirstLineFragment = true;\n\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n      needSkip = true;\n    }\n\n    if (needSkip) {\n\n      // LUCENE-9191: use the optimized (pre-computed, using dev-tools/scripts/create_line_file_docs.py)\n      // seek file, so we can seek in a gzip'd file\n\n      int index = path.lastIndexOf('.');\n      if (index == -1) {\n        throw new IllegalArgumentException(\"could not determine extension for path \\\"\" + path + \"\\\"\");\n      }\n\n      // e.g. foo.txt --> foo.seek, foo.txt.gz --> foo.txt.seek\n      String seekFilePath = path.substring(0, index) + \".seek\";\n      InputStream seekIS = getClass().getResourceAsStream(seekFilePath);\n      if (seekIS == null) {\n        seekIS = Files.newInputStream(Paths.get(seekFilePath));\n      }\n\n      try (BufferedReader reader = new BufferedReader(new InputStreamReader(seekIS,\n                                                                    StandardCharsets.UTF_8))) {\n        List<Long> skipPoints = new ArrayList<>();\n\n        // explicitly insert implicit 0 as the first skip point:\n        skipPoints.add(0L);\n        \n        while (true) {\n          String line = reader.readLine();\n          if (line == null) {\n            break;\n          }\n          skipPoints.add(Long.parseLong(line.trim()));\n        }\n\n        seekTo = skipPoints.get(random.nextInt(skipPoints.size()));\n\n        // dev-tools/scripts/create_line_file_docs.py ensures this is a \"safe\" skip point, and we\n        // can begin gunziping from here:\n        is.skip(seekTo);\n        is = new GZIPInputStream(is);\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n        }\n      }\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (skipFirstLineFragment) {\n      // read until end of line:\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = Files.newInputStream(file);\n      } else {\n        // optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d97fd683c84bc341a983d91b11ceccc2789694b1","date":1588613340,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open().mjava","sourceNew":"  private synchronized void open() throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n\n    // true if the InputStream is not already randomly seek'd after the if/else block below:\n    boolean needSkip;\n    \n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Jenkins' home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and seek to one of the pre-computed skip points:\n        is = Files.newInputStream(file);\n        needSkip = true;\n      } else {\n        // file is not compressed: optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n\n        // read until newline char, otherwise we may hit \"java.nio.charset.MalformedInputException: Input length = 1\"\n        // exception in readline() below, because we seeked part way through a multi-byte (in UTF-8) encoded\n        // unicode character:\n        if (seekTo > 0L) {\n          int b;\n          do {\n            b = is.read();\n          } while (b >= 0 && b != 13 && b != 10);\n        }\n\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n      needSkip = true;\n    }\n\n    if (needSkip) {\n\n      // LUCENE-9191: use the optimized (pre-computed, using dev-tools/scripts/create_line_file_docs.py)\n      // seek file, so we can seek in a gzip'd file\n\n      int index = path.lastIndexOf('.');\n      if (index == -1) {\n        throw new IllegalArgumentException(\"could not determine extension for path \\\"\" + path + \"\\\"\");\n      }\n\n      // e.g. foo.txt --> foo.seek, foo.txt.gz --> foo.txt.seek\n      String seekFilePath = path.substring(0, index) + \".seek\";\n      InputStream seekIS = getClass().getResourceAsStream(seekFilePath);\n      if (seekIS == null) {\n        seekIS = Files.newInputStream(Paths.get(seekFilePath));\n      }\n\n      try (BufferedReader reader = new BufferedReader(new InputStreamReader(seekIS,\n                                                                    StandardCharsets.UTF_8))) {\n        List<Long> skipPoints = new ArrayList<>();\n\n        // explicitly insert implicit 0 as the first skip point:\n        skipPoints.add(0L);\n        \n        while (true) {\n          String line = reader.readLine();\n          if (line == null) {\n            break;\n          }\n          skipPoints.add(Long.parseLong(line.trim()));\n        }\n\n        seekTo = skipPoints.get(random.nextInt(skipPoints.size()));\n\n        // dev-tools/scripts/create_line_file_docs.py ensures this is a \"safe\" skip point, and we\n        // can begin gunziping from here:\n        is.skip(seekTo);\n        is = new GZIPInputStream(is);\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n        }\n      }\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n  }\n\n","sourceOld":"  private synchronized void open() throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n\n    // true if the InputStream is not already randomly seek'd after the if/else block below:\n    boolean needSkip;\n    boolean skipFirstLineFragment = false;\n    \n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Jenkins' home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and seek to one of the pre-computed skip points:\n        is = Files.newInputStream(file);\n        needSkip = true;\n      } else {\n        // file is not compressed: optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n\n        // we (likely) seeked to the middle of a line:\n        skipFirstLineFragment = true;\n\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n      needSkip = true;\n    }\n\n    if (needSkip) {\n\n      // LUCENE-9191: use the optimized (pre-computed, using dev-tools/scripts/create_line_file_docs.py)\n      // seek file, so we can seek in a gzip'd file\n\n      int index = path.lastIndexOf('.');\n      if (index == -1) {\n        throw new IllegalArgumentException(\"could not determine extension for path \\\"\" + path + \"\\\"\");\n      }\n\n      // e.g. foo.txt --> foo.seek, foo.txt.gz --> foo.txt.seek\n      String seekFilePath = path.substring(0, index) + \".seek\";\n      InputStream seekIS = getClass().getResourceAsStream(seekFilePath);\n      if (seekIS == null) {\n        seekIS = Files.newInputStream(Paths.get(seekFilePath));\n      }\n\n      try (BufferedReader reader = new BufferedReader(new InputStreamReader(seekIS,\n                                                                    StandardCharsets.UTF_8))) {\n        List<Long> skipPoints = new ArrayList<>();\n\n        // explicitly insert implicit 0 as the first skip point:\n        skipPoints.add(0L);\n        \n        while (true) {\n          String line = reader.readLine();\n          if (line == null) {\n            break;\n          }\n          skipPoints.add(Long.parseLong(line.trim()));\n        }\n\n        seekTo = skipPoints.get(random.nextInt(skipPoints.size()));\n\n        // dev-tools/scripts/create_line_file_docs.py ensures this is a \"safe\" skip point, and we\n        // can begin gunziping from here:\n        is.skip(seekTo);\n        is = new GZIPInputStream(is);\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n        }\n      }\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (skipFirstLineFragment) {\n      // read until end of line:\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d97fd683c84bc341a983d91b11ceccc2789694b1":["261bc548c130304500988d5439455607f5cc79be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"261bc548c130304500988d5439455607f5cc79be":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d97fd683c84bc341a983d91b11ceccc2789694b1"]},"commit2Childs":{"d97fd683c84bc341a983d91b11ceccc2789694b1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["261bc548c130304500988d5439455607f5cc79be"],"261bc548c130304500988d5439455607f5cc79be":["d97fd683c84bc341a983d91b11ceccc2789694b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}