{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61edce935cac7901da5d9d90cdd7103cea022781","date":1371106067,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + (System.currentTimeMillis() - start));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["7ab17db13bd6ba87189b198d11a3c8d5836fa96f","e8e3766b37206c683d41cf09b4a544b7b28530d0","bb8548d5b6b919c14a179b607ad0c4f7b3136b17","6a90b0c0d735fb9f6839557571eedd4c370c94bf","4d4f1b2c5601680b01c4bb95a43fe6fb73f03103","8d22c66b0638c82521891318fc352042c5b86e03","14aa57a2d9f13bcc41e8b38c52bd1e55f6390576","dd42c8ecc9f8a8e590c5526544a77258089ca23f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + (System.currentTimeMillis() - start));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0957b9b8725b7ad93845495d2512df18cd240731","date":1482658887,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              LOG.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        if (log.isInfoEnabled()) {\n          log.info(\"Creating a connection for entity {} with URL: {}\"\n              , context.getEntityAttribute(DataImporter.NAME), url);\n        }\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): {}\"\n            , TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        log.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): \"\n            + TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"024e13388acbf5562fcbb77a129620982a5e2d79","date":1591531835,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        if (log.isInfoEnabled()) {\n          log.info(\"Creating a connection for entity {} with URL: {}\"\n              , context.getEntityAttribute(DataImporter.NAME), url);\n        }\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            @SuppressWarnings({\"unchecked\"})\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): {}\"\n            , TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        if (log.isInfoEnabled()) {\n          log.info(\"Creating a connection for entity {} with URL: {}\"\n              , context.getEntityAttribute(DataImporter.NAME), url);\n        }\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): {}\"\n            , TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":null,"sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      @Override\n      public Connection call() throws Exception {\n        if (log.isInfoEnabled()) {\n          log.info(\"Creating a connection for entity {} with URL: {}\"\n              , context.getEntityAttribute(DataImporter.NAME), url);\n        }\n        long start = System.nanoTime();\n        Connection c = null;\n\n        if (jndiName != null) {\n          c = getFromJndi(initProps, jndiName);\n        } else if (url != null) {\n          try {\n            c = DriverManager.getConnection(url, initProps);\n          } catch (SQLException e) {\n            // DriverManager does not allow you to use a driver which is not loaded through\n            // the class loader of the class which is trying to make the connection.\n            // This is a workaround for cases where the user puts the driver jar in the\n            // solr.home/lib or solr.home/core/lib directories.\n            @SuppressWarnings({\"unchecked\"})\n            Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).getConstructor().newInstance();\n            c = d.connect(url, initProps);\n          }\n        }\n        if (c != null) {\n          try {\n            initializeConnection(c, initProps);\n          } catch (SQLException e) {\n            try {\n              c.close();\n            } catch (SQLException e2) {\n              log.warn(\"Exception closing connection during cleanup\", e2);\n            }\n\n            throw new DataImportHandlerException(SEVERE, \"Exception initializing SQL connection\", e);\n          }\n        }\n        log.info(\"Time taken for getConnection(): {}\"\n            , TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));\n        return c;\n      }\n\n      private void initializeConnection(Connection c, final Properties initProps)\n          throws SQLException {\n        if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n          c.setReadOnly(true);\n          // Add other sane defaults\n          c.setAutoCommit(true);\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        }\n        if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n          c.setAutoCommit(false);\n        }\n        String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n        if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n        } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n        } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n        } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n          c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n        }\n        String holdability = initProps.getProperty(\"holdability\");\n        if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n        } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n          c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n        }\n      }\n\n      private Connection getFromJndi(final Properties initProps, final String jndiName) throws NamingException,\n          SQLException {\n\n        Connection c = null;\n        InitialContext ctx =  new InitialContext();\n        Object jndival =  ctx.lookup(jndiName);\n        if (jndival instanceof javax.sql.DataSource) {\n          javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n          String user = (String) initProps.get(\"user\");\n          String pass = (String) initProps.get(\"password\");\n          if(user == null || user.trim().equals(\"\")){\n            c = dataSource.getConnection();\n          } else {\n            c = dataSource.getConnection(user, pass);\n          }\n        } else {\n          throw new DataImportHandlerException(SEVERE,\n                  \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n        }\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c26f00b574427b55127e869b935845554afde1fa","7530de27b87b961b51f01bd1299b7004d46e8823"],"024e13388acbf5562fcbb77a129620982a5e2d79":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"0957b9b8725b7ad93845495d2512df18cd240731":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["61edce935cac7901da5d9d90cdd7103cea022781"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["fd5bc858b8426d40bbe90b94120ead37c77d7954","0957b9b8725b7ad93845495d2512df18cd240731"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["024e13388acbf5562fcbb77a129620982a5e2d79"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"61edce935cac7901da5d9d90cdd7103cea022781":["7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["0957b9b8725b7ad93845495d2512df18cd240731"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"024e13388acbf5562fcbb77a129620982a5e2d79":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"c26f00b574427b55127e869b935845554afde1fa":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["024e13388acbf5562fcbb77a129620982a5e2d79"],"0957b9b8725b7ad93845495d2512df18cd240731":["f03e4bed5023ec3ef93a771b8888cae991cf448d","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["0957b9b8725b7ad93845495d2512df18cd240731","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","61edce935cac7901da5d9d90cdd7103cea022781"],"61edce935cac7901da5d9d90cdd7103cea022781":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f03e4bed5023ec3ef93a771b8888cae991cf448d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}