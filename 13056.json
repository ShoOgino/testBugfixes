{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","commits":[{"id":"ab7d51740456adc459ec788c8fe27746bdc60a55","date":1429185101,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"/dev/null","sourceNew":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fb9dbed1415914caa27460f8abb7afadaa61451","date":1429504289,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n        if (segments.size() > 0) {\n            edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n        } else {\n            edgePoints = new GeoPoint[]{points.get(0).point.getSamplePoint(cutoffOffset,originDistance)};\n        }\n    }\n\n","sourceOld":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aca5c321bc9760dbfc9cefcc9d648e946b4615e","date":1429714020,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n        if (segments.size() > 0) {\n            edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n        }\n        for (int i = 0; i < points.size(); i++) {\n            final SegmentEndpoint pathPoint = points.get(i);\n            Membership previousEndBound = null;\n            GeoPoint[] previousEndNotablePoints = null;\n            Membership nextStartBound = null;\n            GeoPoint[] nextStartNotablePoints = null;\n            if (i > 0) {\n                final PathSegment previousSegment = segments.get(i-1);\n                previousEndBound = previousSegment.invertedEndCutoffPlane;\n                previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n            }\n            if (i < segments.size()) {\n                final PathSegment nextSegment = segments.get(i);\n                nextStartBound = nextSegment.invertedStartCutoffPlane;\n                nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n            }\n            pathPoint.setCutoffPlanes(previousEndNotablePoints,previousEndBound,nextStartNotablePoints,nextStartBound);\n        }\n    }\n\n","sourceOld":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n        if (segments.size() > 0) {\n            edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n        } else {\n            edgePoints = new GeoPoint[]{points.get(0).point.getSamplePoint(cutoffOffset,originDistance)};\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2997acf74723385bd84aff1ea0b12af4aefde77","date":1430745542,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    if (segments.size() > 0) {\n      edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n    }\n    for (int i = 0; i < points.size(); i++) {\n      final SegmentEndpoint pathPoint = points.get(i);\n      Membership previousEndBound = null;\n      GeoPoint[] previousEndNotablePoints = null;\n      Membership nextStartBound = null;\n      GeoPoint[] nextStartNotablePoints = null;\n      if (i > 0) {\n        final PathSegment previousSegment = segments.get(i - 1);\n        previousEndBound = previousSegment.invertedEndCutoffPlane;\n        previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n      }\n      if (i < segments.size()) {\n        final PathSegment nextSegment = segments.get(i);\n        nextStartBound = nextSegment.invertedStartCutoffPlane;\n        nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n      }\n      pathPoint.setCutoffPlanes(previousEndNotablePoints, previousEndBound, nextStartNotablePoints, nextStartBound);\n    }\n  }\n\n","sourceOld":"    public void done() {\n        if (points.size() == 0)\n            throw new IllegalArgumentException(\"Path must have at least one point\");\n        if (segments.size() > 0) {\n            edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n        }\n        for (int i = 0; i < points.size(); i++) {\n            final SegmentEndpoint pathPoint = points.get(i);\n            Membership previousEndBound = null;\n            GeoPoint[] previousEndNotablePoints = null;\n            Membership nextStartBound = null;\n            GeoPoint[] nextStartNotablePoints = null;\n            if (i > 0) {\n                final PathSegment previousSegment = segments.get(i-1);\n                previousEndBound = previousSegment.invertedEndCutoffPlane;\n                previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n            }\n            if (i < segments.size()) {\n                final PathSegment nextSegment = segments.get(i);\n                nextStartBound = nextSegment.invertedStartCutoffPlane;\n                nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n            }\n            pathPoint.setCutoffPlanes(previousEndNotablePoints,previousEndBound,nextStartNotablePoints,nextStartBound);\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c921d81476f94b6686d3f216daa1f6b076b4a6c0","date":1430922284,"type":0,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"/dev/null","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    if (segments.size() > 0) {\n      edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n    }\n    for (int i = 0; i < points.size(); i++) {\n      final SegmentEndpoint pathPoint = points.get(i);\n      Membership previousEndBound = null;\n      GeoPoint[] previousEndNotablePoints = null;\n      Membership nextStartBound = null;\n      GeoPoint[] nextStartNotablePoints = null;\n      if (i > 0) {\n        final PathSegment previousSegment = segments.get(i - 1);\n        previousEndBound = previousSegment.invertedEndCutoffPlane;\n        previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n      }\n      if (i < segments.size()) {\n        final PathSegment nextSegment = segments.get(i);\n        nextStartBound = nextSegment.invertedStartCutoffPlane;\n        nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n      }\n      pathPoint.setCutoffPlanes(previousEndNotablePoints, previousEndBound, nextStartNotablePoints, nextStartBound);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9f97ca977ad649f14b4f60a888adef2edd7a64e","date":1432702490,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      if (prevSegment.upperConnectingPlane.isNumericallyIdentical(currentSegment.upperConnectingPlane) &&\n          prevSegment.lowerConnectingPlane.isNumericallyIdentical(currentSegment.lowerConnectingPlane)) {\n        // The planes are identical.  We don't need a circle at all.  Special constructor...\n        endPoints.add(new SegmentEndpoint(currentSegment.start));\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    if (segments.size() > 0) {\n      edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n    }\n    for (int i = 0; i < points.size(); i++) {\n      final SegmentEndpoint pathPoint = points.get(i);\n      Membership previousEndBound = null;\n      GeoPoint[] previousEndNotablePoints = null;\n      Membership nextStartBound = null;\n      GeoPoint[] nextStartNotablePoints = null;\n      if (i > 0) {\n        final PathSegment previousSegment = segments.get(i - 1);\n        previousEndBound = previousSegment.invertedEndCutoffPlane;\n        previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n      }\n      if (i < segments.size()) {\n        final PathSegment nextSegment = segments.get(i);\n        nextStartBound = nextSegment.invertedStartCutoffPlane;\n        nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n      }\n      pathPoint.setCutoffPlanes(previousEndNotablePoints, previousEndBound, nextStartNotablePoints, nextStartBound);\n    }\n  }\n\n","bugFix":null,"bugIntro":["5a7a2bdf7dc2680bbceb7dde026f9856363e0f25","9908748d960ccb7706a20e81289a656237780b6c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fec06d6753751ae302c7d35866763e6cb414112d","date":1433250698,"type":3,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      if (prevSegment.upperConnectingPlane.isNumericallyIdentical(currentSegment.upperConnectingPlane) &&\n          prevSegment.lowerConnectingPlane.isNumericallyIdentical(currentSegment.lowerConnectingPlane)) {\n        // The planes are identical.  We don't need a circle at all.  Special constructor...\n        endPoints.add(new SegmentEndpoint(currentSegment.start));\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    if (segments.size() > 0) {\n      edgePoints = new GeoPoint[]{points.get(0).circlePlane.getSampleIntersectionPoint(segments.get(0).invertedStartCutoffPlane)};\n    }\n    for (int i = 0; i < points.size(); i++) {\n      final SegmentEndpoint pathPoint = points.get(i);\n      Membership previousEndBound = null;\n      GeoPoint[] previousEndNotablePoints = null;\n      Membership nextStartBound = null;\n      GeoPoint[] nextStartNotablePoints = null;\n      if (i > 0) {\n        final PathSegment previousSegment = segments.get(i - 1);\n        previousEndBound = previousSegment.invertedEndCutoffPlane;\n        previousEndNotablePoints = previousSegment.endCutoffPlanePoints;\n      }\n      if (i < segments.size()) {\n        final PathSegment nextSegment = segments.get(i);\n        nextStartBound = nextSegment.invertedStartCutoffPlane;\n        nextStartNotablePoints = nextSegment.startCutoffPlanePoints;\n      }\n      pathPoint.setCutoffPlanes(previousEndNotablePoints, previousEndBound, nextStartNotablePoints, nextStartBound);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68","date":1433421165,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We don't need a circle at all.  Special constructor...\n        endPoints.add(new SegmentEndpoint(currentSegment.start));\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      if (prevSegment.upperConnectingPlane.isNumericallyIdentical(currentSegment.upperConnectingPlane) &&\n          prevSegment.lowerConnectingPlane.isNumericallyIdentical(currentSegment.lowerConnectingPlane)) {\n        // The planes are identical.  We don't need a circle at all.  Special constructor...\n        endPoints.add(new SegmentEndpoint(currentSegment.start));\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":["16ea2fdbebde471a600f8884a86a2ac728ead27f","16ea2fdbebde471a600f8884a86a2ac728ead27f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a7a2bdf7dc2680bbceb7dde026f9856363e0f25","date":1433873284,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We don't need a circle at all.  Special constructor...\n        endPoints.add(new SegmentEndpoint(currentSegment.start));\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":["f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"535df84251be5af3be84d750beba0021aff9132d","date":1434649368,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{upperPoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of \n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), cutoffOffset);\n      endPoints.add(onlyEndpoint);\n      // Find an edgepoint\n      // We already have circle plane, which is the definitive determination of the edge of the \"circle\".\n      // Next, compute vertical plane going through origin and the center point (C = 0, D = 0).\n      Plane verticalPlane = Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x, onlyEndpoint.point.y);\n      if (verticalPlane == null) {\n        verticalPlane = new Plane(1.0,0.0);\n      }\n      // Finally, use Plane.findIntersections() to find the intersection points.\n      final GeoPoint edgePoint = onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, verticalPlane);\n      if (edgePoint == null) {\n        throw new RuntimeException(\"Could not find edge point for path endpoint=\"+onlyEndpoint.point+\" cutoffOffset=\"+cutoffOffset+\" planetModel=\"+planetModel);\n      }\n      this.edgePoints = new GeoPoint[]{edgePoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9908748d960ccb7706a20e81289a656237780b6c","date":1435716223,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{upperPoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{upperPoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":["f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3022be5842502b7c2a57a5124199bbc30236f0a0","date":1436724252,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath#done().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath#done().mjava","sourceNew":"  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{upperPoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(points.get(0), upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{upperPoint};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5a7a2bdf7dc2680bbceb7dde026f9856363e0f25":["060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68"],"0fb9dbed1415914caa27460f8abb7afadaa61451":["ab7d51740456adc459ec788c8fe27746bdc60a55"],"fec06d6753751ae302c7d35866763e6cb414112d":["c921d81476f94b6686d3f216daa1f6b076b4a6c0","f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"3022be5842502b7c2a57a5124199bbc30236f0a0":["9908748d960ccb7706a20e81289a656237780b6c"],"535df84251be5af3be84d750beba0021aff9132d":["5a7a2bdf7dc2680bbceb7dde026f9856363e0f25"],"f9f97ca977ad649f14b4f60a888adef2edd7a64e":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68":["fec06d6753751ae302c7d35866763e6cb414112d"],"ab7d51740456adc459ec788c8fe27746bdc60a55":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2997acf74723385bd84aff1ea0b12af4aefde77":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2997acf74723385bd84aff1ea0b12af4aefde77"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"9908748d960ccb7706a20e81289a656237780b6c":["535df84251be5af3be84d750beba0021aff9132d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3022be5842502b7c2a57a5124199bbc30236f0a0"]},"commit2Childs":{"5a7a2bdf7dc2680bbceb7dde026f9856363e0f25":["535df84251be5af3be84d750beba0021aff9132d"],"0fb9dbed1415914caa27460f8abb7afadaa61451":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"fec06d6753751ae302c7d35866763e6cb414112d":["060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68"],"3022be5842502b7c2a57a5124199bbc30236f0a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"535df84251be5af3be84d750beba0021aff9132d":["9908748d960ccb7706a20e81289a656237780b6c"],"f9f97ca977ad649f14b4f60a888adef2edd7a64e":["fec06d6753751ae302c7d35866763e6cb414112d"],"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68":["5a7a2bdf7dc2680bbceb7dde026f9856363e0f25"],"ab7d51740456adc459ec788c8fe27746bdc60a55":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ab7d51740456adc459ec788c8fe27746bdc60a55","c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["fec06d6753751ae302c7d35866763e6cb414112d","f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["e2997acf74723385bd84aff1ea0b12af4aefde77"],"9908748d960ccb7706a20e81289a656237780b6c":["3022be5842502b7c2a57a5124199bbc30236f0a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}