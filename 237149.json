{"path":"solr/core/src/test/org/apache/solr/cloud/TestStressLiveNodes#getCachedLiveNodesFromLocalState(int).mjava","commits":[{"id":"d3726445f8e9a7d398466439f0f84b5bb329fdcc","date":1460555680,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestStressLiveNodes#getCachedLiveNodesFromLocalState(int).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * returns the cached set of live nodes (according to the ZkStateReader in our CloudSolrClient) \n   * as a sorted list. \n   * This is done in a sleep+retry loop until the result matches the expectedCount, or a few iters have passed\n   * (this way we aren't testing how fast the watchers complete, just that they got the correct result)\n   */\n  private static List<String> getCachedLiveNodesFromLocalState(final int expectedCount) throws Exception {\n    ArrayList<String> result = null;\n\n    for (int i = 0; i < 10; i++) {\n      result = new ArrayList<>(CLOUD_CLIENT.getZkStateReader().getClusterState().getLiveNodes());\n      if (expectedCount != result.size()) {\n        log.info(\"sleeping #{} to give watchers a chance to finish: {} != {}\",\n                 i, expectedCount, result.size());\n        Thread.sleep(200);\n      } else {\n        break;\n      }\n    }\n    if (expectedCount != result.size()) {\n      log.error(\"gave up waiting for live nodes to match expected size: {} != {}\",\n                expectedCount, result.size());\n    }\n    Collections.sort(result);\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestStressLiveNodes#getCachedLiveNodesFromLocalState(int).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * returns the cached set of live nodes (according to the ZkStateReader in our CloudSolrClient) \n   * as a sorted list. \n   * This is done in a sleep+retry loop until the result matches the expectedCount, or a few iters have passed\n   * (this way we aren't testing how fast the watchers complete, just that they got the correct result)\n   */\n  private static List<String> getCachedLiveNodesFromLocalState(final int expectedCount) throws Exception {\n    ArrayList<String> result = null;\n\n    for (int i = 0; i < 10; i++) {\n      result = new ArrayList<>(CLOUD_CLIENT.getZkStateReader().getClusterState().getLiveNodes());\n      if (expectedCount != result.size()) {\n        log.info(\"sleeping #{} to give watchers a chance to finish: {} != {}\",\n                 i, expectedCount, result.size());\n        Thread.sleep(200);\n      } else {\n        break;\n      }\n    }\n    if (expectedCount != result.size()) {\n      log.error(\"gave up waiting for live nodes to match expected size: {} != {}\",\n                expectedCount, result.size());\n    }\n    Collections.sort(result);\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestStressLiveNodes#getCachedLiveNodesFromLocalState(int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestStressLiveNodes#getCachedLiveNodesFromLocalState(int).mjava","sourceNew":"  /** \n   * returns the cached set of live nodes (according to the ZkStateReader in our CloudSolrClient) \n   * as a sorted list. \n   * This is done in a sleep+retry loop until the result matches the expectedCount, or a few iters have passed\n   * (this way we aren't testing how fast the watchers complete, just that they got the correct result)\n   */\n  private static List<String> getCachedLiveNodesFromLocalState(final int expectedCount) throws Exception {\n    ArrayList<String> result = null;\n\n    for (int i = 0; i < 10; i++) {\n      result = new ArrayList<>(CLOUD_CLIENT.getZkStateReader().getClusterState().getLiveNodes());\n      if (expectedCount != result.size()) {\n        if (log.isInfoEnabled()) {\n          log.info(\"sleeping #{} to give watchers a chance to finish: {} != {}\",\n              i, expectedCount, result.size());\n        }\n        Thread.sleep(200);\n      } else {\n        break;\n      }\n    }\n    if (expectedCount != result.size()) {\n      log.error(\"gave up waiting for live nodes to match expected size: {} != {}\",\n                expectedCount, result.size());\n    }\n    Collections.sort(result);\n    return result;\n  }\n\n","sourceOld":"  /** \n   * returns the cached set of live nodes (according to the ZkStateReader in our CloudSolrClient) \n   * as a sorted list. \n   * This is done in a sleep+retry loop until the result matches the expectedCount, or a few iters have passed\n   * (this way we aren't testing how fast the watchers complete, just that they got the correct result)\n   */\n  private static List<String> getCachedLiveNodesFromLocalState(final int expectedCount) throws Exception {\n    ArrayList<String> result = null;\n\n    for (int i = 0; i < 10; i++) {\n      result = new ArrayList<>(CLOUD_CLIENT.getZkStateReader().getClusterState().getLiveNodes());\n      if (expectedCount != result.size()) {\n        log.info(\"sleeping #{} to give watchers a chance to finish: {} != {}\",\n                 i, expectedCount, result.size());\n        Thread.sleep(200);\n      } else {\n        break;\n      }\n    }\n    if (expectedCount != result.size()) {\n      log.error(\"gave up waiting for live nodes to match expected size: {} != {}\",\n                expectedCount, result.size());\n    }\n    Collections.sort(result);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}