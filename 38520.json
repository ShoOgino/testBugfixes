{"path":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8471c0f357621e859602d44e1af230581b739319","date":1347468766,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre class=\"prettyprint\">\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbccaf0f052c2a25526a56531803c5ebac7c8f41","date":1363510731,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre class=\"prettyprint\">\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    final int hashPos = findHash(bytes, code);\n    int e = ids[hashPos];\n    \n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre class=\"prettyprint\">\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30fe9fa09df804ce770f1b667401a7a7647301ed","date":1397554534,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre class=\"prettyprint\">\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    final int hashPos = findHash(bytes, code);\n    int e = ids[hashPos];\n    \n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30fe9fa09df804ce770f1b667401a7a7647301ed":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"8471c0f357621e859602d44e1af230581b739319":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["8471c0f357621e859602d44e1af230581b739319"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30fe9fa09df804ce770f1b667401a7a7647301ed"]},"commit2Childs":{"30fe9fa09df804ce770f1b667401a7a7647301ed":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8471c0f357621e859602d44e1af230581b739319":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["8471c0f357621e859602d44e1af230581b739319"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["30fe9fa09df804ce770f1b667401a7a7647301ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}