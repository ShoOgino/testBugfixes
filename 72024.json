{"path":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","commits":[{"id":"e15c57be968dbcac6fd3f87af0bd26a8f023e069","date":1413564565,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testNormMapRandom() {\n    Map<Long,Integer> freqs = new HashMap<>();\n    Map<Long,Integer> ords = new HashMap<>();\n    \n    Set<Long> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      if (random().nextBoolean()) {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE));\n      } else {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Byte.MIN_VALUE, Byte.MAX_VALUE));\n      }\n    }\n    \n    Long uniqueValues[] = uniqueValuesSet.toArray(new Long[uniqueValuesSet.size()]);\n    \n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      long value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      \n      Integer ord = ords.get(value);\n      if (ord == null) {\n        ord = ords.size();\n        ords.put(value, ord);\n        freqs.put(value, 1);\n      } else {\n        freqs.put(value, freqs.get(value)+1);\n      }\n    }\n    \n    // value -> ord\n    assertEquals(ords.size(), map.size);\n    for (Map.Entry<Long,Integer> kv : ords.entrySet()) {\n      assertEquals(kv.getValue().intValue(), map.getOrd(kv.getKey()));\n    }\n    \n    // ord -> value\n    Map<Long,Integer> reversed = new HashMap<>();\n    long table[] = map.getDecodeTable();\n    for (int i = 0; i < map.size; i++) {\n      reversed.put(table[i], i);\n    }\n    assertEquals(ords, reversed);\n    \n    // freqs\n    int freqTable[] = map.getFreqs();\n    for (int i = 0; i < map.size; i++) {\n      assertEquals(freqs.get(table[i]).longValue(), freqTable[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testNormMapRandom() {\n    Map<Long,Integer> freqs = new HashMap<>();\n    Map<Long,Integer> ords = new HashMap<>();\n    \n    Set<Long> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      if (random().nextBoolean()) {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE));\n      } else {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Byte.MIN_VALUE, Byte.MAX_VALUE));\n      }\n    }\n    \n    Long uniqueValues[] = uniqueValuesSet.toArray(new Long[uniqueValuesSet.size()]);\n    \n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      long value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      \n      Integer ord = ords.get(value);\n      if (ord == null) {\n        ord = ords.size();\n        ords.put(value, ord);\n        freqs.put(value, 1);\n      } else {\n        freqs.put(value, freqs.get(value)+1);\n      }\n    }\n    \n    // value -> ord\n    assertEquals(ords.size(), map.size);\n    for (Map.Entry<Long,Integer> kv : ords.entrySet()) {\n      assertEquals(kv.getValue().intValue(), map.getOrd(kv.getKey()));\n    }\n    \n    // ord -> value\n    Map<Long,Integer> reversed = new HashMap<>();\n    long table[] = map.getDecodeTable();\n    for (int i = 0; i < map.size; i++) {\n      reversed.put(table[i], i);\n    }\n    assertEquals(ords, reversed);\n    \n    // freqs\n    int freqTable[] = map.getFreqs();\n    for (int i = 0; i < map.size; i++) {\n      assertEquals(freqs.get(table[i]).longValue(), freqTable[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c3fae32338d82a0710e1756793faba13dcb598b","date":1414786590,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","sourceNew":"  public void testNormMapRandom() {\n\n    Set<Byte> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      uniqueValuesSet.add(Byte.valueOf((byte)TestUtil.nextInt(random(), Byte.MIN_VALUE, Byte.MAX_VALUE)));\n    }\n    Byte uniqueValues[] = uniqueValuesSet.toArray(new Byte[uniqueValuesSet.size()]);\n\n    Map<Byte,Integer> freqs = new HashMap<>();\n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      byte value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      if (freqs.containsKey(value)) {\n        freqs.put(value, freqs.get(value) + 1);\n      } else {\n        freqs.put(value, 1);\n      }\n    }\n\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n\n    // optimizing should reorder ordinals from greatest to least frequency\n    map.optimizeOrdinals();\n    // recheck consistency\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n    // also check descending freq\n    int prevFreq = map.freqs[0];\n    for (int i = 1; i < map.size; ++i) {\n      assertTrue(prevFreq >= map.freqs[i]);\n      prevFreq = map.freqs[i];\n    }\n  }\n\n","sourceOld":"  public void testNormMapRandom() {\n    Map<Long,Integer> freqs = new HashMap<>();\n    Map<Long,Integer> ords = new HashMap<>();\n    \n    Set<Long> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      if (random().nextBoolean()) {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE));\n      } else {\n        uniqueValuesSet.add(TestUtil.nextLong(random(), Byte.MIN_VALUE, Byte.MAX_VALUE));\n      }\n    }\n    \n    Long uniqueValues[] = uniqueValuesSet.toArray(new Long[uniqueValuesSet.size()]);\n    \n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      long value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      \n      Integer ord = ords.get(value);\n      if (ord == null) {\n        ord = ords.size();\n        ords.put(value, ord);\n        freqs.put(value, 1);\n      } else {\n        freqs.put(value, freqs.get(value)+1);\n      }\n    }\n    \n    // value -> ord\n    assertEquals(ords.size(), map.size);\n    for (Map.Entry<Long,Integer> kv : ords.entrySet()) {\n      assertEquals(kv.getValue().intValue(), map.getOrd(kv.getKey()));\n    }\n    \n    // ord -> value\n    Map<Long,Integer> reversed = new HashMap<>();\n    long table[] = map.getDecodeTable();\n    for (int i = 0; i < map.size; i++) {\n      reversed.put(table[i], i);\n    }\n    assertEquals(ords, reversed);\n    \n    // freqs\n    int freqTable[] = map.getFreqs();\n    for (int i = 0; i < map.size; i++) {\n      assertEquals(freqs.get(table[i]).longValue(), freqTable[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9","date":1434069165,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestLucene50NormsFormat#testNormMapRandom().mjava","sourceNew":"  public void testNormMapRandom() {\n\n    Set<Byte> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      uniqueValuesSet.add(Byte.valueOf((byte)TestUtil.nextInt(random(), Byte.MIN_VALUE, Byte.MAX_VALUE)));\n    }\n    Byte uniqueValues[] = uniqueValuesSet.toArray(new Byte[uniqueValuesSet.size()]);\n\n    Map<Byte,Integer> freqs = new HashMap<>();\n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      byte value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      if (freqs.containsKey(value)) {\n        freqs.put(value, freqs.get(value) + 1);\n      } else {\n        freqs.put(value, 1);\n      }\n    }\n\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n\n    // optimizing should reorder ordinals from greatest to least frequency\n    map.optimizeOrdinals();\n    // recheck consistency\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n    // also check descending freq\n    int prevFreq = map.freqs[0];\n    for (int i = 1; i < map.size; ++i) {\n      assertTrue(prevFreq >= map.freqs[i]);\n      prevFreq = map.freqs[i];\n    }\n  }\n\n","sourceOld":"  public void testNormMapRandom() {\n\n    Set<Byte> uniqueValuesSet = new HashSet<>();\n    int numUniqValues = TestUtil.nextInt(random(), 1, 256);\n    for (int i = 0; i < numUniqValues; i++) {\n      uniqueValuesSet.add(Byte.valueOf((byte)TestUtil.nextInt(random(), Byte.MIN_VALUE, Byte.MAX_VALUE)));\n    }\n    Byte uniqueValues[] = uniqueValuesSet.toArray(new Byte[uniqueValuesSet.size()]);\n\n    Map<Byte,Integer> freqs = new HashMap<>();\n    NormMap map = new NormMap();\n    int numdocs = TestUtil.nextInt(random(), 1, 100000);\n    for (int i = 0; i < numdocs; i++) {\n      byte value = uniqueValues[random().nextInt(uniqueValues.length)];\n      // now add to both expected and actual\n      map.add(value);\n      if (freqs.containsKey(value)) {\n        freqs.put(value, freqs.get(value) + 1);\n      } else {\n        freqs.put(value, 1);\n      }\n    }\n\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n\n    // optimizing should reorder ordinals from greatest to least frequency\n    map.optimizeOrdinals();\n    // recheck consistency\n    assertEquals(freqs.size(), map.size);\n    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {\n      byte value = kv.getKey();\n      int freq = kv.getValue();\n      int ord = map.ord(value);\n      assertEquals(freq, map.freqs[ord]);\n      assertEquals(value, map.values[ord]);\n    }\n    // also check descending freq\n    int prevFreq = map.freqs[0];\n    for (int i = 1; i < map.size; ++i) {\n      assertTrue(prevFreq >= map.freqs[i]);\n      prevFreq = map.freqs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9":["0c3fae32338d82a0710e1756793faba13dcb598b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0c3fae32338d82a0710e1756793faba13dcb598b":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"e15c57be968dbcac6fd3f87af0bd26a8f023e069":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e15c57be968dbcac6fd3f87af0bd26a8f023e069"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9"]},"commit2Childs":{"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e15c57be968dbcac6fd3f87af0bd26a8f023e069","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"0c3fae32338d82a0710e1756793faba13dcb598b":["96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9"],"e15c57be968dbcac6fd3f87af0bd26a8f023e069":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["0c3fae32338d82a0710e1756793faba13dcb598b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}