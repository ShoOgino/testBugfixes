{"path":"solr/core/src/test/org/apache/solr/search/ReturnFieldsTest#testWhiteboxSolrDocumentConversion().mjava","commits":[{"id":"b5d3613911d665344055ef7970e1783b3348b5c0","date":1521487734,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/ReturnFieldsTest#testWhiteboxSolrDocumentConversion().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Whitebox verification that the conversion from lucene {@link Document} to {@link SolrDocument} respects\n   * the {@link ReturnFields} and doesn't unneccessarily convert Fields that aren't needed.\n   * <p>\n   * This is important because {@link SolrDocumentFetcher} may return additional fields \n   * (lazy or otherwise) if the document has been cached.\n   * </p>\n   */\n  public void testWhiteboxSolrDocumentConversion() {\n    final IndexSchema schema = h.getCore().getLatestSchema();\n    SolrDocument docOut = null;\n\n    // a \"mock\" Document with a bunch of fields...\n    //\n    // (we can mock this with all StringField instances because convertLuceneDocToSolrDoc only\n    // uses the schema for multivalued-ness)\n    final Document docIn = new Document();\n    final StringBuilder allFieldNames = new StringBuilder();\n    docIn.add(new StringField(\"id\",\"bar\",Store.YES));\n    allFieldNames.append(\"id\");\n    docIn.add(new StringField(\"store_rpt\",\"42\",Store.YES));\n    allFieldNames.append(\",store_rpt\");\n    docIn.add(new StringField(\"subword\",\"bar\",Store.YES)); // single value in multi-value field\n    allFieldNames.append(\",subword\");\n    docIn.add(new StringField(\"uniq\",\"xxx\",Store.YES)); \n    docIn.add(new StringField(\"uniq\",\"yyy\",Store.YES)); // multi-value in multi-valued field\n    allFieldNames.append(\",uniq\");\n    for (int i = 0; i < 20; i++) {\n      final String foo = \"foo_\" + i + \"_s1\";\n      allFieldNames.append(\",\").append(foo);\n      docIn.add(new StringField(foo, \"bar\"+i, Store.YES));\n    }\n\n    // output should only have a single field\n    docOut = convertLuceneDocToSolrDoc(docIn, schema, new SolrReturnFields(req(\"fl\",\"id\")));\n    assertEquals(docOut.toString(), 1, docOut.size());\n    assertEquals(docOut.toString(),\n                 Collections.singleton(\"id\"),\n                 docOut.getFieldNames());\n    assertTrue(docOut.toString(), docOut.get(\"id\") instanceof StringField);\n\n    // output should only have the few specified fields\n    // behavior should be ultimately be consistent for all of these ReturnField instances\n    // (aliasing, extra requested by transformer, or otherwise)\n    for (ReturnFields rf : Arrays.asList\n           (new SolrReturnFields(req(\"fl\",\"id,subword,store_rpt,uniq,foo_2_s1\")),\n            new SolrReturnFields(req(\"fl\",\"id,xxx:[geo f=store_rpt],uniq,foo_2_s1,subword\")),\n            new SolrReturnFields(req(\"fl\",\"id,xxx:subword,uniq,yyy:foo_2_s1,[geo f=store_rpt]\")))) {\n      docOut = convertLuceneDocToSolrDoc(docIn, schema, rf);\n      final String debug = rf.toString() + \" => \" +docOut.toString();\n      assertEquals(debug, 5, docOut.size());\n      assertEquals(debug,\n                   new HashSet<String>(Arrays.asList(\"id\",\"subword\",\"uniq\",\"foo_2_s1\",\"store_rpt\")),\n                   docOut.getFieldNames());\n      assertTrue(debug, docOut.get(\"id\") instanceof StringField);\n      assertTrue(debug, docOut.get(\"store_rpt\") instanceof StringField);\n      assertTrue(debug, docOut.get(\"foo_2_s1\") instanceof StringField);\n      assertTrue(debug, docOut.get(\"subword\") instanceof List);\n      assertTrue(debug, docOut.get(\"uniq\") instanceof List);\n    }\n    \n    // all source fields should be in the output\n    // behavior should be ultimately be consistent for all of these ReturnField instances\n    // (globbing or requesting more fields then doc has)\n    for (ReturnFields rf : Arrays.asList\n           (new SolrReturnFields(),\n            new SolrReturnFields(req()),\n            new SolrReturnFields(req(\"fl\",\"*\")),\n            new SolrReturnFields(req(\"fl\",\"*,score\")),\n            new SolrReturnFields(req(\"fl\",\"id,subword,uniq,foo_*,store_*\")),\n            new SolrReturnFields(req(\"fl\",allFieldNames+\",bogus1,bogus2,bogus3\")))) {\n      \n      docOut = convertLuceneDocToSolrDoc(docIn, schema, rf);\n      final String debug = rf.toString() + \" => \" +docOut.toString();\n      assertEquals(debug, 24, docOut.size());\n      assertTrue(debug, docOut.get(\"id\") instanceof StringField);\n      assertTrue(debug, docOut.get(\"store_rpt\") instanceof StringField);\n      assertTrue(debug, docOut.get(\"subword\") instanceof List);\n      assertTrue(debug, docOut.get(\"uniq\") instanceof List);\n      for (int i = 0; i < 20; i++) {\n        assertTrue(debug, docOut.get(\"foo_\" + i + \"_s1\") instanceof StringField);\n      }\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5d3613911d665344055ef7970e1783b3348b5c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b5d3613911d665344055ef7970e1783b3348b5c0"]},"commit2Childs":{"b5d3613911d665344055ef7970e1783b3348b5c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b5d3613911d665344055ef7970e1783b3348b5c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}