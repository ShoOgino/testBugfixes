{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"/dev/null","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Sort by docID in the leaf so we can delta-vInt encode:\n      sortHeapPointWriter(heapSource, Math.toIntExact(source.start), Math.toIntExact(source.count), -1);\n\n      int lastDocID = 0;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      out.writeVInt(Math.toIntExact(source.count));\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      for (int i=0;i<source.count;i++) {\n        int docID = heapSource.docIDs[Math.toIntExact(source.start + i)];\n        out.writeVInt(docID - lastDocID);\n        lastDocID = docID;\n      }\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        out.writeBytes(scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Sort by docID in the leaf so we can delta-vInt encode:\n      sortHeapPointWriter(heapSource, Math.toIntExact(source.start), Math.toIntExact(source.count), -1);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Sort by docID in the leaf so we can delta-vInt encode:\n      sortHeapPointWriter(heapSource, Math.toIntExact(source.start), Math.toIntExact(source.count), -1);\n\n      int lastDocID = 0;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      out.writeVInt(Math.toIntExact(source.count));\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      for (int i=0;i<source.count;i++) {\n        int docID = heapSource.docIDs[Math.toIntExact(source.start + i)];\n        out.writeVInt(docID - lastDocID);\n        lastDocID = docID;\n      }\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        out.writeBytes(scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Sort by docID in the leaf so we can delta-vInt encode:\n      sortHeapPointWriter(heapSource, Math.toIntExact(source.start), Math.toIntExact(source.count), -1);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9f70b31079ec002469ee49df3b8f9bd8d10df23","date":1447755747,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<source.count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // Now write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, scratchPackedValue, 0, scratchPackedValue.length);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), Math.toIntExact(source.count));\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<source.count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim = split(minPackedValue, maxPackedValue);\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      ordBitSet.clear(0, pointCount);\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d53f98721d7cda12df9fd4b2e8e2c235be9ac494","date":1450448699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71ed6e52e37d9b4719f6038787d6e5958ee86047","date":1457690041,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: we should delta compress / only write suffix bytes, like terms dict (the values will all be \"close together\" since we are at\n      // a leaf cell):\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5df40d9bbc30a168c87a8a2f3d2b4044ed29f107","date":1457696910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<source.count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (int i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b48667e85e0da01192ccb0c3b62f0125c979f3fe","date":1457739814,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575856a9f007b9c35d0113c9e18151b554709ef2","date":1457776622,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      if (numDims > 1) {\n        ordBitSet.clear(0, pointCount);\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ffb58ba57f805651a528311c104f104d9f4573","date":1457861471,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9028cf27fe30db95667505bb92ecaee8fa3aef7","date":1457861734,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n\n      PathSlice source = slices[0];\n\n      if (source.writer instanceof HeapPointWriter == false) {\n        // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n        // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n        source = switchToHeap(source);\n      }\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // First pass: find the per-dim common prefix for all values in this block:\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      for (int i=0;i<count;i++) {\n        if (i == 0) {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratch1);\n        } else {\n          heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n          for(int dim=0;dim<numDims;dim++) {\n            int offset = dim * bytesPerDim;\n            for(int j=0;j<commonPrefixLengths[dim];j++) {\n              if (scratch1[offset+j] != scratchPackedValue[offset+j]) {\n                commonPrefixLengths[dim] = j;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Second pass: write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        // TODO: we could do bulk copying here, avoiding the intermediate copy:\n        heapSource.readPackedValue(Math.toIntExact(source.start + i), scratchPackedValue);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchPackedValue);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchPackedValue, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchPackedValue);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"625a8bc2ca882187a925748c0f3247129c00f1ef","date":1457864898,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          long nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          int nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"739dbfe581cd9ed58cc78180a0a8bf51f6a63b46","date":1457864929,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          long nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          long nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fd704a49b365ee23de059c76ac9050beb643d0c","date":1457873731,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          long nextRightCount = reader.split(source.count, ordBitSet, leftPointWriter, rightPointWriter, dim == dimToClear);\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          // Partition this source according to how the splitDim split the values:\n          long nextRightCount = 0;\n          for (long i=0;i<source.count;i++) {\n            boolean result = reader.next();\n            assert result;\n            byte[] packedValue = reader.packedValue();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            if (ordBitSet.get(ord)) {\n              rightPointWriter.append(packedValue, ord, docID);\n              nextRightCount++;\n              if (dim == dimToClear) {\n                ordBitSet.clear(ord);\n              }\n            } else {\n              leftPointWriter.append(packedValue, ord, docID);\n            }\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start, slices[dim].count);) {\n\n          long nextRightCount = reader.split(source.count, ordBitSet, leftPointWriter, rightPointWriter, dim == dimToClear);\n          if (rightCount != nextRightCount) {\n            throw new IllegalStateException(\"wrong number of points in split: expected=\" + rightCount + \" but actual=\" + nextRightCount);\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n        } catch (Throwable t) {\n          verifyChecksum(t, slices[dim].writer);\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start);) {\n\n          long nextRightCount = reader.split(source.count, ordBitSet, leftPointWriter, rightPointWriter, dim == dimToClear);\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n\n          assert rightCount == nextRightCount: \"rightCount=\" + rightCount + \" nextRightCount=\" + nextRightCount;\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51b2a4c0f6c28a8ba7c41911b421cea2ede8ef40","date":1458553787,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[],List[Closeable]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,PathSlice[],LongBitSet,IndexOutput,byte[],byte[],byte[],long[]).mjava","sourceNew":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     List<Closeable> toCloseHeroically) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0], toCloseHeroically);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim], toCloseHeroically);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice, and we\n          // will re-use its shared reader when visiting it as we recurse:\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        // Not inside the try because we don't want to close this one now, so that after recursion is done,\n        // we will have done a singel full sweep of the file:\n        PointReader reader = slices[dim].writer.getSharedReader(slices[dim].start, slices[dim].count, toCloseHeroically);\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim)) {\n\n          long nextRightCount = reader.split(source.count, ordBitSet, leftPointWriter, rightPointWriter, dim == dimToClear);\n          if (rightCount != nextRightCount) {\n            throw new IllegalStateException(\"wrong number of points in split: expected=\" + rightCount + \" but actual=\" + nextRightCount);\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n        } catch (Throwable t) {\n          verifyChecksum(t, slices[dim].writer);\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs, toCloseHeroically);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs, toCloseHeroically);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** The array (sized numDims) of PathSlice describe the cell we have currently recursed to. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice[] slices,\n                     LongBitSet ordBitSet,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    for(PathSlice slice : slices) {\n      assert slice.count == slices[0].count;\n    }\n\n    if (numDims == 1 && slices[0].writer instanceof OfflinePointWriter && slices[0].count <= maxPointsSortInHeap) {\n      // Special case for 1D, to cutover to heap once we recurse deeply enough:\n      slices[0] = switchToHeap(slices[0]);\n    }\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node: write block\n      for (int dim=0;dim<numDims;dim++) {\n        if (slices[dim].writer instanceof HeapPointWriter == false) {\n          // Adversarial cases can cause this, e.g. very lopsided data, all equal points, such that we started\n          // offline, but then kept splitting only in one dimension, and so never had to rewrite into heap writer\n          slices[dim] = switchToHeap(slices[dim]);\n        }\n\n        PathSlice source = slices[dim];\n\n        HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n        // Find common prefix by comparing first and last values, already sorted in this dimension:\n        heapSource.readPackedValue(Math.toIntExact(source.start), scratch1);\n        heapSource.readPackedValue(Math.toIntExact(source.start + source.count - 1), scratch2);\n\n        int offset = dim * bytesPerDim;\n        commonPrefixLengths[dim] = bytesPerDim;\n        for(int j=0;j<bytesPerDim;j++) {\n          if (scratch1[offset+j] != scratch2[offset+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      PathSlice source = slices[0];\n\n      // We ensured that maxPointsSortInHeap was >= maxPointsInLeafNode, so we better be in heap at this point:\n      HeapPointWriter heapSource = (HeapPointWriter) source.writer;\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n      //System.out.println(\"  write leaf block @ fp=\" + out.getFilePointer());\n\n      // Write docIDs first, as their own chunk, so that at intersect time we can add all docIDs w/o\n      // loading the values:\n      int count = Math.toIntExact(source.count);\n      assert count > 0: \"nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset;\n      writeLeafBlockDocs(out, heapSource.docIDs, Math.toIntExact(source.start), count);\n\n      // TODO: minor opto: we don't really have to write the actual common prefixes, because BKDReader on recursing can regenerate it for us\n      // from the index, much like how terms dict does so from the FST:\n\n      // Write the common prefixes:\n      writeCommonPrefixes(out, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      byte[] lastPackedValue = new byte[bytesPerDim];\n      for (int i=0;i<count;i++) {\n        heapSource.getPackedValueSlice(Math.toIntExact(source.start + i), scratchBytesRef);\n        assert numDims != 1 || valueInOrder(i, lastPackedValue, scratchBytesRef.bytes, scratchBytesRef.offset);\n\n        // Make sure this value does in fact fall within this leaf cell:\n        assert valueInBounds(scratchBytesRef, minPackedValue, maxPackedValue);\n        writeLeafBlockPackedValue(out, commonPrefixLengths, scratchBytesRef.bytes, scratchBytesRef.offset);\n      }\n\n    } else {\n      // Inner node: partition/recurse\n\n      int splitDim;\n      if (numDims > 1) {\n        splitDim = split(minPackedValue, maxPackedValue);\n      } else {\n        splitDim = 0;\n      }\n\n      PathSlice source = slices[splitDim];\n\n      assert nodeID < splitPackedValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitPackedValues.length;\n\n      // How many points will be in the left tree:\n      long rightCount = source.count / 2;\n      long leftCount = source.count - rightCount;\n\n      byte[] splitValue = markRightTree(rightCount, splitDim, source, ordBitSet);\n      int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      System.arraycopy(splitValue, 0, splitPackedValues, address + 1, bytesPerDim);\n\n      // Partition all PathSlice that are not the split dim into sorted left and right sets, so we can recurse:\n\n      PathSlice[] leftSlices = new PathSlice[numDims];\n      PathSlice[] rightSlices = new PathSlice[numDims];\n\n      byte[] minSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);\n\n      byte[] maxSplitPackedValue = new byte[packedBytesLength];\n      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);\n\n      // When we are on this dim, below, we clear the ordBitSet:\n      int dimToClear;\n      if (numDims - 1 == splitDim) {\n        dimToClear = numDims - 2;\n      } else {\n        dimToClear = numDims - 1;\n      }\n\n      for(int dim=0;dim<numDims;dim++) {\n\n        if (dim == splitDim) {\n          // No need to partition on this dim since it's a simple slice of the incoming already sorted slice.\n          leftSlices[dim] = new PathSlice(source.writer, source.start, leftCount);\n          rightSlices[dim] = new PathSlice(source.writer, source.start + leftCount, rightCount);\n          System.arraycopy(splitValue, 0, minSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(splitValue, 0, maxSplitPackedValue, dim*bytesPerDim, bytesPerDim);\n          continue;\n        }\n\n        try (PointWriter leftPointWriter = getPointWriter(leftCount, \"left\" + dim);\n             PointWriter rightPointWriter = getPointWriter(source.count - leftCount, \"right\" + dim);\n             PointReader reader = slices[dim].writer.getReader(slices[dim].start, slices[dim].count);) {\n\n          long nextRightCount = reader.split(source.count, ordBitSet, leftPointWriter, rightPointWriter, dim == dimToClear);\n          if (rightCount != nextRightCount) {\n            throw new IllegalStateException(\"wrong number of points in split: expected=\" + rightCount + \" but actual=\" + nextRightCount);\n          }\n\n          leftSlices[dim] = new PathSlice(leftPointWriter, 0, leftCount);\n          rightSlices[dim] = new PathSlice(rightPointWriter, 0, rightCount);\n        } catch (Throwable t) {\n          verifyChecksum(t, slices[dim].writer);\n        }\n      }\n\n      // Recurse on left tree:\n      build(2*nodeID, leafNodeOffset, leftSlices,\n            ordBitSet, out,\n            minPackedValue, maxSplitPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          leftSlices[dim].writer.destroy();\n        }\n      }\n\n      // TODO: we could \"tail recurse\" here?  have our parent discard its refs as we recurse right?\n      // Recurse on right tree:\n      build(2*nodeID+1, leafNodeOffset, rightSlices,\n            ordBitSet, out,\n            minSplitPackedValue, maxPackedValue,\n            splitPackedValues, leafBlockFPs);\n      for(int dim=0;dim<numDims;dim++) {\n        // Don't destroy the dim we split on because we just re-used what our caller above gave us for that dim:\n        if (dim != splitDim) {\n          rightSlices[dim].writer.destroy();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"51b2a4c0f6c28a8ba7c41911b421cea2ede8ef40":["950b7a6881d14da782b60444c11295e3ec50d41a"],"5df40d9bbc30a168c87a8a2f3d2b4044ed29f107":["71ed6e52e37d9b4719f6038787d6e5958ee86047"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["b9f70b31079ec002469ee49df3b8f9bd8d10df23"],"b48667e85e0da01192ccb0c3b62f0125c979f3fe":["5df40d9bbc30a168c87a8a2f3d2b4044ed29f107"],"625a8bc2ca882187a925748c0f3247129c00f1ef":["b9028cf27fe30db95667505bb92ecaee8fa3aef7"],"575856a9f007b9c35d0113c9e18151b554709ef2":["5df40d9bbc30a168c87a8a2f3d2b4044ed29f107","b48667e85e0da01192ccb0c3b62f0125c979f3fe"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"16ffb58ba57f805651a528311c104f104d9f4573":["575856a9f007b9c35d0113c9e18151b554709ef2"],"b9f70b31079ec002469ee49df3b8f9bd8d10df23":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"b9028cf27fe30db95667505bb92ecaee8fa3aef7":["575856a9f007b9c35d0113c9e18151b554709ef2","16ffb58ba57f805651a528311c104f104d9f4573"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950b7a6881d14da782b60444c11295e3ec50d41a":["9fd704a49b365ee23de059c76ac9050beb643d0c"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"9fd704a49b365ee23de059c76ac9050beb643d0c":["739dbfe581cd9ed58cc78180a0a8bf51f6a63b46"],"739dbfe581cd9ed58cc78180a0a8bf51f6a63b46":["625a8bc2ca882187a925748c0f3247129c00f1ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["51b2a4c0f6c28a8ba7c41911b421cea2ede8ef40"],"71ed6e52e37d9b4719f6038787d6e5958ee86047":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"]},"commit2Childs":{"51b2a4c0f6c28a8ba7c41911b421cea2ede8ef40":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5df40d9bbc30a168c87a8a2f3d2b4044ed29f107":["b48667e85e0da01192ccb0c3b62f0125c979f3fe","575856a9f007b9c35d0113c9e18151b554709ef2"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"],"b48667e85e0da01192ccb0c3b62f0125c979f3fe":["575856a9f007b9c35d0113c9e18151b554709ef2"],"625a8bc2ca882187a925748c0f3247129c00f1ef":["739dbfe581cd9ed58cc78180a0a8bf51f6a63b46"],"575856a9f007b9c35d0113c9e18151b554709ef2":["16ffb58ba57f805651a528311c104f104d9f4573","b9028cf27fe30db95667505bb92ecaee8fa3aef7"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["b9f70b31079ec002469ee49df3b8f9bd8d10df23"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"16ffb58ba57f805651a528311c104f104d9f4573":["b9028cf27fe30db95667505bb92ecaee8fa3aef7"],"b9f70b31079ec002469ee49df3b8f9bd8d10df23":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"b9028cf27fe30db95667505bb92ecaee8fa3aef7":["625a8bc2ca882187a925748c0f3247129c00f1ef"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"950b7a6881d14da782b60444c11295e3ec50d41a":["51b2a4c0f6c28a8ba7c41911b421cea2ede8ef40"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["71ed6e52e37d9b4719f6038787d6e5958ee86047"],"9fd704a49b365ee23de059c76ac9050beb643d0c":["950b7a6881d14da782b60444c11295e3ec50d41a"],"739dbfe581cd9ed58cc78180a0a8bf51f6a63b46":["9fd704a49b365ee23de059c76ac9050beb643d0c"],"71ed6e52e37d9b4719f6038787d6e5958ee86047":["5df40d9bbc30a168c87a8a2f3d2b4044ed29f107"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}