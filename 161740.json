{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeLeafBlockPackedValues(DataOutput,int[],int,int,IntFunction[BytesRef],int).mjava","commits":[{"id":"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b","date":1561536972,"type":0,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeLeafBlockPackedValues(DataOutput,int[],int,int,IntFunction[BytesRef],int).mjava","pathOld":"/dev/null","sourceNew":"  private void writeLeafBlockPackedValues(DataOutput out, int[] commonPrefixLengths, int count, int sortedDim, IntFunction<BytesRef> packedValues, int leafCardinality) throws IOException {\n    int prefixLenSum = Arrays.stream(commonPrefixLengths).sum();\n    if (prefixLenSum == packedBytesLength) {\n      // all values in this block are equal\n      out.writeByte((byte) -1);\n    } else {\n      assert commonPrefixLengths[sortedDim] < bytesPerDim;\n      // estimate if storing the values with cardinality is cheaper than storing all values.\n      int compressedByteOffset = sortedDim * bytesPerDim + commonPrefixLengths[sortedDim];\n      int highCardinalityCost;\n      int lowCardinalityCost;\n      if (count == leafCardinality) {\n        // all values in this block are different\n        highCardinalityCost = 0;\n        lowCardinalityCost = 1;\n      } else {\n        // compute cost of runLen compression\n        int numRunLens = 0;\n        for (int i = 0; i < count; ) {\n          // do run-length compression on the byte at compressedByteOffset\n          int runLen = runLen(packedValues, i, Math.min(i + 0xff, count), compressedByteOffset);\n          assert runLen <= 0xff;\n          numRunLens++;\n          i += runLen;\n        }\n        // Add cost of runLen compression\n        highCardinalityCost = count * (packedBytesLength - prefixLenSum - 1) + 2 * numRunLens;\n        // +1 is the byte needed for storing the cardinality\n        lowCardinalityCost = leafCardinality * (packedBytesLength - prefixLenSum + 1);\n      }\n      if (lowCardinalityCost <= highCardinalityCost) {\n        out.writeByte((byte) -2);\n        writeLowCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, packedValues);\n      } else {\n        out.writeByte((byte) sortedDim);\n        writeHighCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, sortedDim, packedValues, compressedByteOffset);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeLeafBlockPackedValues(DataOutput,int[],int,int,IntFunction[BytesRef],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeLeafBlockPackedValues(DataOutput,int[],int,int,IntFunction[BytesRef],int).mjava","sourceNew":"  private void writeLeafBlockPackedValues(DataOutput out, int[] commonPrefixLengths, int count, int sortedDim, IntFunction<BytesRef> packedValues, int leafCardinality) throws IOException {\n    int prefixLenSum = Arrays.stream(commonPrefixLengths).sum();\n    if (prefixLenSum == config.packedBytesLength) {\n      // all values in this block are equal\n      out.writeByte((byte) -1);\n    } else {\n      assert commonPrefixLengths[sortedDim] < config.bytesPerDim;\n      // estimate if storing the values with cardinality is cheaper than storing all values.\n      int compressedByteOffset = sortedDim * config.bytesPerDim + commonPrefixLengths[sortedDim];\n      int highCardinalityCost;\n      int lowCardinalityCost;\n      if (count == leafCardinality) {\n        // all values in this block are different\n        highCardinalityCost = 0;\n        lowCardinalityCost = 1;\n      } else {\n        // compute cost of runLen compression\n        int numRunLens = 0;\n        for (int i = 0; i < count; ) {\n          // do run-length compression on the byte at compressedByteOffset\n          int runLen = runLen(packedValues, i, Math.min(i + 0xff, count), compressedByteOffset);\n          assert runLen <= 0xff;\n          numRunLens++;\n          i += runLen;\n        }\n        // Add cost of runLen compression\n        highCardinalityCost = count * (config.packedBytesLength - prefixLenSum - 1) + 2 * numRunLens;\n        // +1 is the byte needed for storing the cardinality\n        lowCardinalityCost = leafCardinality * (config.packedBytesLength - prefixLenSum + 1);\n      }\n      if (lowCardinalityCost <= highCardinalityCost) {\n        out.writeByte((byte) -2);\n        writeLowCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, packedValues);\n      } else {\n        out.writeByte((byte) sortedDim);\n        writeHighCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, sortedDim, packedValues, compressedByteOffset);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeLeafBlockPackedValues(DataOutput out, int[] commonPrefixLengths, int count, int sortedDim, IntFunction<BytesRef> packedValues, int leafCardinality) throws IOException {\n    int prefixLenSum = Arrays.stream(commonPrefixLengths).sum();\n    if (prefixLenSum == packedBytesLength) {\n      // all values in this block are equal\n      out.writeByte((byte) -1);\n    } else {\n      assert commonPrefixLengths[sortedDim] < bytesPerDim;\n      // estimate if storing the values with cardinality is cheaper than storing all values.\n      int compressedByteOffset = sortedDim * bytesPerDim + commonPrefixLengths[sortedDim];\n      int highCardinalityCost;\n      int lowCardinalityCost;\n      if (count == leafCardinality) {\n        // all values in this block are different\n        highCardinalityCost = 0;\n        lowCardinalityCost = 1;\n      } else {\n        // compute cost of runLen compression\n        int numRunLens = 0;\n        for (int i = 0; i < count; ) {\n          // do run-length compression on the byte at compressedByteOffset\n          int runLen = runLen(packedValues, i, Math.min(i + 0xff, count), compressedByteOffset);\n          assert runLen <= 0xff;\n          numRunLens++;\n          i += runLen;\n        }\n        // Add cost of runLen compression\n        highCardinalityCost = count * (packedBytesLength - prefixLenSum - 1) + 2 * numRunLens;\n        // +1 is the byte needed for storing the cardinality\n        lowCardinalityCost = leafCardinality * (packedBytesLength - prefixLenSum + 1);\n      }\n      if (lowCardinalityCost <= highCardinalityCost) {\n        out.writeByte((byte) -2);\n        writeLowCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, packedValues);\n      } else {\n        out.writeByte((byte) sortedDim);\n        writeHighCardinalityLeafBlockPackedValues(out, commonPrefixLengths, count, sortedDim, packedValues, compressedByteOffset);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}