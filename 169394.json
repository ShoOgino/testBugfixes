{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","commits":[{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#startPrimary(int).mjava","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","sourceOld":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      // nocommit what if primary node is still running here, and we failed for some other reason?\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","sourceOld":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; shutdown new primary\");\n      ioe.printStackTrace(System.out);\n      newPrimary.shutdown();\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","sourceOld":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      // nocommit what if primary node is still running here, and we failed for some other reason?\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; shutdown new primary\");\n      ioe.printStackTrace(System.out);\n      newPrimary.shutdown();\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","sourceOld":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      // nocommit what if primary node is still running here, and we failed for some other reason?\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"/dev/null","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion + \"; startup marker count \" + markerCount);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    long t0 = System.nanoTime();\n    message(\"top: start translog replay \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; shutdown new primary\");\n      ioe.printStackTrace(System.out);\n      newPrimary.shutdown();\n      return;\n    }\n\n    long t1 = System.nanoTime();\n    message(\"top: done translog replay; took \" + ((t1 - t0)/1000000.0) + \" msec; now publish primary\");\n\n    // Publish new primary only after translog has succeeded in replaying; this is important, for this test anyway, so we keep a \"linear\"\n    // history so enforcing marker counts is correct.  E.g., if we publish first and replay translog concurrently with incoming ops, then\n    // a primary commit that happens while translog is still replaying will incorrectly record the translog loc into the commit user data\n    // when in fact that commit did NOT reflect all prior ops.  So if we crash and start up again from that commit point, we are missing\n    // ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","13ea66b549e25413e4e3057bf3492ab828899110"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","13ea66b549e25413e4e3057bf3492ab828899110"],"13ea66b549e25413e4e3057bf3492ab828899110":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1b0febf62c2d9baeee7db38998d9197700ccbab9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}