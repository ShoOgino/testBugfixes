{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsIntersectTermsEnum#seekToStartTerm(BytesRef).mjava","commits":[{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsIntersectTermsEnum#seekToStartTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  // NOTE: specialized to only doing the first-time\n  // seek, but we could generalize it to allow\n  // arbitrary seekExact/Ceil.  Note that this is a\n  // seekFloor!\n  private void seekToStartTerm(BytesRef target) throws IOException {\n    //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n    assert currentFrame.ord == 0;\n    if (term.length < target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, target.length);\n    }\n    FST.Arc<Output> arc = arcs[0];\n    assert arc == currentFrame.arc;\n\n    for(int idx=0;idx<=target.length;idx++) {\n\n      while (true) {\n        final int savePos = currentFrame.suffixesReader.getPosition();\n        final int saveStartBytePos = currentFrame.startBytePos;\n        final int saveSuffix = currentFrame.suffix;\n        final long saveLastSubFP = currentFrame.lastSubFP;\n        final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n        final boolean isSubBlock = currentFrame.next();\n\n        //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n        term.length = currentFrame.prefix + currentFrame.suffix;\n        if (term.bytes.length < term.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, term.length);\n        }\n        System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n        if (isSubBlock && StringHelper.startsWith(target, term)) {\n          // Recurse\n          //if (DEBUG) System.out.println(\"      recurse!\");\n          currentFrame = pushFrame(getState());\n          break;\n        } else {\n          final int cmp = term.compareTo(target);\n          if (cmp < 0) {\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (!currentFrame.isLastInFloor) {\n                //if (DEBUG) System.out.println(\"  load floorBlock\");\n                currentFrame.loadNextFloorBlock();\n                continue;\n              } else {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              }\n            }\n            continue;\n          } else if (cmp == 0) {\n            //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n            return;\n          } else {\n            // Fallback to prior entry: the semantics of\n            // this method is that the first call to\n            // next() will return the term after the\n            // requested term\n            currentFrame.nextEnt--;\n            currentFrame.lastSubFP = saveLastSubFP;\n            currentFrame.startBytePos = saveStartBytePos;\n            currentFrame.suffix = saveSuffix;\n            currentFrame.suffixesReader.setPosition(savePos);\n            currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            // If the last entry was a block we don't\n            // need to bother recursing and pushing to\n            // the last term under it because the first\n            // next() will simply skip the frame anyway\n            return;\n          }\n        }\n      }\n    }\n\n    assert false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"]},"commit2Childs":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}