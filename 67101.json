{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#commit().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#commit().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void commit() throws IOException {\n\n    synchronized(commitLock) {\n\n      SegmentInfos infos;\n      Collection<String> indexFiles;\n\n      synchronized (this) {\n        infos = ((SegmentInfosSearcherManager) mgr).getCurrentInfos();\n        indexFiles = infos.files(false);\n        deleter.incRef(indexFiles);\n      }\n\n      message(\"top: commit primaryGen=\" + lastPrimaryGen + \" infos=\" + infos.toString() + \" files=\" + indexFiles);\n\n      // fsync all index files we are now referencing\n      dir.sync(indexFiles);\n\n      Map<String,String> commitData = new HashMap<>();\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(lastPrimaryGen));\n      commitData.put(VERSION_KEY, Long.toString(getCurrentSearchingVersion()));\n      infos.setUserData(commitData, false);\n\n      // write and fsync a new segments_N\n      infos.commit(dir);\n\n      // Notify current infos (which may have changed while we were doing dir.sync above) what generation we are up to; this way future\n      // commits are guaranteed to go to the next (unwritten) generations:\n      if (mgr != null) {\n        ((SegmentInfosSearcherManager) mgr).getCurrentInfos().updateGeneration(infos);\n      }\n      String segmentsFileName = infos.getSegmentsFileName();\n      message(\"top: commit wrote segments file \" + segmentsFileName + \" version=\" + infos.getVersion() + \" sis=\" + infos.toString() + \" commitData=\" + commitData);\n      deleter.incRef(Collections.singletonList(segmentsFileName));\n      message(\"top: commit decRef lastCommitFiles=\" + lastCommitFiles);\n      deleter.decRef(lastCommitFiles);\n      lastCommitFiles.clear();\n      lastCommitFiles.addAll(indexFiles);\n      lastCommitFiles.add(segmentsFileName);\n      message(\"top: commit version=\" + infos.getVersion() + \" files now \" + lastCommitFiles);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#commit().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void commit() throws IOException {\n\n    synchronized(commitLock) {\n\n      SegmentInfos infos;\n      Collection<String> indexFiles;\n\n      synchronized (this) {\n        infos = ((SegmentInfosSearcherManager) mgr).getCurrentInfos();\n        indexFiles = infos.files(false);\n        deleter.incRef(indexFiles);\n      }\n\n      message(\"top: commit primaryGen=\" + lastPrimaryGen + \" infos=\" + infos.toString() + \" files=\" + indexFiles);\n\n      // fsync all index files we are now referencing\n      dir.sync(indexFiles);\n\n      Map<String,String> commitData = new HashMap<>();\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(lastPrimaryGen));\n      commitData.put(VERSION_KEY, Long.toString(getCurrentSearchingVersion()));\n      infos.setUserData(commitData, false);\n\n      // write and fsync a new segments_N\n      infos.commit(dir);\n\n      // Notify current infos (which may have changed while we were doing dir.sync above) what generation we are up to; this way future\n      // commits are guaranteed to go to the next (unwritten) generations:\n      if (mgr != null) {\n        ((SegmentInfosSearcherManager) mgr).getCurrentInfos().updateGeneration(infos);\n      }\n      String segmentsFileName = infos.getSegmentsFileName();\n      message(\"top: commit wrote segments file \" + segmentsFileName + \" version=\" + infos.getVersion() + \" sis=\" + infos.toString() + \" commitData=\" + commitData);\n      deleter.incRef(Collections.singletonList(segmentsFileName));\n      message(\"top: commit decRef lastCommitFiles=\" + lastCommitFiles);\n      deleter.decRef(lastCommitFiles);\n      lastCommitFiles.clear();\n      lastCommitFiles.addAll(indexFiles);\n      lastCommitFiles.add(segmentsFileName);\n      message(\"top: commit version=\" + infos.getVersion() + \" files now \" + lastCommitFiles);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}