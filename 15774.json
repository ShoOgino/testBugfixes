{"path":"solr/solrj/src/test/org/noggit/TestJSONParser#testNumbers().mjava","commits":[{"id":"980f4ef5a16664be88d82c37e6af5c49a3d57c9c","date":1557969027,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/noggit/TestJSONParser#testNumbers().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testNumbers() throws IOException {\n    flags = JSONParser.FLAGS_STRICT;\n\n    err(\"[00]\");\n    err(\"[003]\");\n    err(\"[00.3]\");\n    err(\"[1e1.1]\");\n    err(\"[+1]\");\n    err(\"[NaN]\");\n    err(\"[Infinity]\");\n    err(\"[--1]\");\n\n    flags = JSONParser.FLAGS_DEFAULT;\n\n    String lmin    = \"-9223372036854775808\";\n    String lminNot = \"-9223372036854775809\";\n    String lmax    = \"9223372036854775807\";\n    String lmaxNot = \"9223372036854775808\";\n\n    String bignum=\"12345678987654321357975312468642099775533112244668800152637485960987654321\";\n\n    parse(\"[0,1,-1,543,-876]\", new Object[]{a,o(0),o(1),o(-1),o(543),o(-876),A,e});\n    parse(\"[-0]\",new Object[]{a,o(0),A,e});\n\n\n    parse(\"[\"+lmin +\",\" + lmax+\"]\",\n        new Object[]{a,o(Long.MIN_VALUE),o(Long.MAX_VALUE),A,e});\n\n    parse(\"[\"+bignum+\"]\", new Object[]{a,bn(bignum),A,e});\n    parse(\"[\"+\"-\"+bignum+\"]\", new Object[]{a,bn(\"-\"+bignum),A,e});\n\n    parse(\"[\"+lminNot+\"]\",new Object[]{a,bn(lminNot),A,e});\n    parse(\"[\"+lmaxNot+\"]\",new Object[]{a,bn(lmaxNot),A,e});\n\n    parse(\"[\"+lminNot + \",\" + lmaxNot + \"]\",\n        new Object[]{a,bn(lminNot),bn(lmaxNot),A,e});\n\n    // bignum many digits on either side of decimal\n    String t = bignum + \".\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    err(\"[\" + t+\".1\" + \"]\"); // extra decimal\n    err(\"[\" + \"-\"+t+\".1\" + \"]\");\n\n    // bignum exponent w/o fraction\n    t = \"1\" + \"e+\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = \"1\" + \"E+\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = \"1\" + \"e\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = \"1\" + \"E\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = \"1\" + \"e-\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = \"1\" + \"E-\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n\n    t = bignum + \"e+\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = bignum + \"E-\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    t = bignum + \"e\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n\n    t = bignum + \".\" + bignum + \"e\" + bignum;\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n\n    err(\"[1E]\");\n    err(\"[1E-]\");\n    err(\"[1E+]\");\n    err(\"[1E+.3]\");\n    err(\"[1E+0.3]\");\n    err(\"[1E+1e+3]\");\n    err(\"[\"+bignum+\"e\"+\"]\");\n    err(\"[\"+bignum+\"e-\"+\"]\");\n    err(\"[\"+bignum+\"e+\"+\"]\");\n    err(\"[\"+bignum+\".\"+bignum+\".\"+bignum+\"]\");\n\n\n    double[] vals = new double[] {0,0.1,1.1,\n        Double.MAX_VALUE,\n        Double.MIN_VALUE,\n        2.2250738585072014E-308, /* Double.MIN_NORMAL */\n    };\n    for (int i=0; i<vals.length; i++) {\n      double d = vals[i];\n      parse(\"[\"+d+\",\"+-d+\"]\", new Object[]{a,o(d),o(-d),A,e});\n    }\n\n    // MIN_NORMAL has the max number of digits (23), so check that\n    // adding an extra digit causes BIGNUM to be returned.\n    t = \"2.2250738585072014E-308\" + \"0\";\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n    // check it works with a leading zero too\n    t = \"0.2250738585072014E-308\" + \"0\";\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n\n    // check that overflow detection is working properly w/ numbers that don't cause a wrap to negatives\n    // when multiplied by 10\n    t = \"1910151821265210155\" + \"0\";\n    parse(\"[\"+t+\",\"+\"-\"+t+\"]\", new Object[]{a,bn(t),bn(\"-\"+t),A,e});\n\n    for (int i=0; i<1000000; i++) {\n      long val = random().nextLong();\n      String sval = Long.toString(val);\n      JSONParser parser = getParser(\"[\"+val+\"]\");\n      parser.nextEvent();\n      assertTrue(parser.nextEvent() == JSONParser.LONG);\n      if (random().nextBoolean()) {\n        assertEquals(val, parser.getLong());\n      } else {\n        CharArr chars = parser.getNumberChars();\n        assertEquals(sval, chars.toString());\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"980f4ef5a16664be88d82c37e6af5c49a3d57c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["980f4ef5a16664be88d82c37e6af5c49a3d57c9c"]},"commit2Childs":{"980f4ef5a16664be88d82c37e6af5c49a3d57c9c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["980f4ef5a16664be88d82c37e6af5c49a3d57c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}