{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#addMergeRateLimiters(Directory).mjava","commits":[{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#addMergeRateLimiters(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /** Wraps the incoming {@link Directory} so that we assign a per-thread\n   *  {@link MergeRateLimiter} to all created {@link IndexOutput}s. */\n  private Directory addMergeRateLimiters(Directory in) {\n    return new FilterDirectory(in) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        ensureOpen();\n\n        // This Directory is only supposed to be used during merging,\n        // so all writes should have MERGE context, else there is a bug \n        // somewhere that is failing to pass down the right IOContext:\n        assert context.context == IOContext.Context.MERGE: \"got context=\" + context.context;\n        IndexOutput output = in.createOutput(name, context);\n        MergeRateLimiter rateLimiter = rateLimiters.get();\n        assert rateLimiter != null;\n        return new RateLimitedIndexOutput(rateLimiter, output);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db","date":1420822089,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#addMergeRateLimiters(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#addMergeRateLimiters(Directory).mjava","sourceNew":"  /** Wraps the incoming {@link Directory} so that we assign a per-thread\n   *  {@link MergeRateLimiter} to all created {@link IndexOutput}s. */\n  private Directory addMergeRateLimiters(Directory in) {\n    return new FilterDirectory(in) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        ensureOpen();\n\n        // Paranoia defense: if this trips we have a bug somewhere...\n        IndexWriter.this.ensureOpen(false);\n\n        // This Directory is only supposed to be used during merging,\n        // so all writes should have MERGE context, else there is a bug \n        // somewhere that is failing to pass down the right IOContext:\n        assert context.context == IOContext.Context.MERGE: \"got context=\" + context.context;\n\n        MergeRateLimiter rateLimiter = rateLimiters.get();\n        assert rateLimiter != null;\n\n        return new RateLimitedIndexOutput(rateLimiter, in.createOutput(name, context));\n      }\n    };\n  }\n\n","sourceOld":"  /** Wraps the incoming {@link Directory} so that we assign a per-thread\n   *  {@link MergeRateLimiter} to all created {@link IndexOutput}s. */\n  private Directory addMergeRateLimiters(Directory in) {\n    return new FilterDirectory(in) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        ensureOpen();\n\n        // This Directory is only supposed to be used during merging,\n        // so all writes should have MERGE context, else there is a bug \n        // somewhere that is failing to pass down the right IOContext:\n        assert context.context == IOContext.Context.MERGE: \"got context=\" + context.context;\n        IndexOutput output = in.createOutput(name, context);\n        MergeRateLimiter rateLimiter = rateLimiters.get();\n        assert rateLimiter != null;\n        return new RateLimitedIndexOutput(rateLimiter, output);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#wrapForMerge(OneMerge,Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#addMergeRateLimiters(Directory).mjava","sourceNew":"  @Override\n  public Directory wrapForMerge(OneMerge merge, Directory in) {\n    Thread mergeThread = Thread.currentThread();\n    if (!MergeThread.class.isInstance(mergeThread)) {\n      throw new AssertionError(\"wrapForMerge should be called from MergeThread. Current thread: \"\n          + mergeThread);\n    }\n\n    // Return a wrapped Directory which has rate-limited output.\n    RateLimiter rateLimiter = ((MergeThread) mergeThread).rateLimiter;\n    return new FilterDirectory(in) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        ensureOpen();\n\n        // This Directory is only supposed to be used during merging,\n        // so all writes should have MERGE context, else there is a bug \n        // somewhere that is failing to pass down the right IOContext:\n        assert context.context == IOContext.Context.MERGE: \"got context=\" + context.context;\n        \n        // Because rateLimiter is bound to a particular merge thread, this method should\n        // always be called from that context. Verify this.\n        assert mergeThread == Thread.currentThread() : \"Not the same merge thread, current=\"\n          + Thread.currentThread() + \", expected=\" + mergeThread;\n\n        return new RateLimitedIndexOutput(rateLimiter, in.createOutput(name, context));\n      }\n    };\n  }\n\n","sourceOld":"  /** Wraps the incoming {@link Directory} so that we assign a per-thread\n   *  {@link MergeRateLimiter} to all created {@link IndexOutput}s. */\n  private Directory addMergeRateLimiters(Directory in) {\n    return new FilterDirectory(in) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        ensureOpen();\n\n        // Paranoia defense: if this trips we have a bug somewhere...\n        IndexWriter.this.ensureOpen(false);\n\n        // This Directory is only supposed to be used during merging,\n        // so all writes should have MERGE context, else there is a bug \n        // somewhere that is failing to pass down the right IOContext:\n        assert context.context == IOContext.Context.MERGE: \"got context=\" + context.context;\n\n        MergeRateLimiter rateLimiter = rateLimiters.get();\n        assert rateLimiter != null;\n\n        return new RateLimitedIndexOutput(rateLimiter, in.createOutput(name, context));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db"],"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}