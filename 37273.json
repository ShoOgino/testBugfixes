{"path":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","commits":[{"id":"30fd30bfbfa6b9e036bcd99c8339712e965d4a63","date":1351859294,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","pathOld":"/dev/null","sourceNew":"  public void testSingleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    \n    for (int j = 0; j < 2; j++) {\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      int start = writer.startNewSlice();\n      int num = atLeast(100);\n      for (int i = 0; i < num; i++) {\n        writer.writeInt(i);\n      }\n      \n      int upto = writer.getCurrentOffset();\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      reader.reset(start, upto);\n      for (int i = 0; i < num; i++) {\n        assertEquals(i, reader.readInt());\n      }\n      assertTrue(reader.endOfSlice());\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","sourceNew":"  public void testSingleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    \n    for (int j = 0; j < 2; j++) {\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      int start = writer.startNewSlice();\n      int num = atLeast(100);\n      for (int i = 0; i < num; i++) {\n        writer.writeInt(i);\n      }\n      \n      int upto = writer.getCurrentOffset();\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      reader.reset(start, upto);\n      for (int i = 0; i < num; i++) {\n        assertEquals(i, reader.readInt());\n      }\n      assertTrue(reader.endOfSlice());\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE * Integer.BYTES, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSingleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    \n    for (int j = 0; j < 2; j++) {\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      int start = writer.startNewSlice();\n      int num = atLeast(100);\n      for (int i = 0; i < num; i++) {\n        writer.writeInt(i);\n      }\n      \n      int upto = writer.getCurrentOffset();\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      reader.reset(start, upto);\n      for (int i = 0; i < num; i++) {\n        assertEquals(i, reader.readInt());\n      }\n      assertTrue(reader.endOfSlice());\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testSingleWriterReader().mjava","sourceNew":"  public void testSingleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    \n    for (int j = 0; j < 2; j++) {\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      int start = writer.startNewSlice();\n      int num = atLeast(100);\n      for (int i = 0; i < num; i++) {\n        writer.writeInt(i);\n      }\n      \n      int upto = writer.getCurrentOffset();\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      reader.reset(start, upto);\n      for (int i = 0; i < num; i++) {\n        assertEquals(i, reader.readInt());\n      }\n      assertTrue(reader.endOfSlice());\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE * Integer.BYTES, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSingleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    \n    for (int j = 0; j < 2; j++) {\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      int start = writer.startNewSlice();\n      int num = atLeast(100);\n      for (int i = 0; i < num; i++) {\n        writer.writeInt(i);\n      }\n      \n      int upto = writer.getCurrentOffset();\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      reader.reset(start, upto);\n      for (int i = 0; i < num; i++) {\n        assertEquals(i, reader.readInt());\n      }\n      assertTrue(reader.endOfSlice());\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"419a8f52c6635419beb951255cacbbb281044c57":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["419a8f52c6635419beb951255cacbbb281044c57"]},"commit2Childs":{"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63"],"419a8f52c6635419beb951255cacbbb281044c57":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}