{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","commits":[{"id":"de3459a54b4c8751d9ef19b035577e2418064be7","date":1520297996,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private Map<String, String> fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return (Map<String, String>) Utils.fromJSON(data);\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return Collections.emptyMap();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e92ecc804db94989e3c224b898b8dc978ebb584f","14ad5f6d86e47603e934be859694ffbba27cd436"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14ad5f6d86e47603e934be859694ffbba27cd436","date":1522709785,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private Map<String, String> fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        byte[] data = zkClient.getData(znodePath, watcher, null, true);\n        return (Map<String, String>) Utils.fromJSON(data);\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return Collections.emptyMap();\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private Map<String, String> fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return (Map<String, String>) Utils.fromJSON(data);\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return Collections.emptyMap();\n      }\n    }\n  }\n\n","bugFix":["de3459a54b4c8751d9ef19b035577e2418064be7"],"bugIntro":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e92ecc804db94989e3c224b898b8dc978ebb584f","date":1556036948,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private VersionedCollectionProps fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return new VersionedCollectionProps(stat.getVersion(),(Map<String, String>) Utils.fromJSON(data));\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return new VersionedCollectionProps(-1, EMPTY_MAP);\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private Map<String, String> fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        byte[] data = zkClient.getData(znodePath, watcher, null, true);\n        return (Map<String, String>) Utils.fromJSON(data);\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return Collections.emptyMap();\n      }\n    }\n  }\n\n","bugFix":["14ad5f6d86e47603e934be859694ffbba27cd436","de3459a54b4c8751d9ef19b035577e2418064be7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad04daa4b07fab11f19bb17a8b556b0dde898d7f","date":1560262372,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private VersionedCollectionProps fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    // lazy init cache cleaner once we know someone is using collection properties.\n    if (collectionPropsCacheCleaner == null) {\n      synchronized (this) { // There can be only one! :)\n        if (collectionPropsCacheCleaner == null) {\n          collectionPropsCacheCleaner = notifications.submit(new CacheCleaner());\n        }\n      }\n    }\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return new VersionedCollectionProps(stat.getVersion(),(Map<String, String>) Utils.fromJSON(data));\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return new VersionedCollectionProps(-1, EMPTY_MAP);\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private VersionedCollectionProps fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return new VersionedCollectionProps(stat.getVersion(),(Map<String, String>) Utils.fromJSON(data));\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return new VersionedCollectionProps(-1, EMPTY_MAP);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#fetchCollectionProperties(String,Watcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private VersionedCollectionProps fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    // lazy init cache cleaner once we know someone is using collection properties.\n    if (collectionPropsCacheCleaner == null) {\n      synchronized (this) { // There can be only one! :)\n        if (collectionPropsCacheCleaner == null) {\n          collectionPropsCacheCleaner = notifications.submit(new CacheCleaner());\n        }\n      }\n    }\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return new VersionedCollectionProps(stat.getVersion(), (Map<String, String>) Utils.fromJSON(data));\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return new VersionedCollectionProps(-1, EMPTY_MAP);\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private VersionedCollectionProps fetchCollectionProperties(String collection, Watcher watcher) throws KeeperException, InterruptedException {\n    final String znodePath = getCollectionPropsPath(collection);\n    // lazy init cache cleaner once we know someone is using collection properties.\n    if (collectionPropsCacheCleaner == null) {\n      synchronized (this) { // There can be only one! :)\n        if (collectionPropsCacheCleaner == null) {\n          collectionPropsCacheCleaner = notifications.submit(new CacheCleaner());\n        }\n      }\n    }\n    while (true) {\n      try {\n        Stat stat = new Stat();\n        byte[] data = zkClient.getData(znodePath, watcher, stat, true);\n        return new VersionedCollectionProps(stat.getVersion(),(Map<String, String>) Utils.fromJSON(data));\n      } catch (ClassCastException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to parse collection properties for collection \" + collection, e);\n      } catch (KeeperException.NoNodeException e) {\n        if (watcher != null) {\n          // Leave an exists watch in place in case a collectionprops.json is created later.\n          Stat exists = zkClient.exists(znodePath, watcher, true);\n          if (exists != null) {\n            // Rare race condition, we tried to fetch the data and couldn't find it, then we found it exists.\n            // Loop and try again.\n            continue;\n          }\n        }\n        return new VersionedCollectionProps(-1, EMPTY_MAP);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["14ad5f6d86e47603e934be859694ffbba27cd436"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"de3459a54b4c8751d9ef19b035577e2418064be7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14ad5f6d86e47603e934be859694ffbba27cd436":["de3459a54b4c8751d9ef19b035577e2418064be7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2668c99990e4c94a78bac005aa682b7c5986d23a"]},"commit2Childs":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de3459a54b4c8751d9ef19b035577e2418064be7":["14ad5f6d86e47603e934be859694ffbba27cd436"],"14ad5f6d86e47603e934be859694ffbba27cd436":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de3459a54b4c8751d9ef19b035577e2418064be7"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}