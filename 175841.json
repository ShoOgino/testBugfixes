{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","commits":[{"id":"9a9be5565efd659f2400b5f4db5144a4ffa1da3d","date":1429792192,"type":0,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"/dev/null","sourceNew":"  private void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["275019a81d0883a1db4560391b072d1fbe272ec4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b7eb80017f1c5b32035176b965fa0cc0287d04","date":1432069816,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"275019a81d0883a1db4560391b072d1fbe272ec4","date":1432741049,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":["9a9be5565efd659f2400b5f4db5144a4ffa1da3d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"440b2094afe43ded839b3169b865595b1b5c2c8a","date":1434499529,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner(null, null, null);\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4039b5ea46ea51770a47714b5f486a607ffc5a66","date":1438356910,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b","date":1438774486,"type":5,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54","date":1446047031,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, random().nextBoolean());\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, random().nextBoolean());\n      if (asyncId2 != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330, cloudSolrClient));\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26fc9c59806c587f9b96f0ea15fa9a0aa8001568","date":1452027155,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330, cloudSolrClient));\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, random().nextBoolean());\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, random().nextBoolean());\n      if (asyncId2 != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330, cloudSolrClient));\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3088cdaa24ffe3ef44713ac9484114bd56eca2af","date":1453441194,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330, cloudSolrClient));\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      if (asyncId2 != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5719bfb2650ba43855e20564d39873bbbdc7f02c","date":1500676092,"type":4,"author":"Steve Rowe","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getCollection(collectionName).getSlices();\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c717efc76ccf2ea435c52fa36a4774056fe8b4d4","date":1501575440,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testCollectionCreateSearchDelete() throws Exception {\n\n    final String collectionName = \"testcollection\";\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      log.info(\"#### Starting a server\");\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      log.info(\"#### Creating a collection\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, null, null);\n\n      ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // modify/query collection\n      log.info(\"#### updating a querying collection\");\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.forceUpdateCollection(collectionName);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getCollection(collectionName).getSlices();\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      log.info(\"#### Stopping a server\");\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n\n      // re-create a server (to restore original NUM_SERVERS count)\n      log.info(\"#### Starting a server\");\n      startedServer = miniCluster.startJettySolrRunner(jettyToStop);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n      // create it again\n      String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId2, null, null);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // check that there's no left-over state\n      assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["26fc9c59806c587f9b96f0ea15fa9a0aa8001568"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["9a9be5565efd659f2400b5f4db5144a4ffa1da3d"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["a52341299179de5479672f7cf518bf4b173f34b3"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["4039b5ea46ea51770a47714b5f486a607ffc5a66"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"26fc9c59806c587f9b96f0ea15fa9a0aa8001568":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["440b2094afe43ded839b3169b865595b1b5c2c8a"],"440b2094afe43ded839b3169b865595b1b5c2c8a":["275019a81d0883a1db4560391b072d1fbe272ec4"],"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a52341299179de5479672f7cf518bf4b173f34b3":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"9a9be5565efd659f2400b5f4db5144a4ffa1da3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4039b5ea46ea51770a47714b5f486a607ffc5a66":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"275019a81d0883a1db4560391b072d1fbe272ec4":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"]},"commit2Childs":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["936cdd5882761db3b844afd6f84ab81cbb011a75","5719bfb2650ba43855e20564d39873bbbdc7f02c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a52341299179de5479672f7cf518bf4b173f34b3"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["275019a81d0883a1db4560391b072d1fbe272ec4"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"344b0840364d990b29b97467bfcc766ff8325d11":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["26fc9c59806c587f9b96f0ea15fa9a0aa8001568"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"26fc9c59806c587f9b96f0ea15fa9a0aa8001568":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["4039b5ea46ea51770a47714b5f486a607ffc5a66"],"440b2094afe43ded839b3169b865595b1b5c2c8a":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"a52341299179de5479672f7cf518bf4b173f34b3":["344b0840364d990b29b97467bfcc766ff8325d11"],"9a9be5565efd659f2400b5f4db5144a4ffa1da3d":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a9be5565efd659f2400b5f4db5144a4ffa1da3d"],"4039b5ea46ea51770a47714b5f486a607ffc5a66":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"275019a81d0883a1db4560391b072d1fbe272ec4":["440b2094afe43ded839b3169b865595b1b5c2c8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}