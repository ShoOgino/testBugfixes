{"path":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","commits":[{"id":"4f7c8ed26cfbf4007c46fd27a417560e932ab4d8","date":1246360634,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"/dev/null","sourceNew":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = (mayUseTermDocs && reader.hasDeletions()) ? reader.termDocs(null) : null;\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return termDocs.doc();\n          }\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return doc;\n          }\n\n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3a0b8ae4ac997de7adea27f34c380588fa28d646","b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0b8ae4ac997de7adea27f34c380588fa28d646","date":1253188966,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return termDocs.doc();\n          }\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return doc;\n          }\n\n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = (mayUseTermDocs && reader.hasDeletions()) ? reader.termDocs(null) : null;\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return termDocs.doc();\n          }\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return doc;\n          }\n\n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":["4f7c8ed26cfbf4007c46fd27a417560e932ab4d8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"438aef2dc00a23f2716882753fe225fbce4cfbfc","date":1255281460,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return termDocs.doc();\n          }\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int target) throws IOException {\n            return advance(target) != NO_MORE_DOCS;\n          }\n\n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() {\n            return doc;\n          }\n\n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d62b1ed69b2d54a65df6f993499b39562d1dc1f9","date":1255700561,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          public int docID() {\n            return doc;\n          }\n          \n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4f7c8ed26cfbf4007c46fd27a417560e932ab4d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d62b1ed69b2d54a65df6f993499b39562d1dc1f9":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["3a0b8ae4ac997de7adea27f34c380588fa28d646"],"8a9e385641d717e641408d8fbbc62be8fc766357":["d62b1ed69b2d54a65df6f993499b39562d1dc1f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8a9e385641d717e641408d8fbbc62be8fc766357"],"3a0b8ae4ac997de7adea27f34c380588fa28d646":["4f7c8ed26cfbf4007c46fd27a417560e932ab4d8"]},"commit2Childs":{"4f7c8ed26cfbf4007c46fd27a417560e932ab4d8":["3a0b8ae4ac997de7adea27f34c380588fa28d646"],"d62b1ed69b2d54a65df6f993499b39562d1dc1f9":["8a9e385641d717e641408d8fbbc62be8fc766357"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["d62b1ed69b2d54a65df6f993499b39562d1dc1f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f7c8ed26cfbf4007c46fd27a417560e932ab4d8"],"8a9e385641d717e641408d8fbbc62be8fc766357":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3a0b8ae4ac997de7adea27f34c380588fa28d646":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}