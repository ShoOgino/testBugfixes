{"path":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","commits":[{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheHelper().getKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"d211216c83f01894810543d1c107160a9ae3650b":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83870855d82aba6819217abeff5a40779dbb28b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d211216c83f01894810543d1c107160a9ae3650b"]},"commit2Childs":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["d211216c83f01894810543d1c107160a9ae3650b","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d211216c83f01894810543d1c107160a9ae3650b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}