{"path":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","commits":[{"id":"9d22d0f5940f155267b250876fa797ff69e8e6e7","date":1400540695,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","pathOld":"/dev/null","sourceNew":"    public void trackRequestResult(HttpResponse resp, boolean success) {      \n      if (rfTracker != null) {\n        Integer rf = null;\n        if (resp != null) {\n          // need to parse out the rf from requests that were forwards to another leader\n          InputStream inputStream = null;\n          try {\n            inputStream = resp.getEntity().getContent();\n            BinaryResponseParser brp = new BinaryResponseParser();\n            NamedList<Object> nl= brp.processResponse(inputStream, null);\n            Object hdr = nl.get(\"responseHeader\");\n            if (hdr != null && hdr instanceof NamedList) {\n              NamedList<Object> hdrList = (NamedList<Object>)hdr;\n              Object rfObj = hdrList.get(UpdateRequest.REPFACT);\n              if (rfObj != null && rfObj instanceof Integer) {\n                rf = (Integer)rfObj;\n              }\n            }\n          } catch (Exception e) {\n            log.warn(\"Failed to parse response from \"+node+\" during replication factor accounting due to: \"+e);\n          } finally {\n            if (inputStream != null) {\n              try {\n                inputStream.close();\n              } catch (Exception ignore){}\n            }\n          }\n        }\n        rfTracker.trackRequestResult(node, success, rf);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","pathOld":"/dev/null","sourceNew":"    public void trackRequestResult(HttpResponse resp, boolean success) {      \n      if (rfTracker != null) {\n        Integer rf = null;\n        if (resp != null) {\n          // need to parse out the rf from requests that were forwards to another leader\n          InputStream inputStream = null;\n          try {\n            inputStream = resp.getEntity().getContent();\n            BinaryResponseParser brp = new BinaryResponseParser();\n            NamedList<Object> nl= brp.processResponse(inputStream, null);\n            Object hdr = nl.get(\"responseHeader\");\n            if (hdr != null && hdr instanceof NamedList) {\n              NamedList<Object> hdrList = (NamedList<Object>)hdr;\n              Object rfObj = hdrList.get(UpdateRequest.REPFACT);\n              if (rfObj != null && rfObj instanceof Integer) {\n                rf = (Integer)rfObj;\n              }\n            }\n          } catch (Exception e) {\n            log.warn(\"Failed to parse response from \"+node+\" during replication factor accounting due to: \"+e);\n          } finally {\n            if (inputStream != null) {\n              try {\n                inputStream.close();\n              } catch (Exception ignore){}\n            }\n          }\n        }\n        rfTracker.trackRequestResult(node, success, rf);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","sourceNew":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggrator node.\n    public void trackRequestResult(HttpResponse resp, boolean success) {\n\n      // Returing Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(resp);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","sourceOld":"    public void trackRequestResult(HttpResponse resp, boolean success) {      \n      if (rfTracker != null) {\n        Integer rf = null;\n        if (resp != null) {\n          // need to parse out the rf from requests that were forwards to another leader\n          InputStream inputStream = null;\n          try {\n            inputStream = resp.getEntity().getContent();\n            BinaryResponseParser brp = new BinaryResponseParser();\n            NamedList<Object> nl= brp.processResponse(inputStream, null);\n            Object hdr = nl.get(\"responseHeader\");\n            if (hdr != null && hdr instanceof NamedList) {\n              NamedList<Object> hdrList = (NamedList<Object>)hdr;\n              Object rfObj = hdrList.get(UpdateRequest.REPFACT);\n              if (rfObj != null && rfObj instanceof Integer) {\n                rf = (Integer)rfObj;\n              }\n            }\n          } catch (Exception e) {\n            log.warn(\"Failed to parse response from \"+node+\" during replication factor accounting due to: \"+e);\n          } finally {\n            if (inputStream != null) {\n              try {\n                inputStream.close();\n              } catch (Exception ignore){}\n            }\n          }\n        }\n        rfTracker.trackRequestResult(node, success, rf);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43f5f8344e80b4bfb2069917069430266753d2f0","date":1538584815,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","sourceNew":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggregator node.\n    public void trackRequestResult(HttpResponse resp, boolean success) {\n      \n      // Returning Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(resp);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","sourceOld":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggrator node.\n    public void trackRequestResult(HttpResponse resp, boolean success) {\n\n      // Returing Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(resp);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(org.eclipse.jetty.client.api.Response,InputStream,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","sourceNew":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggregator node.\n    public void trackRequestResult(org.eclipse.jetty.client.api.Response resp, InputStream respBody, boolean success) {\n\n      // Returning Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(respBody);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","sourceOld":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggregator node.\n    public void trackRequestResult(HttpResponse resp, boolean success) {\n      \n      // Returning Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(resp);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["43f5f8344e80b4bfb2069917069430266753d2f0"],"43f5f8344e80b4bfb2069917069430266753d2f0":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43f5f8344e80b4bfb2069917069430266753d2f0":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a","b7605579001505896d48b07160075a5c8b8e128e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d22d0f5940f155267b250876fa797ff69e8e6e7","b7605579001505896d48b07160075a5c8b8e128e"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["43f5f8344e80b4bfb2069917069430266753d2f0"],"b7605579001505896d48b07160075a5c8b8e128e":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}